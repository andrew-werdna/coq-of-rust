(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module opcode.
  (* StructTuple
    {
      name := "OpCode";
      const_params := [];
      ty_params := [];
      fields := [ Ty.path "u8" ];
    } *)
  
  Module Impl_core_clone_Clone_for_revm_bytecode_opcode_OpCode.
    Definition Self : Ty.t := Ty.path "revm_bytecode::opcode::OpCode".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.deref (| M.read (| self |) |))) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_revm_bytecode_opcode_OpCode.
  
  Module Impl_core_marker_Copy_for_revm_bytecode_opcode_OpCode.
    Definition Self : Ty.t := Ty.path "revm_bytecode::opcode::OpCode".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_Copy_for_revm_bytecode_opcode_OpCode.
  
  Module Impl_core_fmt_Debug_for_revm_bytecode_opcode_OpCode.
    Definition Self : Ty.t := Ty.path "revm_bytecode::opcode::OpCode".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_tuple_field1_finish",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| Value.String "OpCode" |) |) |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.alloc (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_tuple_field (|
                          M.deref (| M.read (| self |) |),
                          "revm_bytecode::opcode::OpCode",
                          0
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_revm_bytecode_opcode_OpCode.
  
  Module Impl_core_default_Default_for_revm_bytecode_opcode_OpCode.
    Definition Self : Ty.t := Ty.path "revm_bytecode::opcode::OpCode".
    
    (* Default *)
    Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (Value.StructTuple
            "revm_bytecode::opcode::OpCode"
            [
              M.call_closure (|
                Ty.path "u8",
                M.get_trait_method (|
                  "core::default::Default",
                  Ty.path "u8",
                  [],
                  [],
                  "default",
                  [],
                  []
                |),
                []
              |)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::default::Default"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("default", InstanceField.Method default) ].
  End Impl_core_default_Default_for_revm_bytecode_opcode_OpCode.
  
  Module Impl_core_marker_StructuralPartialEq_for_revm_bytecode_opcode_OpCode.
    Definition Self : Ty.t := Ty.path "revm_bytecode::opcode::OpCode".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_revm_bytecode_opcode_OpCode.
  
  Module Impl_core_cmp_PartialEq_for_revm_bytecode_opcode_OpCode.
    Definition Self : Ty.t := Ty.path "revm_bytecode::opcode::OpCode".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          BinOp.eq (|
            M.read (|
              M.SubPointer.get_struct_tuple_field (|
                M.deref (| M.read (| self |) |),
                "revm_bytecode::opcode::OpCode",
                0
              |)
            |),
            M.read (|
              M.SubPointer.get_struct_tuple_field (|
                M.deref (| M.read (| other |) |),
                "revm_bytecode::opcode::OpCode",
                0
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_revm_bytecode_opcode_OpCode.
  
  Module Impl_core_cmp_Eq_for_revm_bytecode_opcode_OpCode.
    Definition Self : Ty.t := Ty.path "revm_bytecode::opcode::OpCode".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_revm_bytecode_opcode_OpCode.
  
  Module Impl_core_cmp_PartialOrd_for_revm_bytecode_opcode_OpCode.
    Definition Self : Ty.t := Ty.path "revm_bytecode::opcode::OpCode".
    
    (* PartialOrd *)
    Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.path "u8",
              [],
              [ Ty.path "u8" ],
              "partial_cmp",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "revm_bytecode::opcode::OpCode",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| other |) |),
                      "revm_bytecode::opcode::OpCode",
                      0
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_for_revm_bytecode_opcode_OpCode.
  
  Module Impl_core_cmp_Ord_for_revm_bytecode_opcode_OpCode.
    Definition Self : Ty.t := Ty.path "revm_bytecode::opcode::OpCode".
    
    (* Ord *)
    Definition cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "core::cmp::Ordering",
            M.get_trait_method (| "core::cmp::Ord", Ty.path "u8", [], [], "cmp", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "revm_bytecode::opcode::OpCode",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| other |) |),
                      "revm_bytecode::opcode::OpCode",
                      0
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Ord"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
  End Impl_core_cmp_Ord_for_revm_bytecode_opcode_OpCode.
  
  Module Impl_core_hash_Hash_for_revm_bytecode_opcode_OpCode.
    Definition Self : Ty.t := Ty.path "revm_bytecode::opcode::OpCode".
    
    (* Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hash", Ty.path "u8", [], [], "hash", [], [ __H ] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "revm_bytecode::opcode::OpCode",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_revm_bytecode_opcode_OpCode.
  
  Module Impl_core_fmt_Display_for_revm_bytecode_opcode_OpCode.
    Definition Self : Ty.t := Ty.path "revm_bytecode::opcode::OpCode".
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            let n = self.get();
            if let Some(val) = OPCODE_INFO[n as usize] {
                f.write_str(val.name())
            } else {
                write!(f, "UNKNOWN(0x{n:02X})")
            }
        }
    *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            let~ n : Ty.path "u8" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "u8",
                  M.get_associated_function (|
                    Ty.path "revm_bytecode::opcode::OpCode",
                    "get",
                    [],
                    []
                  |),
                  [ M.read (| M.deref (| M.read (| self |) |) |) ]
                |)
              |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.SubPointer.get_array_field (|
                        M.get_constant "revm_bytecode::opcode::OPCODE_INFO",
                        M.alloc (| M.cast (Ty.path "usize") (M.read (| n |)) |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let val := M.copy (| γ0_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.call_closure (|
                                Ty.apply (Ty.path "&") [] [ Ty.path "str" ],
                                M.get_associated_function (|
                                  Ty.path "revm_bytecode::opcode::OpCodeInfo",
                                  "name",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, val |) ]
                              |)
                            |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1_formatted",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (| Value.String "UNKNOWN(0x" |);
                                          M.read (| Value.String ")" |)
                                        ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_upper_hex",
                                              [],
                                              [ Ty.path "u8" ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, n |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Placeholder",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Placeholder",
                                              "new",
                                              [],
                                              []
                                            |),
                                            [
                                              Value.Integer IntegerKind.Usize 0;
                                              Value.UnicodeChar 32;
                                              Value.StructTuple
                                                "core::fmt::rt::Alignment::Unknown"
                                                [];
                                              Value.Integer IntegerKind.U32 8;
                                              Value.StructTuple "core::fmt::rt::Count::Implied" [];
                                              Value.StructTuple
                                                "core::fmt::rt::Count::Is"
                                                [ Value.Integer IntegerKind.Usize 2 ]
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |);
                              M.call_closure (|
                                Ty.path "core::fmt::rt::UnsafeArg",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::rt::UnsafeArg",
                                  "new",
                                  [],
                                  []
                                |),
                                []
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Display"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Display_for_revm_bytecode_opcode_OpCode.
  
  Module Impl_revm_bytecode_opcode_OpCode.
    Definition Self : Ty.t := Ty.path "revm_bytecode::opcode::OpCode".
    
    (*
        pub const fn new(opcode: u8) -> Option<Self> {
            match OPCODE_INFO[opcode as usize] {
                Some(_) => Some(Self(opcode)),
                None => None,
            }
        }
    *)
    Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ opcode ] =>
        ltac:(M.monadic
          (let opcode := M.alloc (| opcode |) in
          M.read (|
            M.match_operator (|
              M.SubPointer.get_array_field (|
                M.get_constant "revm_bytecode::opcode::OPCODE_INFO",
                M.alloc (| M.cast (Ty.path "usize") (M.read (| opcode |)) |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [ Value.StructTuple "revm_bytecode::opcode::OpCode" [ M.read (| opcode |) ]
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
    Smpl Add apply AssociatedFunction_new : is_associated.
    
    (*
        pub const fn is_jumpdest(&self) -> bool {
            self.0 == JUMPDEST
        }
    *)
    Definition is_jumpdest (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          BinOp.eq (|
            M.read (|
              M.SubPointer.get_struct_tuple_field (|
                M.deref (| M.read (| self |) |),
                "revm_bytecode::opcode::OpCode",
                0
              |)
            |),
            M.read (| M.get_constant "revm_bytecode::opcode::JUMPDEST" |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_is_jumpdest : M.IsAssociatedFunction Self "is_jumpdest" is_jumpdest.
    Smpl Add apply AssociatedFunction_is_jumpdest : is_associated.
    
    (*
        pub const fn is_jumpdest_by_op(opcode: u8) -> bool {
            if let Some(opcode) = Self::new(opcode) {
                opcode.is_jumpdest()
            } else {
                false
            }
        }
    *)
    Definition is_jumpdest_by_op (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ opcode ] =>
        ltac:(M.monadic
          (let opcode := M.alloc (| opcode |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [ Ty.path "revm_bytecode::opcode::OpCode" ],
                          M.get_associated_function (|
                            Ty.path "revm_bytecode::opcode::OpCode",
                            "new",
                            [],
                            []
                          |),
                          [ M.read (| opcode |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let opcode := M.copy (| γ0_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "bool",
                        M.get_associated_function (|
                          Ty.path "revm_bytecode::opcode::OpCode",
                          "is_jumpdest",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, opcode |) ]
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_is_jumpdest_by_op :
      M.IsAssociatedFunction Self "is_jumpdest_by_op" is_jumpdest_by_op.
    Smpl Add apply AssociatedFunction_is_jumpdest_by_op : is_associated.
    
    (*
        pub const fn is_jump(self) -> bool {
            self.0 == JUMP
        }
    *)
    Definition is_jump (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          BinOp.eq (|
            M.read (|
              M.SubPointer.get_struct_tuple_field (| self, "revm_bytecode::opcode::OpCode", 0 |)
            |),
            M.read (| M.get_constant "revm_bytecode::opcode::JUMP" |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_is_jump : M.IsAssociatedFunction Self "is_jump" is_jump.
    Smpl Add apply AssociatedFunction_is_jump : is_associated.
    
    (*
        pub const fn is_jump_by_op(opcode: u8) -> bool {
            if let Some(opcode) = Self::new(opcode) {
                opcode.is_jump()
            } else {
                false
            }
        }
    *)
    Definition is_jump_by_op (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ opcode ] =>
        ltac:(M.monadic
          (let opcode := M.alloc (| opcode |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [ Ty.path "revm_bytecode::opcode::OpCode" ],
                          M.get_associated_function (|
                            Ty.path "revm_bytecode::opcode::OpCode",
                            "new",
                            [],
                            []
                          |),
                          [ M.read (| opcode |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let opcode := M.copy (| γ0_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "bool",
                        M.get_associated_function (|
                          Ty.path "revm_bytecode::opcode::OpCode",
                          "is_jump",
                          [],
                          []
                        |),
                        [ M.read (| opcode |) ]
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_is_jump_by_op :
      M.IsAssociatedFunction Self "is_jump_by_op" is_jump_by_op.
    Smpl Add apply AssociatedFunction_is_jump_by_op : is_associated.
    
    (*
        pub const fn is_push(self) -> bool {
            self.0 >= PUSH1 && self.0 <= PUSH32
        }
    *)
    Definition is_push (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          LogicalOp.and (|
            BinOp.ge (|
              M.read (|
                M.SubPointer.get_struct_tuple_field (| self, "revm_bytecode::opcode::OpCode", 0 |)
              |),
              M.read (| M.get_constant "revm_bytecode::opcode::PUSH1" |)
            |),
            ltac:(M.monadic
              (BinOp.le (|
                M.read (|
                  M.SubPointer.get_struct_tuple_field (| self, "revm_bytecode::opcode::OpCode", 0 |)
                |),
                M.read (| M.get_constant "revm_bytecode::opcode::PUSH32" |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_is_push : M.IsAssociatedFunction Self "is_push" is_push.
    Smpl Add apply AssociatedFunction_is_push : is_associated.
    
    (*
        pub fn is_push_by_op(opcode: u8) -> bool {
            if let Some(opcode) = Self::new(opcode) {
                opcode.is_push()
            } else {
                false
            }
        }
    *)
    Definition is_push_by_op (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ opcode ] =>
        ltac:(M.monadic
          (let opcode := M.alloc (| opcode |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [ Ty.path "revm_bytecode::opcode::OpCode" ],
                          M.get_associated_function (|
                            Ty.path "revm_bytecode::opcode::OpCode",
                            "new",
                            [],
                            []
                          |),
                          [ M.read (| opcode |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let opcode := M.copy (| γ0_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "bool",
                        M.get_associated_function (|
                          Ty.path "revm_bytecode::opcode::OpCode",
                          "is_push",
                          [],
                          []
                        |),
                        [ M.read (| opcode |) ]
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_is_push_by_op :
      M.IsAssociatedFunction Self "is_push_by_op" is_push_by_op.
    Smpl Add apply AssociatedFunction_is_push_by_op : is_associated.
    
    (*
        pub unsafe fn new_unchecked(opcode: u8) -> Self {
            Self(opcode)
        }
    *)
    Definition new_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ opcode ] =>
        ltac:(M.monadic
          (let opcode := M.alloc (| opcode |) in
          Value.StructTuple "revm_bytecode::opcode::OpCode" [ M.read (| opcode |) ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_new_unchecked :
      M.IsAssociatedFunction Self "new_unchecked" new_unchecked.
    Smpl Add apply AssociatedFunction_new_unchecked : is_associated.
    
    (*
        pub const fn as_str(self) -> &'static str {
            self.info().name()
        }
    *)
    Definition as_str (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.apply (Ty.path "&") [] [ Ty.path "str" ],
            M.get_associated_function (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              "name",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.alloc (|
                  M.call_closure (|
                    Ty.path "revm_bytecode::opcode::OpCodeInfo",
                    M.get_associated_function (|
                      Ty.path "revm_bytecode::opcode::OpCode",
                      "info",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, self |) ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_as_str : M.IsAssociatedFunction Self "as_str" as_str.
    Smpl Add apply AssociatedFunction_as_str : is_associated.
    
    (*
        pub const fn name_by_op(opcode: u8) -> &'static str {
            if let Some(opcode) = Self::new(opcode) {
                opcode.as_str()
            } else {
                "Unknown"
            }
        }
    *)
    Definition name_by_op (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ opcode ] =>
        ltac:(M.monadic
          (let opcode := M.alloc (| opcode |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [ Ty.path "revm_bytecode::opcode::OpCode" ],
                          M.get_associated_function (|
                            Ty.path "revm_bytecode::opcode::OpCode",
                            "new",
                            [],
                            []
                          |),
                          [ M.read (| opcode |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let opcode := M.copy (| γ0_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply (Ty.path "&") [] [ Ty.path "str" ],
                        M.get_associated_function (|
                          Ty.path "revm_bytecode::opcode::OpCode",
                          "as_str",
                          [],
                          []
                        |),
                        [ M.read (| opcode |) ]
                      |)
                    |)));
                fun γ => ltac:(M.monadic (Value.String "Unknown"))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_name_by_op : M.IsAssociatedFunction Self "name_by_op" name_by_op.
    Smpl Add apply AssociatedFunction_name_by_op : is_associated.
    
    (*
        pub const fn inputs(&self) -> u8 {
            self.info().inputs()
        }
    *)
    Definition inputs (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.path "u8",
            M.get_associated_function (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              "inputs",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.alloc (|
                  M.call_closure (|
                    Ty.path "revm_bytecode::opcode::OpCodeInfo",
                    M.get_associated_function (|
                      Ty.path "revm_bytecode::opcode::OpCode",
                      "info",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_inputs : M.IsAssociatedFunction Self "inputs" inputs.
    Smpl Add apply AssociatedFunction_inputs : is_associated.
    
    (*
        pub const fn outputs(&self) -> u8 {
            self.info().outputs()
        }
    *)
    Definition outputs (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.path "u8",
            M.get_associated_function (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              "outputs",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.alloc (|
                  M.call_closure (|
                    Ty.path "revm_bytecode::opcode::OpCodeInfo",
                    M.get_associated_function (|
                      Ty.path "revm_bytecode::opcode::OpCode",
                      "info",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_outputs : M.IsAssociatedFunction Self "outputs" outputs.
    Smpl Add apply AssociatedFunction_outputs : is_associated.
    
    (*
        pub const fn io_diff(&self) -> i16 {
            self.info().io_diff()
        }
    *)
    Definition io_diff (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.path "i16",
            M.get_associated_function (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              "io_diff",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.alloc (|
                  M.call_closure (|
                    Ty.path "revm_bytecode::opcode::OpCodeInfo",
                    M.get_associated_function (|
                      Ty.path "revm_bytecode::opcode::OpCode",
                      "info",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_io_diff : M.IsAssociatedFunction Self "io_diff" io_diff.
    Smpl Add apply AssociatedFunction_io_diff : is_associated.
    
    (*
        pub const fn info_by_op(opcode: u8) -> Option<OpCodeInfo> {
            if let Some(opcode) = Self::new(opcode) {
                Some(opcode.info())
            } else {
                None
            }
        }
    *)
    Definition info_by_op (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ opcode ] =>
        ltac:(M.monadic
          (let opcode := M.alloc (| opcode |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [ Ty.path "revm_bytecode::opcode::OpCode" ],
                          M.get_associated_function (|
                            Ty.path "revm_bytecode::opcode::OpCode",
                            "new",
                            [],
                            []
                          |),
                          [ M.read (| opcode |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let opcode := M.copy (| γ0_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            Ty.path "revm_bytecode::opcode::OpCodeInfo",
                            M.get_associated_function (|
                              Ty.path "revm_bytecode::opcode::OpCode",
                              "info",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, opcode |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_info_by_op : M.IsAssociatedFunction Self "info_by_op" info_by_op.
    Smpl Add apply AssociatedFunction_info_by_op : is_associated.
    
    (*
        pub const fn as_usize(&self) -> usize {
            self.0 as usize
        }
    *)
    Definition as_usize (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.cast
            (Ty.path "usize")
            (M.read (|
              M.SubPointer.get_struct_tuple_field (|
                M.deref (| M.read (| self |) |),
                "revm_bytecode::opcode::OpCode",
                0
              |)
            |))))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_as_usize : M.IsAssociatedFunction Self "as_usize" as_usize.
    Smpl Add apply AssociatedFunction_as_usize : is_associated.
    
    (*
        pub const fn info(&self) -> OpCodeInfo {
            if let Some(t) = OPCODE_INFO[self.0 as usize] {
                t
            } else {
                panic!("opcode not found")
            }
        }
    *)
    Definition info (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.SubPointer.get_array_field (|
                        M.get_constant "revm_bytecode::opcode::OPCODE_INFO",
                        M.alloc (|
                          M.cast
                            (Ty.path "usize")
                            (M.read (|
                              M.SubPointer.get_struct_tuple_field (|
                                M.deref (| M.read (| self |) |),
                                "revm_bytecode::opcode::OpCode",
                                0
                              |)
                            |))
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let t := M.copy (| γ0_0 |) in
                    t));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          Ty.path "never",
                          M.get_function (| "core::panicking::panic_fmt", [], [] |),
                          [
                            M.call_closure (|
                              Ty.path "core::fmt::Arguments",
                              M.get_associated_function (|
                                Ty.path "core::fmt::Arguments",
                                "new_const",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.alloc (|
                                        Value.Array [ M.read (| Value.String "opcode not found" |) ]
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          ]
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_info : M.IsAssociatedFunction Self "info" info.
    Smpl Add apply AssociatedFunction_info : is_associated.
    
    (*
        pub const fn input_output(&self) -> (u8, u8) {
            let info = self.info();
            (info.inputs, info.outputs)
        }
    *)
    Definition input_output (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "revm_bytecode::opcode::OpCodeInfo",
                  M.get_associated_function (|
                    Ty.path "revm_bytecode::opcode::OpCode",
                    "info",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |)
              |) in
            M.alloc (|
              Value.Tuple
                [
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      info,
                      "revm_bytecode::opcode::OpCodeInfo",
                      "inputs"
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      info,
                      "revm_bytecode::opcode::OpCodeInfo",
                      "outputs"
                    |)
                  |)
                ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_input_output : M.IsAssociatedFunction Self "input_output" input_output.
    Smpl Add apply AssociatedFunction_input_output : is_associated.
    
    (*
        pub const fn get(self) -> u8 {
            self.0
        }
    *)
    Definition get (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.SubPointer.get_struct_tuple_field (| self, "revm_bytecode::opcode::OpCode", 0 |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_get : M.IsAssociatedFunction Self "get" get.
    Smpl Add apply AssociatedFunction_get : is_associated.
    
    (*
        pub const fn modifies_memory(&self) -> bool {
            matches!(
                *self,
                OpCode::EXTCODECOPY
                    | OpCode::MLOAD
                    | OpCode::MSTORE
                    | OpCode::MSTORE8
                    | OpCode::MCOPY
                    | OpCode::CODECOPY
                    | OpCode::CALLDATACOPY
                    | OpCode::RETURNDATACOPY
                    | OpCode::CALL
                    | OpCode::CALLCODE
                    | OpCode::DELEGATECALL
                    | OpCode::STATICCALL
                    | OpCode::DATACOPY
                    | OpCode::EOFCREATE
                    | OpCode::RETURNCONTRACT
                    | OpCode::EXTCALL
                    | OpCode::EXTDELEGATECALL
                    | OpCode::EXTSTATICCALL
            )
        }
    *)
    Definition modifies_memory (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.deref (| M.read (| self |) |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.find_or_pattern (|
                      γ,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "revm_bytecode::opcode::OpCode",
                                0
                              |) in
                            let _ :=
                              M.is_constant_or_break_match (|
                                M.read (| γ0_0 |),
                                Value.Integer IntegerKind.U8 60
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "revm_bytecode::opcode::OpCode",
                                0
                              |) in
                            let _ :=
                              M.is_constant_or_break_match (|
                                M.read (| γ0_0 |),
                                Value.Integer IntegerKind.U8 81
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "revm_bytecode::opcode::OpCode",
                                0
                              |) in
                            let _ :=
                              M.is_constant_or_break_match (|
                                M.read (| γ0_0 |),
                                Value.Integer IntegerKind.U8 82
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "revm_bytecode::opcode::OpCode",
                                0
                              |) in
                            let _ :=
                              M.is_constant_or_break_match (|
                                M.read (| γ0_0 |),
                                Value.Integer IntegerKind.U8 83
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "revm_bytecode::opcode::OpCode",
                                0
                              |) in
                            let _ :=
                              M.is_constant_or_break_match (|
                                M.read (| γ0_0 |),
                                Value.Integer IntegerKind.U8 94
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "revm_bytecode::opcode::OpCode",
                                0
                              |) in
                            let _ :=
                              M.is_constant_or_break_match (|
                                M.read (| γ0_0 |),
                                Value.Integer IntegerKind.U8 57
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "revm_bytecode::opcode::OpCode",
                                0
                              |) in
                            let _ :=
                              M.is_constant_or_break_match (|
                                M.read (| γ0_0 |),
                                Value.Integer IntegerKind.U8 55
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "revm_bytecode::opcode::OpCode",
                                0
                              |) in
                            let _ :=
                              M.is_constant_or_break_match (|
                                M.read (| γ0_0 |),
                                Value.Integer IntegerKind.U8 62
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "revm_bytecode::opcode::OpCode",
                                0
                              |) in
                            let _ :=
                              M.is_constant_or_break_match (|
                                M.read (| γ0_0 |),
                                Value.Integer IntegerKind.U8 241
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "revm_bytecode::opcode::OpCode",
                                0
                              |) in
                            let _ :=
                              M.is_constant_or_break_match (|
                                M.read (| γ0_0 |),
                                Value.Integer IntegerKind.U8 242
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "revm_bytecode::opcode::OpCode",
                                0
                              |) in
                            let _ :=
                              M.is_constant_or_break_match (|
                                M.read (| γ0_0 |),
                                Value.Integer IntegerKind.U8 244
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "revm_bytecode::opcode::OpCode",
                                0
                              |) in
                            let _ :=
                              M.is_constant_or_break_match (|
                                M.read (| γ0_0 |),
                                Value.Integer IntegerKind.U8 250
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "revm_bytecode::opcode::OpCode",
                                0
                              |) in
                            let _ :=
                              M.is_constant_or_break_match (|
                                M.read (| γ0_0 |),
                                Value.Integer IntegerKind.U8 211
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "revm_bytecode::opcode::OpCode",
                                0
                              |) in
                            let _ :=
                              M.is_constant_or_break_match (|
                                M.read (| γ0_0 |),
                                Value.Integer IntegerKind.U8 236
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "revm_bytecode::opcode::OpCode",
                                0
                              |) in
                            let _ :=
                              M.is_constant_or_break_match (|
                                M.read (| γ0_0 |),
                                Value.Integer IntegerKind.U8 238
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "revm_bytecode::opcode::OpCode",
                                0
                              |) in
                            let _ :=
                              M.is_constant_or_break_match (|
                                M.read (| γ0_0 |),
                                Value.Integer IntegerKind.U8 248
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "revm_bytecode::opcode::OpCode",
                                0
                              |) in
                            let _ :=
                              M.is_constant_or_break_match (|
                                M.read (| γ0_0 |),
                                Value.Integer IntegerKind.U8 249
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "revm_bytecode::opcode::OpCode",
                                0
                              |) in
                            let _ :=
                              M.is_constant_or_break_match (|
                                M.read (| γ0_0 |),
                                Value.Integer IntegerKind.U8 251
                              |) in
                            Value.Tuple []))
                      ],
                      fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [] => ltac:(M.monadic (M.alloc (| Value.Bool true |)))
                          | _ => M.impossible "wrong number of arguments"
                          end)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_modifies_memory :
      M.IsAssociatedFunction Self "modifies_memory" modifies_memory.
    Smpl Add apply AssociatedFunction_modifies_memory : is_associated.
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_STOP : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 0 ]
          |))).
    
    Axiom AssociatedConstant_value_STOP : M.IsAssociatedConstant Self "value_STOP" value_STOP.
    Smpl Add apply AssociatedConstant_value_STOP : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_ADD : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 1 ]
          |))).
    
    Axiom AssociatedConstant_value_ADD : M.IsAssociatedConstant Self "value_ADD" value_ADD.
    Smpl Add apply AssociatedConstant_value_ADD : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_MUL : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 2 ]
          |))).
    
    Axiom AssociatedConstant_value_MUL : M.IsAssociatedConstant Self "value_MUL" value_MUL.
    Smpl Add apply AssociatedConstant_value_MUL : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_SUB : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 3 ]
          |))).
    
    Axiom AssociatedConstant_value_SUB : M.IsAssociatedConstant Self "value_SUB" value_SUB.
    Smpl Add apply AssociatedConstant_value_SUB : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_DIV : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 4 ]
          |))).
    
    Axiom AssociatedConstant_value_DIV : M.IsAssociatedConstant Self "value_DIV" value_DIV.
    Smpl Add apply AssociatedConstant_value_DIV : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_SDIV : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 5 ]
          |))).
    
    Axiom AssociatedConstant_value_SDIV : M.IsAssociatedConstant Self "value_SDIV" value_SDIV.
    Smpl Add apply AssociatedConstant_value_SDIV : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_MOD : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 6 ]
          |))).
    
    Axiom AssociatedConstant_value_MOD : M.IsAssociatedConstant Self "value_MOD" value_MOD.
    Smpl Add apply AssociatedConstant_value_MOD : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_SMOD : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 7 ]
          |))).
    
    Axiom AssociatedConstant_value_SMOD : M.IsAssociatedConstant Self "value_SMOD" value_SMOD.
    Smpl Add apply AssociatedConstant_value_SMOD : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_ADDMOD : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 8 ]
          |))).
    
    Axiom AssociatedConstant_value_ADDMOD : M.IsAssociatedConstant Self "value_ADDMOD" value_ADDMOD.
    Smpl Add apply AssociatedConstant_value_ADDMOD : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_MULMOD : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 9 ]
          |))).
    
    Axiom AssociatedConstant_value_MULMOD : M.IsAssociatedConstant Self "value_MULMOD" value_MULMOD.
    Smpl Add apply AssociatedConstant_value_MULMOD : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_EXP : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 10 ]
          |))).
    
    Axiom AssociatedConstant_value_EXP : M.IsAssociatedConstant Self "value_EXP" value_EXP.
    Smpl Add apply AssociatedConstant_value_EXP : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_SIGNEXTEND : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 11 ]
          |))).
    
    Axiom AssociatedConstant_value_SIGNEXTEND :
      M.IsAssociatedConstant Self "value_SIGNEXTEND" value_SIGNEXTEND.
    Smpl Add apply AssociatedConstant_value_SIGNEXTEND : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_LT : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 16 ]
          |))).
    
    Axiom AssociatedConstant_value_LT : M.IsAssociatedConstant Self "value_LT" value_LT.
    Smpl Add apply AssociatedConstant_value_LT : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_GT : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 17 ]
          |))).
    
    Axiom AssociatedConstant_value_GT : M.IsAssociatedConstant Self "value_GT" value_GT.
    Smpl Add apply AssociatedConstant_value_GT : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_SLT : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 18 ]
          |))).
    
    Axiom AssociatedConstant_value_SLT : M.IsAssociatedConstant Self "value_SLT" value_SLT.
    Smpl Add apply AssociatedConstant_value_SLT : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_SGT : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 19 ]
          |))).
    
    Axiom AssociatedConstant_value_SGT : M.IsAssociatedConstant Self "value_SGT" value_SGT.
    Smpl Add apply AssociatedConstant_value_SGT : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_EQ : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 20 ]
          |))).
    
    Axiom AssociatedConstant_value_EQ : M.IsAssociatedConstant Self "value_EQ" value_EQ.
    Smpl Add apply AssociatedConstant_value_EQ : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_ISZERO : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 21 ]
          |))).
    
    Axiom AssociatedConstant_value_ISZERO : M.IsAssociatedConstant Self "value_ISZERO" value_ISZERO.
    Smpl Add apply AssociatedConstant_value_ISZERO : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_AND : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 22 ]
          |))).
    
    Axiom AssociatedConstant_value_AND : M.IsAssociatedConstant Self "value_AND" value_AND.
    Smpl Add apply AssociatedConstant_value_AND : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_OR : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 23 ]
          |))).
    
    Axiom AssociatedConstant_value_OR : M.IsAssociatedConstant Self "value_OR" value_OR.
    Smpl Add apply AssociatedConstant_value_OR : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_XOR : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 24 ]
          |))).
    
    Axiom AssociatedConstant_value_XOR : M.IsAssociatedConstant Self "value_XOR" value_XOR.
    Smpl Add apply AssociatedConstant_value_XOR : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_NOT : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 25 ]
          |))).
    
    Axiom AssociatedConstant_value_NOT : M.IsAssociatedConstant Self "value_NOT" value_NOT.
    Smpl Add apply AssociatedConstant_value_NOT : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_BYTE : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 26 ]
          |))).
    
    Axiom AssociatedConstant_value_BYTE : M.IsAssociatedConstant Self "value_BYTE" value_BYTE.
    Smpl Add apply AssociatedConstant_value_BYTE : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_SHL : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 27 ]
          |))).
    
    Axiom AssociatedConstant_value_SHL : M.IsAssociatedConstant Self "value_SHL" value_SHL.
    Smpl Add apply AssociatedConstant_value_SHL : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_SHR : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 28 ]
          |))).
    
    Axiom AssociatedConstant_value_SHR : M.IsAssociatedConstant Self "value_SHR" value_SHR.
    Smpl Add apply AssociatedConstant_value_SHR : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_SAR : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 29 ]
          |))).
    
    Axiom AssociatedConstant_value_SAR : M.IsAssociatedConstant Self "value_SAR" value_SAR.
    Smpl Add apply AssociatedConstant_value_SAR : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_KECCAK256 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 32 ]
          |))).
    
    Axiom AssociatedConstant_value_KECCAK256 :
      M.IsAssociatedConstant Self "value_KECCAK256" value_KECCAK256.
    Smpl Add apply AssociatedConstant_value_KECCAK256 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_ADDRESS : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 48 ]
          |))).
    
    Axiom AssociatedConstant_value_ADDRESS :
      M.IsAssociatedConstant Self "value_ADDRESS" value_ADDRESS.
    Smpl Add apply AssociatedConstant_value_ADDRESS : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_BALANCE : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 49 ]
          |))).
    
    Axiom AssociatedConstant_value_BALANCE :
      M.IsAssociatedConstant Self "value_BALANCE" value_BALANCE.
    Smpl Add apply AssociatedConstant_value_BALANCE : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_ORIGIN : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 50 ]
          |))).
    
    Axiom AssociatedConstant_value_ORIGIN : M.IsAssociatedConstant Self "value_ORIGIN" value_ORIGIN.
    Smpl Add apply AssociatedConstant_value_ORIGIN : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_CALLER : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 51 ]
          |))).
    
    Axiom AssociatedConstant_value_CALLER : M.IsAssociatedConstant Self "value_CALLER" value_CALLER.
    Smpl Add apply AssociatedConstant_value_CALLER : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_CALLVALUE : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 52 ]
          |))).
    
    Axiom AssociatedConstant_value_CALLVALUE :
      M.IsAssociatedConstant Self "value_CALLVALUE" value_CALLVALUE.
    Smpl Add apply AssociatedConstant_value_CALLVALUE : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_CALLDATALOAD : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 53 ]
          |))).
    
    Axiom AssociatedConstant_value_CALLDATALOAD :
      M.IsAssociatedConstant Self "value_CALLDATALOAD" value_CALLDATALOAD.
    Smpl Add apply AssociatedConstant_value_CALLDATALOAD : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_CALLDATASIZE : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 54 ]
          |))).
    
    Axiom AssociatedConstant_value_CALLDATASIZE :
      M.IsAssociatedConstant Self "value_CALLDATASIZE" value_CALLDATASIZE.
    Smpl Add apply AssociatedConstant_value_CALLDATASIZE : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_CALLDATACOPY : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 55 ]
          |))).
    
    Axiom AssociatedConstant_value_CALLDATACOPY :
      M.IsAssociatedConstant Self "value_CALLDATACOPY" value_CALLDATACOPY.
    Smpl Add apply AssociatedConstant_value_CALLDATACOPY : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_CODESIZE : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 56 ]
          |))).
    
    Axiom AssociatedConstant_value_CODESIZE :
      M.IsAssociatedConstant Self "value_CODESIZE" value_CODESIZE.
    Smpl Add apply AssociatedConstant_value_CODESIZE : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_CODECOPY : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 57 ]
          |))).
    
    Axiom AssociatedConstant_value_CODECOPY :
      M.IsAssociatedConstant Self "value_CODECOPY" value_CODECOPY.
    Smpl Add apply AssociatedConstant_value_CODECOPY : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_GASPRICE : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 58 ]
          |))).
    
    Axiom AssociatedConstant_value_GASPRICE :
      M.IsAssociatedConstant Self "value_GASPRICE" value_GASPRICE.
    Smpl Add apply AssociatedConstant_value_GASPRICE : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_EXTCODESIZE : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 59 ]
          |))).
    
    Axiom AssociatedConstant_value_EXTCODESIZE :
      M.IsAssociatedConstant Self "value_EXTCODESIZE" value_EXTCODESIZE.
    Smpl Add apply AssociatedConstant_value_EXTCODESIZE : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_EXTCODECOPY : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 60 ]
          |))).
    
    Axiom AssociatedConstant_value_EXTCODECOPY :
      M.IsAssociatedConstant Self "value_EXTCODECOPY" value_EXTCODECOPY.
    Smpl Add apply AssociatedConstant_value_EXTCODECOPY : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_RETURNDATASIZE : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 61 ]
          |))).
    
    Axiom AssociatedConstant_value_RETURNDATASIZE :
      M.IsAssociatedConstant Self "value_RETURNDATASIZE" value_RETURNDATASIZE.
    Smpl Add apply AssociatedConstant_value_RETURNDATASIZE : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_RETURNDATACOPY : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 62 ]
          |))).
    
    Axiom AssociatedConstant_value_RETURNDATACOPY :
      M.IsAssociatedConstant Self "value_RETURNDATACOPY" value_RETURNDATACOPY.
    Smpl Add apply AssociatedConstant_value_RETURNDATACOPY : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_EXTCODEHASH : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 63 ]
          |))).
    
    Axiom AssociatedConstant_value_EXTCODEHASH :
      M.IsAssociatedConstant Self "value_EXTCODEHASH" value_EXTCODEHASH.
    Smpl Add apply AssociatedConstant_value_EXTCODEHASH : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_BLOCKHASH : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 64 ]
          |))).
    
    Axiom AssociatedConstant_value_BLOCKHASH :
      M.IsAssociatedConstant Self "value_BLOCKHASH" value_BLOCKHASH.
    Smpl Add apply AssociatedConstant_value_BLOCKHASH : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_COINBASE : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 65 ]
          |))).
    
    Axiom AssociatedConstant_value_COINBASE :
      M.IsAssociatedConstant Self "value_COINBASE" value_COINBASE.
    Smpl Add apply AssociatedConstant_value_COINBASE : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_TIMESTAMP : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 66 ]
          |))).
    
    Axiom AssociatedConstant_value_TIMESTAMP :
      M.IsAssociatedConstant Self "value_TIMESTAMP" value_TIMESTAMP.
    Smpl Add apply AssociatedConstant_value_TIMESTAMP : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_NUMBER : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 67 ]
          |))).
    
    Axiom AssociatedConstant_value_NUMBER : M.IsAssociatedConstant Self "value_NUMBER" value_NUMBER.
    Smpl Add apply AssociatedConstant_value_NUMBER : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_DIFFICULTY : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 68 ]
          |))).
    
    Axiom AssociatedConstant_value_DIFFICULTY :
      M.IsAssociatedConstant Self "value_DIFFICULTY" value_DIFFICULTY.
    Smpl Add apply AssociatedConstant_value_DIFFICULTY : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_GASLIMIT : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 69 ]
          |))).
    
    Axiom AssociatedConstant_value_GASLIMIT :
      M.IsAssociatedConstant Self "value_GASLIMIT" value_GASLIMIT.
    Smpl Add apply AssociatedConstant_value_GASLIMIT : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_CHAINID : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 70 ]
          |))).
    
    Axiom AssociatedConstant_value_CHAINID :
      M.IsAssociatedConstant Self "value_CHAINID" value_CHAINID.
    Smpl Add apply AssociatedConstant_value_CHAINID : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_SELFBALANCE : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 71 ]
          |))).
    
    Axiom AssociatedConstant_value_SELFBALANCE :
      M.IsAssociatedConstant Self "value_SELFBALANCE" value_SELFBALANCE.
    Smpl Add apply AssociatedConstant_value_SELFBALANCE : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_BASEFEE : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 72 ]
          |))).
    
    Axiom AssociatedConstant_value_BASEFEE :
      M.IsAssociatedConstant Self "value_BASEFEE" value_BASEFEE.
    Smpl Add apply AssociatedConstant_value_BASEFEE : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_BLOBHASH : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 73 ]
          |))).
    
    Axiom AssociatedConstant_value_BLOBHASH :
      M.IsAssociatedConstant Self "value_BLOBHASH" value_BLOBHASH.
    Smpl Add apply AssociatedConstant_value_BLOBHASH : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_BLOBBASEFEE : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 74 ]
          |))).
    
    Axiom AssociatedConstant_value_BLOBBASEFEE :
      M.IsAssociatedConstant Self "value_BLOBBASEFEE" value_BLOBBASEFEE.
    Smpl Add apply AssociatedConstant_value_BLOBBASEFEE : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_POP : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 80 ]
          |))).
    
    Axiom AssociatedConstant_value_POP : M.IsAssociatedConstant Self "value_POP" value_POP.
    Smpl Add apply AssociatedConstant_value_POP : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_MLOAD : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 81 ]
          |))).
    
    Axiom AssociatedConstant_value_MLOAD : M.IsAssociatedConstant Self "value_MLOAD" value_MLOAD.
    Smpl Add apply AssociatedConstant_value_MLOAD : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_MSTORE : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 82 ]
          |))).
    
    Axiom AssociatedConstant_value_MSTORE : M.IsAssociatedConstant Self "value_MSTORE" value_MSTORE.
    Smpl Add apply AssociatedConstant_value_MSTORE : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_MSTORE8 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 83 ]
          |))).
    
    Axiom AssociatedConstant_value_MSTORE8 :
      M.IsAssociatedConstant Self "value_MSTORE8" value_MSTORE8.
    Smpl Add apply AssociatedConstant_value_MSTORE8 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_SLOAD : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 84 ]
          |))).
    
    Axiom AssociatedConstant_value_SLOAD : M.IsAssociatedConstant Self "value_SLOAD" value_SLOAD.
    Smpl Add apply AssociatedConstant_value_SLOAD : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_SSTORE : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 85 ]
          |))).
    
    Axiom AssociatedConstant_value_SSTORE : M.IsAssociatedConstant Self "value_SSTORE" value_SSTORE.
    Smpl Add apply AssociatedConstant_value_SSTORE : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_JUMP : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 86 ]
          |))).
    
    Axiom AssociatedConstant_value_JUMP : M.IsAssociatedConstant Self "value_JUMP" value_JUMP.
    Smpl Add apply AssociatedConstant_value_JUMP : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_JUMPI : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 87 ]
          |))).
    
    Axiom AssociatedConstant_value_JUMPI : M.IsAssociatedConstant Self "value_JUMPI" value_JUMPI.
    Smpl Add apply AssociatedConstant_value_JUMPI : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_PC : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 88 ]
          |))).
    
    Axiom AssociatedConstant_value_PC : M.IsAssociatedConstant Self "value_PC" value_PC.
    Smpl Add apply AssociatedConstant_value_PC : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_MSIZE : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 89 ]
          |))).
    
    Axiom AssociatedConstant_value_MSIZE : M.IsAssociatedConstant Self "value_MSIZE" value_MSIZE.
    Smpl Add apply AssociatedConstant_value_MSIZE : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_GAS : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 90 ]
          |))).
    
    Axiom AssociatedConstant_value_GAS : M.IsAssociatedConstant Self "value_GAS" value_GAS.
    Smpl Add apply AssociatedConstant_value_GAS : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_JUMPDEST : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 91 ]
          |))).
    
    Axiom AssociatedConstant_value_JUMPDEST :
      M.IsAssociatedConstant Self "value_JUMPDEST" value_JUMPDEST.
    Smpl Add apply AssociatedConstant_value_JUMPDEST : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_TLOAD : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 92 ]
          |))).
    
    Axiom AssociatedConstant_value_TLOAD : M.IsAssociatedConstant Self "value_TLOAD" value_TLOAD.
    Smpl Add apply AssociatedConstant_value_TLOAD : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_TSTORE : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 93 ]
          |))).
    
    Axiom AssociatedConstant_value_TSTORE : M.IsAssociatedConstant Self "value_TSTORE" value_TSTORE.
    Smpl Add apply AssociatedConstant_value_TSTORE : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_MCOPY : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 94 ]
          |))).
    
    Axiom AssociatedConstant_value_MCOPY : M.IsAssociatedConstant Self "value_MCOPY" value_MCOPY.
    Smpl Add apply AssociatedConstant_value_MCOPY : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_PUSH0 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 95 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH0 : M.IsAssociatedConstant Self "value_PUSH0" value_PUSH0.
    Smpl Add apply AssociatedConstant_value_PUSH0 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_PUSH1 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 96 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH1 : M.IsAssociatedConstant Self "value_PUSH1" value_PUSH1.
    Smpl Add apply AssociatedConstant_value_PUSH1 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_PUSH2 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 97 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH2 : M.IsAssociatedConstant Self "value_PUSH2" value_PUSH2.
    Smpl Add apply AssociatedConstant_value_PUSH2 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_PUSH3 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 98 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH3 : M.IsAssociatedConstant Self "value_PUSH3" value_PUSH3.
    Smpl Add apply AssociatedConstant_value_PUSH3 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_PUSH4 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 99 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH4 : M.IsAssociatedConstant Self "value_PUSH4" value_PUSH4.
    Smpl Add apply AssociatedConstant_value_PUSH4 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_PUSH5 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 100 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH5 : M.IsAssociatedConstant Self "value_PUSH5" value_PUSH5.
    Smpl Add apply AssociatedConstant_value_PUSH5 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_PUSH6 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 101 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH6 : M.IsAssociatedConstant Self "value_PUSH6" value_PUSH6.
    Smpl Add apply AssociatedConstant_value_PUSH6 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_PUSH7 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 102 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH7 : M.IsAssociatedConstant Self "value_PUSH7" value_PUSH7.
    Smpl Add apply AssociatedConstant_value_PUSH7 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_PUSH8 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 103 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH8 : M.IsAssociatedConstant Self "value_PUSH8" value_PUSH8.
    Smpl Add apply AssociatedConstant_value_PUSH8 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_PUSH9 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 104 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH9 : M.IsAssociatedConstant Self "value_PUSH9" value_PUSH9.
    Smpl Add apply AssociatedConstant_value_PUSH9 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_PUSH10 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 105 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH10 : M.IsAssociatedConstant Self "value_PUSH10" value_PUSH10.
    Smpl Add apply AssociatedConstant_value_PUSH10 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_PUSH11 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 106 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH11 : M.IsAssociatedConstant Self "value_PUSH11" value_PUSH11.
    Smpl Add apply AssociatedConstant_value_PUSH11 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_PUSH12 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 107 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH12 : M.IsAssociatedConstant Self "value_PUSH12" value_PUSH12.
    Smpl Add apply AssociatedConstant_value_PUSH12 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_PUSH13 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 108 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH13 : M.IsAssociatedConstant Self "value_PUSH13" value_PUSH13.
    Smpl Add apply AssociatedConstant_value_PUSH13 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_PUSH14 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 109 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH14 : M.IsAssociatedConstant Self "value_PUSH14" value_PUSH14.
    Smpl Add apply AssociatedConstant_value_PUSH14 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_PUSH15 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 110 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH15 : M.IsAssociatedConstant Self "value_PUSH15" value_PUSH15.
    Smpl Add apply AssociatedConstant_value_PUSH15 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_PUSH16 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 111 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH16 : M.IsAssociatedConstant Self "value_PUSH16" value_PUSH16.
    Smpl Add apply AssociatedConstant_value_PUSH16 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_PUSH17 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 112 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH17 : M.IsAssociatedConstant Self "value_PUSH17" value_PUSH17.
    Smpl Add apply AssociatedConstant_value_PUSH17 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_PUSH18 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 113 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH18 : M.IsAssociatedConstant Self "value_PUSH18" value_PUSH18.
    Smpl Add apply AssociatedConstant_value_PUSH18 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_PUSH19 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 114 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH19 : M.IsAssociatedConstant Self "value_PUSH19" value_PUSH19.
    Smpl Add apply AssociatedConstant_value_PUSH19 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_PUSH20 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 115 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH20 : M.IsAssociatedConstant Self "value_PUSH20" value_PUSH20.
    Smpl Add apply AssociatedConstant_value_PUSH20 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_PUSH21 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 116 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH21 : M.IsAssociatedConstant Self "value_PUSH21" value_PUSH21.
    Smpl Add apply AssociatedConstant_value_PUSH21 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_PUSH22 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 117 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH22 : M.IsAssociatedConstant Self "value_PUSH22" value_PUSH22.
    Smpl Add apply AssociatedConstant_value_PUSH22 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_PUSH23 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 118 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH23 : M.IsAssociatedConstant Self "value_PUSH23" value_PUSH23.
    Smpl Add apply AssociatedConstant_value_PUSH23 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_PUSH24 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 119 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH24 : M.IsAssociatedConstant Self "value_PUSH24" value_PUSH24.
    Smpl Add apply AssociatedConstant_value_PUSH24 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_PUSH25 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 120 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH25 : M.IsAssociatedConstant Self "value_PUSH25" value_PUSH25.
    Smpl Add apply AssociatedConstant_value_PUSH25 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_PUSH26 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 121 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH26 : M.IsAssociatedConstant Self "value_PUSH26" value_PUSH26.
    Smpl Add apply AssociatedConstant_value_PUSH26 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_PUSH27 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 122 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH27 : M.IsAssociatedConstant Self "value_PUSH27" value_PUSH27.
    Smpl Add apply AssociatedConstant_value_PUSH27 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_PUSH28 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 123 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH28 : M.IsAssociatedConstant Self "value_PUSH28" value_PUSH28.
    Smpl Add apply AssociatedConstant_value_PUSH28 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_PUSH29 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 124 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH29 : M.IsAssociatedConstant Self "value_PUSH29" value_PUSH29.
    Smpl Add apply AssociatedConstant_value_PUSH29 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_PUSH30 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 125 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH30 : M.IsAssociatedConstant Self "value_PUSH30" value_PUSH30.
    Smpl Add apply AssociatedConstant_value_PUSH30 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_PUSH31 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 126 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH31 : M.IsAssociatedConstant Self "value_PUSH31" value_PUSH31.
    Smpl Add apply AssociatedConstant_value_PUSH31 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_PUSH32 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 127 ]
          |))).
    
    Axiom AssociatedConstant_value_PUSH32 : M.IsAssociatedConstant Self "value_PUSH32" value_PUSH32.
    Smpl Add apply AssociatedConstant_value_PUSH32 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_DUP1 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 128 ]
          |))).
    
    Axiom AssociatedConstant_value_DUP1 : M.IsAssociatedConstant Self "value_DUP1" value_DUP1.
    Smpl Add apply AssociatedConstant_value_DUP1 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_DUP2 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 129 ]
          |))).
    
    Axiom AssociatedConstant_value_DUP2 : M.IsAssociatedConstant Self "value_DUP2" value_DUP2.
    Smpl Add apply AssociatedConstant_value_DUP2 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_DUP3 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 130 ]
          |))).
    
    Axiom AssociatedConstant_value_DUP3 : M.IsAssociatedConstant Self "value_DUP3" value_DUP3.
    Smpl Add apply AssociatedConstant_value_DUP3 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_DUP4 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 131 ]
          |))).
    
    Axiom AssociatedConstant_value_DUP4 : M.IsAssociatedConstant Self "value_DUP4" value_DUP4.
    Smpl Add apply AssociatedConstant_value_DUP4 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_DUP5 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 132 ]
          |))).
    
    Axiom AssociatedConstant_value_DUP5 : M.IsAssociatedConstant Self "value_DUP5" value_DUP5.
    Smpl Add apply AssociatedConstant_value_DUP5 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_DUP6 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 133 ]
          |))).
    
    Axiom AssociatedConstant_value_DUP6 : M.IsAssociatedConstant Self "value_DUP6" value_DUP6.
    Smpl Add apply AssociatedConstant_value_DUP6 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_DUP7 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 134 ]
          |))).
    
    Axiom AssociatedConstant_value_DUP7 : M.IsAssociatedConstant Self "value_DUP7" value_DUP7.
    Smpl Add apply AssociatedConstant_value_DUP7 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_DUP8 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 135 ]
          |))).
    
    Axiom AssociatedConstant_value_DUP8 : M.IsAssociatedConstant Self "value_DUP8" value_DUP8.
    Smpl Add apply AssociatedConstant_value_DUP8 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_DUP9 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 136 ]
          |))).
    
    Axiom AssociatedConstant_value_DUP9 : M.IsAssociatedConstant Self "value_DUP9" value_DUP9.
    Smpl Add apply AssociatedConstant_value_DUP9 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_DUP10 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 137 ]
          |))).
    
    Axiom AssociatedConstant_value_DUP10 : M.IsAssociatedConstant Self "value_DUP10" value_DUP10.
    Smpl Add apply AssociatedConstant_value_DUP10 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_DUP11 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 138 ]
          |))).
    
    Axiom AssociatedConstant_value_DUP11 : M.IsAssociatedConstant Self "value_DUP11" value_DUP11.
    Smpl Add apply AssociatedConstant_value_DUP11 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_DUP12 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 139 ]
          |))).
    
    Axiom AssociatedConstant_value_DUP12 : M.IsAssociatedConstant Self "value_DUP12" value_DUP12.
    Smpl Add apply AssociatedConstant_value_DUP12 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_DUP13 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 140 ]
          |))).
    
    Axiom AssociatedConstant_value_DUP13 : M.IsAssociatedConstant Self "value_DUP13" value_DUP13.
    Smpl Add apply AssociatedConstant_value_DUP13 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_DUP14 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 141 ]
          |))).
    
    Axiom AssociatedConstant_value_DUP14 : M.IsAssociatedConstant Self "value_DUP14" value_DUP14.
    Smpl Add apply AssociatedConstant_value_DUP14 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_DUP15 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 142 ]
          |))).
    
    Axiom AssociatedConstant_value_DUP15 : M.IsAssociatedConstant Self "value_DUP15" value_DUP15.
    Smpl Add apply AssociatedConstant_value_DUP15 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_DUP16 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 143 ]
          |))).
    
    Axiom AssociatedConstant_value_DUP16 : M.IsAssociatedConstant Self "value_DUP16" value_DUP16.
    Smpl Add apply AssociatedConstant_value_DUP16 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_SWAP1 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 144 ]
          |))).
    
    Axiom AssociatedConstant_value_SWAP1 : M.IsAssociatedConstant Self "value_SWAP1" value_SWAP1.
    Smpl Add apply AssociatedConstant_value_SWAP1 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_SWAP2 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 145 ]
          |))).
    
    Axiom AssociatedConstant_value_SWAP2 : M.IsAssociatedConstant Self "value_SWAP2" value_SWAP2.
    Smpl Add apply AssociatedConstant_value_SWAP2 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_SWAP3 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 146 ]
          |))).
    
    Axiom AssociatedConstant_value_SWAP3 : M.IsAssociatedConstant Self "value_SWAP3" value_SWAP3.
    Smpl Add apply AssociatedConstant_value_SWAP3 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_SWAP4 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 147 ]
          |))).
    
    Axiom AssociatedConstant_value_SWAP4 : M.IsAssociatedConstant Self "value_SWAP4" value_SWAP4.
    Smpl Add apply AssociatedConstant_value_SWAP4 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_SWAP5 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 148 ]
          |))).
    
    Axiom AssociatedConstant_value_SWAP5 : M.IsAssociatedConstant Self "value_SWAP5" value_SWAP5.
    Smpl Add apply AssociatedConstant_value_SWAP5 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_SWAP6 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 149 ]
          |))).
    
    Axiom AssociatedConstant_value_SWAP6 : M.IsAssociatedConstant Self "value_SWAP6" value_SWAP6.
    Smpl Add apply AssociatedConstant_value_SWAP6 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_SWAP7 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 150 ]
          |))).
    
    Axiom AssociatedConstant_value_SWAP7 : M.IsAssociatedConstant Self "value_SWAP7" value_SWAP7.
    Smpl Add apply AssociatedConstant_value_SWAP7 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_SWAP8 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 151 ]
          |))).
    
    Axiom AssociatedConstant_value_SWAP8 : M.IsAssociatedConstant Self "value_SWAP8" value_SWAP8.
    Smpl Add apply AssociatedConstant_value_SWAP8 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_SWAP9 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 152 ]
          |))).
    
    Axiom AssociatedConstant_value_SWAP9 : M.IsAssociatedConstant Self "value_SWAP9" value_SWAP9.
    Smpl Add apply AssociatedConstant_value_SWAP9 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_SWAP10 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 153 ]
          |))).
    
    Axiom AssociatedConstant_value_SWAP10 : M.IsAssociatedConstant Self "value_SWAP10" value_SWAP10.
    Smpl Add apply AssociatedConstant_value_SWAP10 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_SWAP11 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 154 ]
          |))).
    
    Axiom AssociatedConstant_value_SWAP11 : M.IsAssociatedConstant Self "value_SWAP11" value_SWAP11.
    Smpl Add apply AssociatedConstant_value_SWAP11 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_SWAP12 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 155 ]
          |))).
    
    Axiom AssociatedConstant_value_SWAP12 : M.IsAssociatedConstant Self "value_SWAP12" value_SWAP12.
    Smpl Add apply AssociatedConstant_value_SWAP12 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_SWAP13 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 156 ]
          |))).
    
    Axiom AssociatedConstant_value_SWAP13 : M.IsAssociatedConstant Self "value_SWAP13" value_SWAP13.
    Smpl Add apply AssociatedConstant_value_SWAP13 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_SWAP14 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 157 ]
          |))).
    
    Axiom AssociatedConstant_value_SWAP14 : M.IsAssociatedConstant Self "value_SWAP14" value_SWAP14.
    Smpl Add apply AssociatedConstant_value_SWAP14 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_SWAP15 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 158 ]
          |))).
    
    Axiom AssociatedConstant_value_SWAP15 : M.IsAssociatedConstant Self "value_SWAP15" value_SWAP15.
    Smpl Add apply AssociatedConstant_value_SWAP15 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_SWAP16 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 159 ]
          |))).
    
    Axiom AssociatedConstant_value_SWAP16 : M.IsAssociatedConstant Self "value_SWAP16" value_SWAP16.
    Smpl Add apply AssociatedConstant_value_SWAP16 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_LOG0 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 160 ]
          |))).
    
    Axiom AssociatedConstant_value_LOG0 : M.IsAssociatedConstant Self "value_LOG0" value_LOG0.
    Smpl Add apply AssociatedConstant_value_LOG0 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_LOG1 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 161 ]
          |))).
    
    Axiom AssociatedConstant_value_LOG1 : M.IsAssociatedConstant Self "value_LOG1" value_LOG1.
    Smpl Add apply AssociatedConstant_value_LOG1 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_LOG2 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 162 ]
          |))).
    
    Axiom AssociatedConstant_value_LOG2 : M.IsAssociatedConstant Self "value_LOG2" value_LOG2.
    Smpl Add apply AssociatedConstant_value_LOG2 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_LOG3 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 163 ]
          |))).
    
    Axiom AssociatedConstant_value_LOG3 : M.IsAssociatedConstant Self "value_LOG3" value_LOG3.
    Smpl Add apply AssociatedConstant_value_LOG3 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_LOG4 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 164 ]
          |))).
    
    Axiom AssociatedConstant_value_LOG4 : M.IsAssociatedConstant Self "value_LOG4" value_LOG4.
    Smpl Add apply AssociatedConstant_value_LOG4 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_DATALOAD : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 208 ]
          |))).
    
    Axiom AssociatedConstant_value_DATALOAD :
      M.IsAssociatedConstant Self "value_DATALOAD" value_DATALOAD.
    Smpl Add apply AssociatedConstant_value_DATALOAD : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_DATALOADN : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 209 ]
          |))).
    
    Axiom AssociatedConstant_value_DATALOADN :
      M.IsAssociatedConstant Self "value_DATALOADN" value_DATALOADN.
    Smpl Add apply AssociatedConstant_value_DATALOADN : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_DATASIZE : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 210 ]
          |))).
    
    Axiom AssociatedConstant_value_DATASIZE :
      M.IsAssociatedConstant Self "value_DATASIZE" value_DATASIZE.
    Smpl Add apply AssociatedConstant_value_DATASIZE : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_DATACOPY : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 211 ]
          |))).
    
    Axiom AssociatedConstant_value_DATACOPY :
      M.IsAssociatedConstant Self "value_DATACOPY" value_DATACOPY.
    Smpl Add apply AssociatedConstant_value_DATACOPY : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_RJUMP : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 224 ]
          |))).
    
    Axiom AssociatedConstant_value_RJUMP : M.IsAssociatedConstant Self "value_RJUMP" value_RJUMP.
    Smpl Add apply AssociatedConstant_value_RJUMP : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_RJUMPI : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 225 ]
          |))).
    
    Axiom AssociatedConstant_value_RJUMPI : M.IsAssociatedConstant Self "value_RJUMPI" value_RJUMPI.
    Smpl Add apply AssociatedConstant_value_RJUMPI : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_RJUMPV : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 226 ]
          |))).
    
    Axiom AssociatedConstant_value_RJUMPV : M.IsAssociatedConstant Self "value_RJUMPV" value_RJUMPV.
    Smpl Add apply AssociatedConstant_value_RJUMPV : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_CALLF : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 227 ]
          |))).
    
    Axiom AssociatedConstant_value_CALLF : M.IsAssociatedConstant Self "value_CALLF" value_CALLF.
    Smpl Add apply AssociatedConstant_value_CALLF : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_RETF : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 228 ]
          |))).
    
    Axiom AssociatedConstant_value_RETF : M.IsAssociatedConstant Self "value_RETF" value_RETF.
    Smpl Add apply AssociatedConstant_value_RETF : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_JUMPF : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 229 ]
          |))).
    
    Axiom AssociatedConstant_value_JUMPF : M.IsAssociatedConstant Self "value_JUMPF" value_JUMPF.
    Smpl Add apply AssociatedConstant_value_JUMPF : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_DUPN : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 230 ]
          |))).
    
    Axiom AssociatedConstant_value_DUPN : M.IsAssociatedConstant Self "value_DUPN" value_DUPN.
    Smpl Add apply AssociatedConstant_value_DUPN : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_SWAPN : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 231 ]
          |))).
    
    Axiom AssociatedConstant_value_SWAPN : M.IsAssociatedConstant Self "value_SWAPN" value_SWAPN.
    Smpl Add apply AssociatedConstant_value_SWAPN : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_EXCHANGE : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 232 ]
          |))).
    
    Axiom AssociatedConstant_value_EXCHANGE :
      M.IsAssociatedConstant Self "value_EXCHANGE" value_EXCHANGE.
    Smpl Add apply AssociatedConstant_value_EXCHANGE : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_EOFCREATE : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 236 ]
          |))).
    
    Axiom AssociatedConstant_value_EOFCREATE :
      M.IsAssociatedConstant Self "value_EOFCREATE" value_EOFCREATE.
    Smpl Add apply AssociatedConstant_value_EOFCREATE : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_RETURNCONTRACT : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 238 ]
          |))).
    
    Axiom AssociatedConstant_value_RETURNCONTRACT :
      M.IsAssociatedConstant Self "value_RETURNCONTRACT" value_RETURNCONTRACT.
    Smpl Add apply AssociatedConstant_value_RETURNCONTRACT : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_CREATE : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 240 ]
          |))).
    
    Axiom AssociatedConstant_value_CREATE : M.IsAssociatedConstant Self "value_CREATE" value_CREATE.
    Smpl Add apply AssociatedConstant_value_CREATE : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_CALL : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 241 ]
          |))).
    
    Axiom AssociatedConstant_value_CALL : M.IsAssociatedConstant Self "value_CALL" value_CALL.
    Smpl Add apply AssociatedConstant_value_CALL : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_CALLCODE : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 242 ]
          |))).
    
    Axiom AssociatedConstant_value_CALLCODE :
      M.IsAssociatedConstant Self "value_CALLCODE" value_CALLCODE.
    Smpl Add apply AssociatedConstant_value_CALLCODE : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_RETURN : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 243 ]
          |))).
    
    Axiom AssociatedConstant_value_RETURN : M.IsAssociatedConstant Self "value_RETURN" value_RETURN.
    Smpl Add apply AssociatedConstant_value_RETURN : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_DELEGATECALL : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 244 ]
          |))).
    
    Axiom AssociatedConstant_value_DELEGATECALL :
      M.IsAssociatedConstant Self "value_DELEGATECALL" value_DELEGATECALL.
    Smpl Add apply AssociatedConstant_value_DELEGATECALL : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_CREATE2 : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 245 ]
          |))).
    
    Axiom AssociatedConstant_value_CREATE2 :
      M.IsAssociatedConstant Self "value_CREATE2" value_CREATE2.
    Smpl Add apply AssociatedConstant_value_CREATE2 : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_RETURNDATALOAD : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 247 ]
          |))).
    
    Axiom AssociatedConstant_value_RETURNDATALOAD :
      M.IsAssociatedConstant Self "value_RETURNDATALOAD" value_RETURNDATALOAD.
    Smpl Add apply AssociatedConstant_value_RETURNDATALOAD : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_EXTCALL : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 248 ]
          |))).
    
    Axiom AssociatedConstant_value_EXTCALL :
      M.IsAssociatedConstant Self "value_EXTCALL" value_EXTCALL.
    Smpl Add apply AssociatedConstant_value_EXTCALL : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_EXTDELEGATECALL : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 249 ]
          |))).
    
    Axiom AssociatedConstant_value_EXTDELEGATECALL :
      M.IsAssociatedConstant Self "value_EXTDELEGATECALL" value_EXTDELEGATECALL.
    Smpl Add apply AssociatedConstant_value_EXTDELEGATECALL : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_STATICCALL : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 250 ]
          |))).
    
    Axiom AssociatedConstant_value_STATICCALL :
      M.IsAssociatedConstant Self "value_STATICCALL" value_STATICCALL.
    Smpl Add apply AssociatedConstant_value_STATICCALL : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_EXTSTATICCALL : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 251 ]
          |))).
    
    Axiom AssociatedConstant_value_EXTSTATICCALL :
      M.IsAssociatedConstant Self "value_EXTSTATICCALL" value_EXTSTATICCALL.
    Smpl Add apply AssociatedConstant_value_EXTSTATICCALL : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_REVERT : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 253 ]
          |))).
    
    Axiom AssociatedConstant_value_REVERT : M.IsAssociatedConstant Self "value_REVERT" value_REVERT.
    Smpl Add apply AssociatedConstant_value_REVERT : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_INVALID : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 254 ]
          |))).
    
    Axiom AssociatedConstant_value_INVALID :
      M.IsAssociatedConstant Self "value_INVALID" value_INVALID.
    Smpl Add apply AssociatedConstant_value_INVALID : is_associated.
    
    (*             pub const $name: Self = Self($val); *)
    (* Ty.path "revm_bytecode::opcode::OpCode" *)
    Definition value_SELFDESTRUCT : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple "revm_bytecode::opcode::OpCode" [ Value.Integer IntegerKind.U8 255 ]
          |))).
    
    Axiom AssociatedConstant_value_SELFDESTRUCT :
      M.IsAssociatedConstant Self "value_SELFDESTRUCT" value_SELFDESTRUCT.
    Smpl Add apply AssociatedConstant_value_SELFDESTRUCT : is_associated.
  End Impl_revm_bytecode_opcode_OpCode.
  
  (* StructRecord
    {
      name := "OpCodeInfo";
      const_params := [];
      ty_params := [];
      fields :=
        [
          ("name_ptr", Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ Ty.path "u8" ]);
          ("name_len", Ty.path "u8");
          ("inputs", Ty.path "u8");
          ("outputs", Ty.path "u8");
          ("immediate_size", Ty.path "u8");
          ("not_eof", Ty.path "bool");
          ("terminating", Ty.path "bool")
        ];
    } *)
  
  Module Impl_core_clone_Clone_for_revm_bytecode_opcode_OpCodeInfo.
    Definition Self : Ty.t := Ty.path "revm_bytecode::opcode::OpCodeInfo".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Value.DeclaredButUndefined,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Value.DeclaredButUndefined,
                              [ fun γ => ltac:(M.monadic (M.deref (| M.read (| self |) |))) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_revm_bytecode_opcode_OpCodeInfo.
  
  Module Impl_core_marker_Copy_for_revm_bytecode_opcode_OpCodeInfo.
    Definition Self : Ty.t := Ty.path "revm_bytecode::opcode::OpCodeInfo".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_Copy_for_revm_bytecode_opcode_OpCodeInfo.
  
  Module Impl_core_marker_StructuralPartialEq_for_revm_bytecode_opcode_OpCodeInfo.
    Definition Self : Ty.t := Ty.path "revm_bytecode::opcode::OpCodeInfo".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_revm_bytecode_opcode_OpCodeInfo.
  
  Module Impl_core_cmp_PartialEq_for_revm_bytecode_opcode_OpCodeInfo.
    Definition Self : Ty.t := Ty.path "revm_bytecode::opcode::OpCodeInfo".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          LogicalOp.and (|
            LogicalOp.and (|
              LogicalOp.and (|
                LogicalOp.and (|
                  LogicalOp.and (|
                    LogicalOp.and (|
                      M.call_closure (|
                        Ty.path "bool",
                        M.get_trait_method (|
                          "core::cmp::PartialEq",
                          Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ Ty.path "u8" ],
                          [],
                          [ Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ Ty.path "u8" ] ],
                          "eq",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "revm_bytecode::opcode::OpCodeInfo",
                              "name_ptr"
                            |)
                          |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| other |) |),
                              "revm_bytecode::opcode::OpCodeInfo",
                              "name_ptr"
                            |)
                          |)
                        ]
                      |),
                      ltac:(M.monadic
                        (BinOp.eq (|
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "revm_bytecode::opcode::OpCodeInfo",
                              "name_len"
                            |)
                          |),
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| other |) |),
                              "revm_bytecode::opcode::OpCodeInfo",
                              "name_len"
                            |)
                          |)
                        |)))
                    |),
                    ltac:(M.monadic
                      (BinOp.eq (|
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "revm_bytecode::opcode::OpCodeInfo",
                            "inputs"
                          |)
                        |),
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| other |) |),
                            "revm_bytecode::opcode::OpCodeInfo",
                            "inputs"
                          |)
                        |)
                      |)))
                  |),
                  ltac:(M.monadic
                    (BinOp.eq (|
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "revm_bytecode::opcode::OpCodeInfo",
                          "outputs"
                        |)
                      |),
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| other |) |),
                          "revm_bytecode::opcode::OpCodeInfo",
                          "outputs"
                        |)
                      |)
                    |)))
                |),
                ltac:(M.monadic
                  (BinOp.eq (|
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "revm_bytecode::opcode::OpCodeInfo",
                        "immediate_size"
                      |)
                    |),
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| other |) |),
                        "revm_bytecode::opcode::OpCodeInfo",
                        "immediate_size"
                      |)
                    |)
                  |)))
              |),
              ltac:(M.monadic
                (BinOp.eq (|
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "revm_bytecode::opcode::OpCodeInfo",
                      "not_eof"
                    |)
                  |),
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| other |) |),
                      "revm_bytecode::opcode::OpCodeInfo",
                      "not_eof"
                    |)
                  |)
                |)))
            |),
            ltac:(M.monadic
              (BinOp.eq (|
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "revm_bytecode::opcode::OpCodeInfo",
                    "terminating"
                  |)
                |),
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| other |) |),
                    "revm_bytecode::opcode::OpCodeInfo",
                    "terminating"
                  |)
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_revm_bytecode_opcode_OpCodeInfo.
  
  Module Impl_core_cmp_Eq_for_revm_bytecode_opcode_OpCodeInfo.
    Definition Self : Ty.t := Ty.path "revm_bytecode::opcode::OpCodeInfo".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Value.DeclaredButUndefined,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Value.DeclaredButUndefined,
                              [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_revm_bytecode_opcode_OpCodeInfo.
  
  Module Impl_core_cmp_PartialOrd_for_revm_bytecode_opcode_OpCodeInfo.
    Definition Self : Ty.t := Ty.path "revm_bytecode::opcode::OpCodeInfo".
    
    (* PartialOrd *)
    Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
                  M.get_trait_method (|
                    "core::cmp::PartialOrd",
                    Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ Ty.path "u8" ],
                    [],
                    [ Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ Ty.path "u8" ] ],
                    "partial_cmp",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "revm_bytecode::opcode::OpCodeInfo",
                            "name_ptr"
                          |)
                        |)
                      |)
                    |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| other |) |),
                            "revm_bytecode::opcode::OpCodeInfo",
                            "name_ptr"
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let _ := M.is_struct_tuple (| γ0_0, "core::cmp::Ordering::Equal" |) in
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [ Ty.path "core::cmp::Ordering" ],
                          M.get_trait_method (|
                            "core::cmp::PartialOrd",
                            Ty.path "u8",
                            [],
                            [ Ty.path "u8" ],
                            "partial_cmp",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "revm_bytecode::opcode::OpCodeInfo",
                                    "name_len"
                                  |)
                                |)
                              |)
                            |);
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| other |) |),
                                    "revm_bytecode::opcode::OpCodeInfo",
                                    "name_len"
                                  |)
                                |)
                              |)
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let _ := M.is_struct_tuple (| γ0_0, "core::cmp::Ordering::Equal" |) in
                            M.match_operator (|
                              M.alloc (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::option::Option")
                                    []
                                    [ Ty.path "core::cmp::Ordering" ],
                                  M.get_trait_method (|
                                    "core::cmp::PartialOrd",
                                    Ty.path "u8",
                                    [],
                                    [ Ty.path "u8" ],
                                    "partial_cmp",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "revm_bytecode::opcode::OpCodeInfo",
                                            "inputs"
                                          |)
                                        |)
                                      |)
                                    |);
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| other |) |),
                                            "revm_bytecode::opcode::OpCodeInfo",
                                            "inputs"
                                          |)
                                        |)
                                      |)
                                    |)
                                  ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "core::option::Option::Some",
                                        0
                                      |) in
                                    let _ :=
                                      M.is_struct_tuple (| γ0_0, "core::cmp::Ordering::Equal" |) in
                                    M.match_operator (|
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [ Ty.path "core::cmp::Ordering" ],
                                          M.get_trait_method (|
                                            "core::cmp::PartialOrd",
                                            Ty.path "u8",
                                            [],
                                            [ Ty.path "u8" ],
                                            "partial_cmp",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (| M.read (| self |) |),
                                                    "revm_bytecode::opcode::OpCodeInfo",
                                                    "outputs"
                                                  |)
                                                |)
                                              |)
                                            |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (| M.read (| other |) |),
                                                    "revm_bytecode::opcode::OpCodeInfo",
                                                    "outputs"
                                                  |)
                                                |)
                                              |)
                                            |)
                                          ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::option::Option::Some",
                                                0
                                              |) in
                                            let _ :=
                                              M.is_struct_tuple (|
                                                γ0_0,
                                                "core::cmp::Ordering::Equal"
                                              |) in
                                            M.match_operator (|
                                              M.alloc (|
                                                M.call_closure (|
                                                  Ty.apply
                                                    (Ty.path "core::option::Option")
                                                    []
                                                    [ Ty.path "core::cmp::Ordering" ],
                                                  M.get_trait_method (|
                                                    "core::cmp::PartialOrd",
                                                    Ty.path "u8",
                                                    [],
                                                    [ Ty.path "u8" ],
                                                    "partial_cmp",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.SubPointer.get_struct_record_field (|
                                                            M.deref (| M.read (| self |) |),
                                                            "revm_bytecode::opcode::OpCodeInfo",
                                                            "immediate_size"
                                                          |)
                                                        |)
                                                      |)
                                                    |);
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.SubPointer.get_struct_record_field (|
                                                            M.deref (| M.read (| other |) |),
                                                            "revm_bytecode::opcode::OpCodeInfo",
                                                            "immediate_size"
                                                          |)
                                                        |)
                                                      |)
                                                    |)
                                                  ]
                                                |)
                                              |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ0_0 :=
                                                      M.SubPointer.get_struct_tuple_field (|
                                                        γ,
                                                        "core::option::Option::Some",
                                                        0
                                                      |) in
                                                    let _ :=
                                                      M.is_struct_tuple (|
                                                        γ0_0,
                                                        "core::cmp::Ordering::Equal"
                                                      |) in
                                                    M.match_operator (|
                                                      M.alloc (|
                                                        M.call_closure (|
                                                          Ty.apply
                                                            (Ty.path "core::option::Option")
                                                            []
                                                            [ Ty.path "core::cmp::Ordering" ],
                                                          M.get_trait_method (|
                                                            "core::cmp::PartialOrd",
                                                            Ty.path "bool",
                                                            [],
                                                            [ Ty.path "bool" ],
                                                            "partial_cmp",
                                                            [],
                                                            []
                                                          |),
                                                          [
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.deref (|
                                                                M.borrow (|
                                                                  Pointer.Kind.Ref,
                                                                  M.SubPointer.get_struct_record_field (|
                                                                    M.deref (| M.read (| self |) |),
                                                                    "revm_bytecode::opcode::OpCodeInfo",
                                                                    "not_eof"
                                                                  |)
                                                                |)
                                                              |)
                                                            |);
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.deref (|
                                                                M.borrow (|
                                                                  Pointer.Kind.Ref,
                                                                  M.SubPointer.get_struct_record_field (|
                                                                    M.deref (|
                                                                      M.read (| other |)
                                                                    |),
                                                                    "revm_bytecode::opcode::OpCodeInfo",
                                                                    "not_eof"
                                                                  |)
                                                                |)
                                                              |)
                                                            |)
                                                          ]
                                                        |)
                                                      |),
                                                      [
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (let γ0_0 :=
                                                              M.SubPointer.get_struct_tuple_field (|
                                                                γ,
                                                                "core::option::Option::Some",
                                                                0
                                                              |) in
                                                            let _ :=
                                                              M.is_struct_tuple (|
                                                                γ0_0,
                                                                "core::cmp::Ordering::Equal"
                                                              |) in
                                                            M.alloc (|
                                                              M.call_closure (|
                                                                Ty.apply
                                                                  (Ty.path "core::option::Option")
                                                                  []
                                                                  [ Ty.path "core::cmp::Ordering" ],
                                                                M.get_trait_method (|
                                                                  "core::cmp::PartialOrd",
                                                                  Ty.path "bool",
                                                                  [],
                                                                  [ Ty.path "bool" ],
                                                                  "partial_cmp",
                                                                  [],
                                                                  []
                                                                |),
                                                                [
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    M.deref (|
                                                                      M.borrow (|
                                                                        Pointer.Kind.Ref,
                                                                        M.SubPointer.get_struct_record_field (|
                                                                          M.deref (|
                                                                            M.read (| self |)
                                                                          |),
                                                                          "revm_bytecode::opcode::OpCodeInfo",
                                                                          "terminating"
                                                                        |)
                                                                      |)
                                                                    |)
                                                                  |);
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    M.deref (|
                                                                      M.borrow (|
                                                                        Pointer.Kind.Ref,
                                                                        M.SubPointer.get_struct_record_field (|
                                                                          M.deref (|
                                                                            M.read (| other |)
                                                                          |),
                                                                          "revm_bytecode::opcode::OpCodeInfo",
                                                                          "terminating"
                                                                        |)
                                                                      |)
                                                                    |)
                                                                  |)
                                                                ]
                                                              |)
                                                            |)));
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (let cmp := M.copy (| γ |) in
                                                            cmp))
                                                      ]
                                                    |)));
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let cmp := M.copy (| γ |) in
                                                    cmp))
                                              ]
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let cmp := M.copy (| γ |) in
                                            cmp))
                                      ]
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let cmp := M.copy (| γ |) in
                                    cmp))
                              ]
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let cmp := M.copy (| γ |) in
                            cmp))
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let cmp := M.copy (| γ |) in
                    cmp))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_for_revm_bytecode_opcode_OpCodeInfo.
  
  Module Impl_core_cmp_Ord_for_revm_bytecode_opcode_OpCodeInfo.
    Definition Self : Ty.t := Ty.path "revm_bytecode::opcode::OpCodeInfo".
    
    (* Ord *)
    Definition cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  Ty.path "core::cmp::Ordering",
                  M.get_trait_method (|
                    "core::cmp::Ord",
                    Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ Ty.path "u8" ],
                    [],
                    [],
                    "cmp",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "revm_bytecode::opcode::OpCodeInfo",
                            "name_ptr"
                          |)
                        |)
                      |)
                    |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| other |) |),
                            "revm_bytecode::opcode::OpCodeInfo",
                            "name_ptr"
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::cmp::Ordering::Equal" |) in
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          Ty.path "core::cmp::Ordering",
                          M.get_trait_method (|
                            "core::cmp::Ord",
                            Ty.path "u8",
                            [],
                            [],
                            "cmp",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "revm_bytecode::opcode::OpCodeInfo",
                                    "name_len"
                                  |)
                                |)
                              |)
                            |);
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| other |) |),
                                    "revm_bytecode::opcode::OpCodeInfo",
                                    "name_len"
                                  |)
                                |)
                              |)
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let _ := M.is_struct_tuple (| γ, "core::cmp::Ordering::Equal" |) in
                            M.match_operator (|
                              M.alloc (|
                                M.call_closure (|
                                  Ty.path "core::cmp::Ordering",
                                  M.get_trait_method (|
                                    "core::cmp::Ord",
                                    Ty.path "u8",
                                    [],
                                    [],
                                    "cmp",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "revm_bytecode::opcode::OpCodeInfo",
                                            "inputs"
                                          |)
                                        |)
                                      |)
                                    |);
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| other |) |),
                                            "revm_bytecode::opcode::OpCodeInfo",
                                            "inputs"
                                          |)
                                        |)
                                      |)
                                    |)
                                  ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let _ :=
                                      M.is_struct_tuple (| γ, "core::cmp::Ordering::Equal" |) in
                                    M.match_operator (|
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.path "core::cmp::Ordering",
                                          M.get_trait_method (|
                                            "core::cmp::Ord",
                                            Ty.path "u8",
                                            [],
                                            [],
                                            "cmp",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (| M.read (| self |) |),
                                                    "revm_bytecode::opcode::OpCodeInfo",
                                                    "outputs"
                                                  |)
                                                |)
                                              |)
                                            |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (| M.read (| other |) |),
                                                    "revm_bytecode::opcode::OpCodeInfo",
                                                    "outputs"
                                                  |)
                                                |)
                                              |)
                                            |)
                                          ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let _ :=
                                              M.is_struct_tuple (|
                                                γ,
                                                "core::cmp::Ordering::Equal"
                                              |) in
                                            M.match_operator (|
                                              M.alloc (|
                                                M.call_closure (|
                                                  Ty.path "core::cmp::Ordering",
                                                  M.get_trait_method (|
                                                    "core::cmp::Ord",
                                                    Ty.path "u8",
                                                    [],
                                                    [],
                                                    "cmp",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.SubPointer.get_struct_record_field (|
                                                            M.deref (| M.read (| self |) |),
                                                            "revm_bytecode::opcode::OpCodeInfo",
                                                            "immediate_size"
                                                          |)
                                                        |)
                                                      |)
                                                    |);
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.SubPointer.get_struct_record_field (|
                                                            M.deref (| M.read (| other |) |),
                                                            "revm_bytecode::opcode::OpCodeInfo",
                                                            "immediate_size"
                                                          |)
                                                        |)
                                                      |)
                                                    |)
                                                  ]
                                                |)
                                              |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let _ :=
                                                      M.is_struct_tuple (|
                                                        γ,
                                                        "core::cmp::Ordering::Equal"
                                                      |) in
                                                    M.match_operator (|
                                                      M.alloc (|
                                                        M.call_closure (|
                                                          Ty.path "core::cmp::Ordering",
                                                          M.get_trait_method (|
                                                            "core::cmp::Ord",
                                                            Ty.path "bool",
                                                            [],
                                                            [],
                                                            "cmp",
                                                            [],
                                                            []
                                                          |),
                                                          [
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.deref (|
                                                                M.borrow (|
                                                                  Pointer.Kind.Ref,
                                                                  M.SubPointer.get_struct_record_field (|
                                                                    M.deref (| M.read (| self |) |),
                                                                    "revm_bytecode::opcode::OpCodeInfo",
                                                                    "not_eof"
                                                                  |)
                                                                |)
                                                              |)
                                                            |);
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.deref (|
                                                                M.borrow (|
                                                                  Pointer.Kind.Ref,
                                                                  M.SubPointer.get_struct_record_field (|
                                                                    M.deref (|
                                                                      M.read (| other |)
                                                                    |),
                                                                    "revm_bytecode::opcode::OpCodeInfo",
                                                                    "not_eof"
                                                                  |)
                                                                |)
                                                              |)
                                                            |)
                                                          ]
                                                        |)
                                                      |),
                                                      [
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (let _ :=
                                                              M.is_struct_tuple (|
                                                                γ,
                                                                "core::cmp::Ordering::Equal"
                                                              |) in
                                                            M.alloc (|
                                                              M.call_closure (|
                                                                Ty.path "core::cmp::Ordering",
                                                                M.get_trait_method (|
                                                                  "core::cmp::Ord",
                                                                  Ty.path "bool",
                                                                  [],
                                                                  [],
                                                                  "cmp",
                                                                  [],
                                                                  []
                                                                |),
                                                                [
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    M.deref (|
                                                                      M.borrow (|
                                                                        Pointer.Kind.Ref,
                                                                        M.SubPointer.get_struct_record_field (|
                                                                          M.deref (|
                                                                            M.read (| self |)
                                                                          |),
                                                                          "revm_bytecode::opcode::OpCodeInfo",
                                                                          "terminating"
                                                                        |)
                                                                      |)
                                                                    |)
                                                                  |);
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    M.deref (|
                                                                      M.borrow (|
                                                                        Pointer.Kind.Ref,
                                                                        M.SubPointer.get_struct_record_field (|
                                                                          M.deref (|
                                                                            M.read (| other |)
                                                                          |),
                                                                          "revm_bytecode::opcode::OpCodeInfo",
                                                                          "terminating"
                                                                        |)
                                                                      |)
                                                                    |)
                                                                  |)
                                                                ]
                                                              |)
                                                            |)));
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (let cmp := M.copy (| γ |) in
                                                            cmp))
                                                      ]
                                                    |)));
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let cmp := M.copy (| γ |) in
                                                    cmp))
                                              ]
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let cmp := M.copy (| γ |) in
                                            cmp))
                                      ]
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let cmp := M.copy (| γ |) in
                                    cmp))
                              ]
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let cmp := M.copy (| γ |) in
                            cmp))
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let cmp := M.copy (| γ |) in
                    cmp))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Ord"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
  End Impl_core_cmp_Ord_for_revm_bytecode_opcode_OpCodeInfo.
  
  Module Impl_core_hash_Hash_for_revm_bytecode_opcode_OpCodeInfo.
    Definition Self : Ty.t := Ty.path "revm_bytecode::opcode::OpCodeInfo".
    
    (* Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::hash::Hash",
                    Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ Ty.path "u8" ],
                    [],
                    [],
                    "hash",
                    [],
                    [ __H ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "revm_bytecode::opcode::OpCodeInfo",
                            "name_ptr"
                          |)
                        |)
                      |)
                    |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                  ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::hash::Hash",
                    Ty.path "u8",
                    [],
                    [],
                    "hash",
                    [],
                    [ __H ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "revm_bytecode::opcode::OpCodeInfo",
                            "name_len"
                          |)
                        |)
                      |)
                    |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                  ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::hash::Hash",
                    Ty.path "u8",
                    [],
                    [],
                    "hash",
                    [],
                    [ __H ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "revm_bytecode::opcode::OpCodeInfo",
                            "inputs"
                          |)
                        |)
                      |)
                    |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                  ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::hash::Hash",
                    Ty.path "u8",
                    [],
                    [],
                    "hash",
                    [],
                    [ __H ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "revm_bytecode::opcode::OpCodeInfo",
                            "outputs"
                          |)
                        |)
                      |)
                    |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                  ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::hash::Hash",
                    Ty.path "u8",
                    [],
                    [],
                    "hash",
                    [],
                    [ __H ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "revm_bytecode::opcode::OpCodeInfo",
                            "immediate_size"
                          |)
                        |)
                      |)
                    |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                  ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::hash::Hash",
                    Ty.path "bool",
                    [],
                    [],
                    "hash",
                    [],
                    [ __H ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "revm_bytecode::opcode::OpCodeInfo",
                            "not_eof"
                          |)
                        |)
                      |)
                    |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "core::hash::Hash",
                  Ty.path "bool",
                  [],
                  [],
                  "hash",
                  [],
                  [ __H ]
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "revm_bytecode::opcode::OpCodeInfo",
                          "terminating"
                        |)
                      |)
                    |)
                  |);
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_revm_bytecode_opcode_OpCodeInfo.
  
  Module Impl_core_fmt_Debug_for_revm_bytecode_opcode_OpCodeInfo.
    Definition Self : Ty.t := Ty.path "revm_bytecode::opcode::OpCodeInfo".
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_struct("OpCodeInfo")
                .field("name", &self.name())
                .field("inputs", &self.inputs())
                .field("outputs", &self.outputs())
                .field("not_eof", &self.is_disabled_in_eof())
                .field("terminating", &self.is_terminating())
                .field("immediate_size", &self.immediate_size())
                .finish()
        }
    *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::builders::DebugStruct",
              "finish",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::builders::DebugStruct" ],
                    M.get_associated_function (|
                      Ty.path "core::fmt::builders::DebugStruct",
                      "field",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [ Ty.path "core::fmt::builders::DebugStruct" ],
                            M.get_associated_function (|
                              Ty.path "core::fmt::builders::DebugStruct",
                              "field",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.MutRef,
                                M.deref (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&mut")
                                      []
                                      [ Ty.path "core::fmt::builders::DebugStruct" ],
                                    M.get_associated_function (|
                                      Ty.path "core::fmt::builders::DebugStruct",
                                      "field",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.deref (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "&mut")
                                              []
                                              [ Ty.path "core::fmt::builders::DebugStruct" ],
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::builders::DebugStruct",
                                              "field",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.MutRef,
                                                M.deref (|
                                                  M.call_closure (|
                                                    Ty.apply
                                                      (Ty.path "&mut")
                                                      []
                                                      [ Ty.path "core::fmt::builders::DebugStruct"
                                                      ],
                                                    M.get_associated_function (|
                                                      Ty.path "core::fmt::builders::DebugStruct",
                                                      "field",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.MutRef,
                                                        M.deref (|
                                                          M.call_closure (|
                                                            Ty.apply
                                                              (Ty.path "&mut")
                                                              []
                                                              [
                                                                Ty.path
                                                                  "core::fmt::builders::DebugStruct"
                                                              ],
                                                            M.get_associated_function (|
                                                              Ty.path
                                                                "core::fmt::builders::DebugStruct",
                                                              "field",
                                                              [],
                                                              []
                                                            |),
                                                            [
                                                              M.borrow (|
                                                                Pointer.Kind.MutRef,
                                                                M.alloc (|
                                                                  M.call_closure (|
                                                                    Ty.path
                                                                      "core::fmt::builders::DebugStruct",
                                                                    M.get_associated_function (|
                                                                      Ty.path
                                                                        "core::fmt::Formatter",
                                                                      "debug_struct",
                                                                      [],
                                                                      []
                                                                    |),
                                                                    [
                                                                      M.borrow (|
                                                                        Pointer.Kind.MutRef,
                                                                        M.deref (| M.read (| f |) |)
                                                                      |);
                                                                      M.borrow (|
                                                                        Pointer.Kind.Ref,
                                                                        M.deref (|
                                                                          M.read (|
                                                                            Value.String
                                                                              "OpCodeInfo"
                                                                          |)
                                                                        |)
                                                                      |)
                                                                    ]
                                                                  |)
                                                                |)
                                                              |);
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (|
                                                                  M.read (| Value.String "name" |)
                                                                |)
                                                              |);
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (|
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    M.alloc (|
                                                                      M.call_closure (|
                                                                        Ty.apply
                                                                          (Ty.path "&")
                                                                          []
                                                                          [ Ty.path "str" ],
                                                                        M.get_associated_function (|
                                                                          Ty.path
                                                                            "revm_bytecode::opcode::OpCodeInfo",
                                                                          "name",
                                                                          [],
                                                                          []
                                                                        |),
                                                                        [
                                                                          M.borrow (|
                                                                            Pointer.Kind.Ref,
                                                                            M.deref (|
                                                                              M.read (| self |)
                                                                            |)
                                                                          |)
                                                                        ]
                                                                      |)
                                                                    |)
                                                                  |)
                                                                |)
                                                              |)
                                                            ]
                                                          |)
                                                        |)
                                                      |);
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (|
                                                          M.read (| Value.String "inputs" |)
                                                        |)
                                                      |);
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (|
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.alloc (|
                                                              M.call_closure (|
                                                                Ty.path "u8",
                                                                M.get_associated_function (|
                                                                  Ty.path
                                                                    "revm_bytecode::opcode::OpCodeInfo",
                                                                  "inputs",
                                                                  [],
                                                                  []
                                                                |),
                                                                [
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    M.deref (| M.read (| self |) |)
                                                                  |)
                                                                ]
                                                              |)
                                                            |)
                                                          |)
                                                        |)
                                                      |)
                                                    ]
                                                  |)
                                                |)
                                              |);
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| Value.String "outputs" |) |)
                                              |);
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (|
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.alloc (|
                                                      M.call_closure (|
                                                        Ty.path "u8",
                                                        M.get_associated_function (|
                                                          Ty.path
                                                            "revm_bytecode::opcode::OpCodeInfo",
                                                          "outputs",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (| M.read (| self |) |)
                                                          |)
                                                        ]
                                                      |)
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            ]
                                          |)
                                        |)
                                      |);
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| Value.String "not_eof" |) |)
                                      |);
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.alloc (|
                                              M.call_closure (|
                                                Ty.path "bool",
                                                M.get_associated_function (|
                                                  Ty.path "revm_bytecode::opcode::OpCodeInfo",
                                                  "is_disabled_in_eof",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (| M.read (| self |) |)
                                                  |)
                                                ]
                                              |)
                                            |)
                                          |)
                                        |)
                                      |)
                                    ]
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (| M.read (| Value.String "terminating" |) |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.path "bool",
                                        M.get_associated_function (|
                                          Ty.path "revm_bytecode::opcode::OpCodeInfo",
                                          "is_terminating",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| self |) |)
                                          |)
                                        ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        |)
                      |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (| M.read (| Value.String "immediate_size" |) |)
                      |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "u8",
                                M.get_associated_function (|
                                  Ty.path "revm_bytecode::opcode::OpCodeInfo",
                                  "immediate_size",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                              |)
                            |)
                          |)
                        |)
                      |)
                    ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_revm_bytecode_opcode_OpCodeInfo.
  
  Module Impl_revm_bytecode_opcode_OpCodeInfo.
    Definition Self : Ty.t := Ty.path "revm_bytecode::opcode::OpCodeInfo".
    
    (*
        pub const fn new(name: &'static str) -> Self {
            assert!(name.len() < 256, "opcode name is too long");
            Self {
                name_ptr: unsafe { NonNull::new_unchecked(name.as_ptr().cast_mut()) },
                name_len: name.len() as u8,
                inputs: 0,
                outputs: 0,
                not_eof: false,
                terminating: false,
                immediate_size: 0,
            }
        }
    *)
    Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ name ] =>
        ltac:(M.monadic
          (let name := M.alloc (| name |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            UnOp.not (|
                              BinOp.lt (|
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_associated_function (| Ty.path "str", "len", [], [] |),
                                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| name |) |) |)
                                  ]
                                |),
                                Value.Integer IntegerKind.Usize 256
                              |)
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            Ty.path "never",
                            M.get_function (| "core::panicking::panic_fmt", [], [] |),
                            [
                              M.call_closure (|
                                Ty.path "core::fmt::Arguments",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Arguments",
                                  "new_const",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.alloc (|
                                          Value.Array
                                            [ M.read (| Value.String "opcode name is too long" |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.alloc (|
              Value.StructRecord
                "revm_bytecode::opcode::OpCodeInfo"
                [
                  ("name_ptr",
                    M.call_closure (|
                      Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ Ty.path "u8" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ Ty.path "u8" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ],
                            "cast_mut",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ],
                              M.get_associated_function (| Ty.path "str", "as_ptr", [], [] |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| name |) |) |) ]
                            |)
                          ]
                        |)
                      ]
                    |));
                  ("name_len",
                    M.cast
                      (Ty.path "u8")
                      (M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (| Ty.path "str", "len", [], [] |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| name |) |) |) ]
                      |)));
                  ("inputs", Value.Integer IntegerKind.U8 0);
                  ("outputs", Value.Integer IntegerKind.U8 0);
                  ("not_eof", Value.Bool false);
                  ("terminating", Value.Bool false);
                  ("immediate_size", Value.Integer IntegerKind.U8 0)
                ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
    Smpl Add apply AssociatedFunction_new : is_associated.
    
    (*
        pub const fn name(&self) -> &'static str {
            // SAFETY: `self.name_*` can only be initialized with a valid `&'static str`.
            unsafe {
                // TODO : Use `str::from_raw_parts` when it's stable.
                let slice = core::slice::from_raw_parts(self.name_ptr.as_ptr(), self.name_len as usize);
                core::str::from_utf8_unchecked(slice)
            }
        }
    *)
    Definition name (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ slice :
                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                  M.get_function (| "core::slice::raw::from_raw_parts", [], [ Ty.path "u8" ] |),
                  [
                    (* MutToConstPointer *)
                    M.pointer_coercion
                      (M.call_closure (|
                        Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ Ty.path "u8" ],
                          "as_ptr",
                          [],
                          []
                        |),
                        [
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "revm_bytecode::opcode::OpCodeInfo",
                              "name_ptr"
                            |)
                          |)
                        ]
                      |));
                    M.cast
                      (Ty.path "usize")
                      (M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "revm_bytecode::opcode::OpCodeInfo",
                          "name_len"
                        |)
                      |))
                  ]
                |)
              |) in
            M.alloc (|
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.path "str" ],
                    M.get_function (| "core::str::converts::from_utf8_unchecked", [], [] |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |) ]
                  |)
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_name : M.IsAssociatedFunction Self "name" name.
    Smpl Add apply AssociatedFunction_name : is_associated.
    
    (*
        pub const fn io_diff(&self) -> i16 {
            self.outputs as i16 - self.inputs as i16
        }
    *)
    Definition io_diff (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          BinOp.Wrap.sub (|
            M.cast
              (Ty.path "i16")
              (M.read (|
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "revm_bytecode::opcode::OpCodeInfo",
                  "outputs"
                |)
              |)),
            M.cast
              (Ty.path "i16")
              (M.read (|
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "revm_bytecode::opcode::OpCodeInfo",
                  "inputs"
                |)
              |))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_io_diff : M.IsAssociatedFunction Self "io_diff" io_diff.
    Smpl Add apply AssociatedFunction_io_diff : is_associated.
    
    (*
        pub const fn inputs(&self) -> u8 {
            self.inputs
        }
    *)
    Definition inputs (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.SubPointer.get_struct_record_field (|
              M.deref (| M.read (| self |) |),
              "revm_bytecode::opcode::OpCodeInfo",
              "inputs"
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_inputs : M.IsAssociatedFunction Self "inputs" inputs.
    Smpl Add apply AssociatedFunction_inputs : is_associated.
    
    (*
        pub const fn outputs(&self) -> u8 {
            self.outputs
        }
    *)
    Definition outputs (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.SubPointer.get_struct_record_field (|
              M.deref (| M.read (| self |) |),
              "revm_bytecode::opcode::OpCodeInfo",
              "outputs"
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_outputs : M.IsAssociatedFunction Self "outputs" outputs.
    Smpl Add apply AssociatedFunction_outputs : is_associated.
    
    (*
        pub const fn is_disabled_in_eof(&self) -> bool {
            self.not_eof
        }
    *)
    Definition is_disabled_in_eof (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.SubPointer.get_struct_record_field (|
              M.deref (| M.read (| self |) |),
              "revm_bytecode::opcode::OpCodeInfo",
              "not_eof"
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_is_disabled_in_eof :
      M.IsAssociatedFunction Self "is_disabled_in_eof" is_disabled_in_eof.
    Smpl Add apply AssociatedFunction_is_disabled_in_eof : is_associated.
    
    (*
        pub const fn is_terminating(&self) -> bool {
            self.terminating
        }
    *)
    Definition is_terminating (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.SubPointer.get_struct_record_field (|
              M.deref (| M.read (| self |) |),
              "revm_bytecode::opcode::OpCodeInfo",
              "terminating"
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_is_terminating :
      M.IsAssociatedFunction Self "is_terminating" is_terminating.
    Smpl Add apply AssociatedFunction_is_terminating : is_associated.
    
    (*
        pub const fn immediate_size(&self) -> u8 {
            self.immediate_size
        }
    *)
    Definition immediate_size (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.SubPointer.get_struct_record_field (|
              M.deref (| M.read (| self |) |),
              "revm_bytecode::opcode::OpCodeInfo",
              "immediate_size"
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_immediate_size :
      M.IsAssociatedFunction Self "immediate_size" immediate_size.
    Smpl Add apply AssociatedFunction_immediate_size : is_associated.
  End Impl_revm_bytecode_opcode_OpCodeInfo.
  
  (*
  pub const fn not_eof(mut op: OpCodeInfo) -> OpCodeInfo {
      op.not_eof = true;
      op
  }
  *)
  Definition not_eof (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ op ] =>
      ltac:(M.monadic
        (let op := M.alloc (| op |) in
        M.read (|
          let~ _ : Ty.tuple [] :=
            M.alloc (|
              M.write (|
                M.SubPointer.get_struct_record_field (|
                  op,
                  "revm_bytecode::opcode::OpCodeInfo",
                  "not_eof"
                |),
                Value.Bool true
              |)
            |) in
          op
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Function_not_eof : M.IsFunction "revm_bytecode::opcode::not_eof" not_eof.
  Smpl Add apply Function_not_eof : is_function.
  
  (*
  pub const fn immediate_size(mut op: OpCodeInfo, n: u8) -> OpCodeInfo {
      op.immediate_size = n;
      op
  }
  *)
  Definition immediate_size (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ op; n ] =>
      ltac:(M.monadic
        (let op := M.alloc (| op |) in
        let n := M.alloc (| n |) in
        M.read (|
          let~ _ : Ty.tuple [] :=
            M.alloc (|
              M.write (|
                M.SubPointer.get_struct_record_field (|
                  op,
                  "revm_bytecode::opcode::OpCodeInfo",
                  "immediate_size"
                |),
                M.read (| n |)
              |)
            |) in
          op
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Function_immediate_size :
    M.IsFunction "revm_bytecode::opcode::immediate_size" immediate_size.
  Smpl Add apply Function_immediate_size : is_function.
  
  (*
  pub const fn terminating(mut op: OpCodeInfo) -> OpCodeInfo {
      op.terminating = true;
      op
  }
  *)
  Definition terminating (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ op ] =>
      ltac:(M.monadic
        (let op := M.alloc (| op |) in
        M.read (|
          let~ _ : Ty.tuple [] :=
            M.alloc (|
              M.write (|
                M.SubPointer.get_struct_record_field (|
                  op,
                  "revm_bytecode::opcode::OpCodeInfo",
                  "terminating"
                |),
                Value.Bool true
              |)
            |) in
          op
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Function_terminating : M.IsFunction "revm_bytecode::opcode::terminating" terminating.
  Smpl Add apply Function_terminating : is_function.
  
  (*
  pub const fn stack_io(mut op: OpCodeInfo, inputs: u8, outputs: u8) -> OpCodeInfo {
      op.inputs = inputs;
      op.outputs = outputs;
      op
  }
  *)
  Definition stack_io (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ op; inputs; outputs ] =>
      ltac:(M.monadic
        (let op := M.alloc (| op |) in
        let inputs := M.alloc (| inputs |) in
        let outputs := M.alloc (| outputs |) in
        M.read (|
          let~ _ : Ty.tuple [] :=
            M.alloc (|
              M.write (|
                M.SubPointer.get_struct_record_field (|
                  op,
                  "revm_bytecode::opcode::OpCodeInfo",
                  "inputs"
                |),
                M.read (| inputs |)
              |)
            |) in
          let~ _ : Ty.tuple [] :=
            M.alloc (|
              M.write (|
                M.SubPointer.get_struct_record_field (|
                  op,
                  "revm_bytecode::opcode::OpCodeInfo",
                  "outputs"
                |),
                M.read (| outputs |)
              |)
            |) in
          op
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Function_stack_io : M.IsFunction "revm_bytecode::opcode::stack_io" stack_io.
  Smpl Add apply Function_stack_io : is_function.
  
  Definition value_NOP : Value.t :=
    M.run_constant ltac:(M.monadic (M.get_constant "revm_bytecode::opcode::JUMPDEST")).
  
  Axiom Constant_value_NOP : (M.get_constant "revm_bytecode::opcode::NOP") = value_NOP.
  Global Hint Rewrite Constant_value_NOP : constant_rewrites.
  
  Definition value_STOP : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 0 |))).
  
  Axiom Constant_value_STOP : (M.get_constant "revm_bytecode::opcode::STOP") = value_STOP.
  Global Hint Rewrite Constant_value_STOP : constant_rewrites.
  
  Definition value_ADD : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 1 |))).
  
  Axiom Constant_value_ADD : (M.get_constant "revm_bytecode::opcode::ADD") = value_ADD.
  Global Hint Rewrite Constant_value_ADD : constant_rewrites.
  
  Definition value_MUL : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 2 |))).
  
  Axiom Constant_value_MUL : (M.get_constant "revm_bytecode::opcode::MUL") = value_MUL.
  Global Hint Rewrite Constant_value_MUL : constant_rewrites.
  
  Definition value_SUB : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 3 |))).
  
  Axiom Constant_value_SUB : (M.get_constant "revm_bytecode::opcode::SUB") = value_SUB.
  Global Hint Rewrite Constant_value_SUB : constant_rewrites.
  
  Definition value_DIV : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 4 |))).
  
  Axiom Constant_value_DIV : (M.get_constant "revm_bytecode::opcode::DIV") = value_DIV.
  Global Hint Rewrite Constant_value_DIV : constant_rewrites.
  
  Definition value_SDIV : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 5 |))).
  
  Axiom Constant_value_SDIV : (M.get_constant "revm_bytecode::opcode::SDIV") = value_SDIV.
  Global Hint Rewrite Constant_value_SDIV : constant_rewrites.
  
  Definition value_MOD : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 6 |))).
  
  Axiom Constant_value_MOD : (M.get_constant "revm_bytecode::opcode::MOD") = value_MOD.
  Global Hint Rewrite Constant_value_MOD : constant_rewrites.
  
  Definition value_SMOD : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 7 |))).
  
  Axiom Constant_value_SMOD : (M.get_constant "revm_bytecode::opcode::SMOD") = value_SMOD.
  Global Hint Rewrite Constant_value_SMOD : constant_rewrites.
  
  Definition value_ADDMOD : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 8 |))).
  
  Axiom Constant_value_ADDMOD : (M.get_constant "revm_bytecode::opcode::ADDMOD") = value_ADDMOD.
  Global Hint Rewrite Constant_value_ADDMOD : constant_rewrites.
  
  Definition value_MULMOD : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 9 |))).
  
  Axiom Constant_value_MULMOD : (M.get_constant "revm_bytecode::opcode::MULMOD") = value_MULMOD.
  Global Hint Rewrite Constant_value_MULMOD : constant_rewrites.
  
  Definition value_EXP : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 10 |))).
  
  Axiom Constant_value_EXP : (M.get_constant "revm_bytecode::opcode::EXP") = value_EXP.
  Global Hint Rewrite Constant_value_EXP : constant_rewrites.
  
  Definition value_SIGNEXTEND : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 11 |))).
  
  Axiom Constant_value_SIGNEXTEND :
    (M.get_constant "revm_bytecode::opcode::SIGNEXTEND") = value_SIGNEXTEND.
  Global Hint Rewrite Constant_value_SIGNEXTEND : constant_rewrites.
  
  Definition value_LT : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 16 |))).
  
  Axiom Constant_value_LT : (M.get_constant "revm_bytecode::opcode::LT") = value_LT.
  Global Hint Rewrite Constant_value_LT : constant_rewrites.
  
  Definition value_GT : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 17 |))).
  
  Axiom Constant_value_GT : (M.get_constant "revm_bytecode::opcode::GT") = value_GT.
  Global Hint Rewrite Constant_value_GT : constant_rewrites.
  
  Definition value_SLT : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 18 |))).
  
  Axiom Constant_value_SLT : (M.get_constant "revm_bytecode::opcode::SLT") = value_SLT.
  Global Hint Rewrite Constant_value_SLT : constant_rewrites.
  
  Definition value_SGT : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 19 |))).
  
  Axiom Constant_value_SGT : (M.get_constant "revm_bytecode::opcode::SGT") = value_SGT.
  Global Hint Rewrite Constant_value_SGT : constant_rewrites.
  
  Definition value_EQ : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 20 |))).
  
  Axiom Constant_value_EQ : (M.get_constant "revm_bytecode::opcode::EQ") = value_EQ.
  Global Hint Rewrite Constant_value_EQ : constant_rewrites.
  
  Definition value_ISZERO : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 21 |))).
  
  Axiom Constant_value_ISZERO : (M.get_constant "revm_bytecode::opcode::ISZERO") = value_ISZERO.
  Global Hint Rewrite Constant_value_ISZERO : constant_rewrites.
  
  Definition value_AND : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 22 |))).
  
  Axiom Constant_value_AND : (M.get_constant "revm_bytecode::opcode::AND") = value_AND.
  Global Hint Rewrite Constant_value_AND : constant_rewrites.
  
  Definition value_OR : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 23 |))).
  
  Axiom Constant_value_OR : (M.get_constant "revm_bytecode::opcode::OR") = value_OR.
  Global Hint Rewrite Constant_value_OR : constant_rewrites.
  
  Definition value_XOR : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 24 |))).
  
  Axiom Constant_value_XOR : (M.get_constant "revm_bytecode::opcode::XOR") = value_XOR.
  Global Hint Rewrite Constant_value_XOR : constant_rewrites.
  
  Definition value_NOT : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 25 |))).
  
  Axiom Constant_value_NOT : (M.get_constant "revm_bytecode::opcode::NOT") = value_NOT.
  Global Hint Rewrite Constant_value_NOT : constant_rewrites.
  
  Definition value_BYTE : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 26 |))).
  
  Axiom Constant_value_BYTE : (M.get_constant "revm_bytecode::opcode::BYTE") = value_BYTE.
  Global Hint Rewrite Constant_value_BYTE : constant_rewrites.
  
  Definition value_SHL : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 27 |))).
  
  Axiom Constant_value_SHL : (M.get_constant "revm_bytecode::opcode::SHL") = value_SHL.
  Global Hint Rewrite Constant_value_SHL : constant_rewrites.
  
  Definition value_SHR : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 28 |))).
  
  Axiom Constant_value_SHR : (M.get_constant "revm_bytecode::opcode::SHR") = value_SHR.
  Global Hint Rewrite Constant_value_SHR : constant_rewrites.
  
  Definition value_SAR : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 29 |))).
  
  Axiom Constant_value_SAR : (M.get_constant "revm_bytecode::opcode::SAR") = value_SAR.
  Global Hint Rewrite Constant_value_SAR : constant_rewrites.
  
  Definition value_KECCAK256 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 32 |))).
  
  Axiom Constant_value_KECCAK256 :
    (M.get_constant "revm_bytecode::opcode::KECCAK256") = value_KECCAK256.
  Global Hint Rewrite Constant_value_KECCAK256 : constant_rewrites.
  
  Definition value_ADDRESS : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 48 |))).
  
  Axiom Constant_value_ADDRESS : (M.get_constant "revm_bytecode::opcode::ADDRESS") = value_ADDRESS.
  Global Hint Rewrite Constant_value_ADDRESS : constant_rewrites.
  
  Definition value_BALANCE : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 49 |))).
  
  Axiom Constant_value_BALANCE : (M.get_constant "revm_bytecode::opcode::BALANCE") = value_BALANCE.
  Global Hint Rewrite Constant_value_BALANCE : constant_rewrites.
  
  Definition value_ORIGIN : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 50 |))).
  
  Axiom Constant_value_ORIGIN : (M.get_constant "revm_bytecode::opcode::ORIGIN") = value_ORIGIN.
  Global Hint Rewrite Constant_value_ORIGIN : constant_rewrites.
  
  Definition value_CALLER : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 51 |))).
  
  Axiom Constant_value_CALLER : (M.get_constant "revm_bytecode::opcode::CALLER") = value_CALLER.
  Global Hint Rewrite Constant_value_CALLER : constant_rewrites.
  
  Definition value_CALLVALUE : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 52 |))).
  
  Axiom Constant_value_CALLVALUE :
    (M.get_constant "revm_bytecode::opcode::CALLVALUE") = value_CALLVALUE.
  Global Hint Rewrite Constant_value_CALLVALUE : constant_rewrites.
  
  Definition value_CALLDATALOAD : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 53 |))).
  
  Axiom Constant_value_CALLDATALOAD :
    (M.get_constant "revm_bytecode::opcode::CALLDATALOAD") = value_CALLDATALOAD.
  Global Hint Rewrite Constant_value_CALLDATALOAD : constant_rewrites.
  
  Definition value_CALLDATASIZE : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 54 |))).
  
  Axiom Constant_value_CALLDATASIZE :
    (M.get_constant "revm_bytecode::opcode::CALLDATASIZE") = value_CALLDATASIZE.
  Global Hint Rewrite Constant_value_CALLDATASIZE : constant_rewrites.
  
  Definition value_CALLDATACOPY : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 55 |))).
  
  Axiom Constant_value_CALLDATACOPY :
    (M.get_constant "revm_bytecode::opcode::CALLDATACOPY") = value_CALLDATACOPY.
  Global Hint Rewrite Constant_value_CALLDATACOPY : constant_rewrites.
  
  Definition value_CODESIZE : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 56 |))).
  
  Axiom Constant_value_CODESIZE :
    (M.get_constant "revm_bytecode::opcode::CODESIZE") = value_CODESIZE.
  Global Hint Rewrite Constant_value_CODESIZE : constant_rewrites.
  
  Definition value_CODECOPY : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 57 |))).
  
  Axiom Constant_value_CODECOPY :
    (M.get_constant "revm_bytecode::opcode::CODECOPY") = value_CODECOPY.
  Global Hint Rewrite Constant_value_CODECOPY : constant_rewrites.
  
  Definition value_GASPRICE : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 58 |))).
  
  Axiom Constant_value_GASPRICE :
    (M.get_constant "revm_bytecode::opcode::GASPRICE") = value_GASPRICE.
  Global Hint Rewrite Constant_value_GASPRICE : constant_rewrites.
  
  Definition value_EXTCODESIZE : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 59 |))).
  
  Axiom Constant_value_EXTCODESIZE :
    (M.get_constant "revm_bytecode::opcode::EXTCODESIZE") = value_EXTCODESIZE.
  Global Hint Rewrite Constant_value_EXTCODESIZE : constant_rewrites.
  
  Definition value_EXTCODECOPY : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 60 |))).
  
  Axiom Constant_value_EXTCODECOPY :
    (M.get_constant "revm_bytecode::opcode::EXTCODECOPY") = value_EXTCODECOPY.
  Global Hint Rewrite Constant_value_EXTCODECOPY : constant_rewrites.
  
  Definition value_RETURNDATASIZE : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 61 |))).
  
  Axiom Constant_value_RETURNDATASIZE :
    (M.get_constant "revm_bytecode::opcode::RETURNDATASIZE") = value_RETURNDATASIZE.
  Global Hint Rewrite Constant_value_RETURNDATASIZE : constant_rewrites.
  
  Definition value_RETURNDATACOPY : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 62 |))).
  
  Axiom Constant_value_RETURNDATACOPY :
    (M.get_constant "revm_bytecode::opcode::RETURNDATACOPY") = value_RETURNDATACOPY.
  Global Hint Rewrite Constant_value_RETURNDATACOPY : constant_rewrites.
  
  Definition value_EXTCODEHASH : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 63 |))).
  
  Axiom Constant_value_EXTCODEHASH :
    (M.get_constant "revm_bytecode::opcode::EXTCODEHASH") = value_EXTCODEHASH.
  Global Hint Rewrite Constant_value_EXTCODEHASH : constant_rewrites.
  
  Definition value_BLOCKHASH : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 64 |))).
  
  Axiom Constant_value_BLOCKHASH :
    (M.get_constant "revm_bytecode::opcode::BLOCKHASH") = value_BLOCKHASH.
  Global Hint Rewrite Constant_value_BLOCKHASH : constant_rewrites.
  
  Definition value_COINBASE : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 65 |))).
  
  Axiom Constant_value_COINBASE :
    (M.get_constant "revm_bytecode::opcode::COINBASE") = value_COINBASE.
  Global Hint Rewrite Constant_value_COINBASE : constant_rewrites.
  
  Definition value_TIMESTAMP : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 66 |))).
  
  Axiom Constant_value_TIMESTAMP :
    (M.get_constant "revm_bytecode::opcode::TIMESTAMP") = value_TIMESTAMP.
  Global Hint Rewrite Constant_value_TIMESTAMP : constant_rewrites.
  
  Definition value_NUMBER : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 67 |))).
  
  Axiom Constant_value_NUMBER : (M.get_constant "revm_bytecode::opcode::NUMBER") = value_NUMBER.
  Global Hint Rewrite Constant_value_NUMBER : constant_rewrites.
  
  Definition value_DIFFICULTY : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 68 |))).
  
  Axiom Constant_value_DIFFICULTY :
    (M.get_constant "revm_bytecode::opcode::DIFFICULTY") = value_DIFFICULTY.
  Global Hint Rewrite Constant_value_DIFFICULTY : constant_rewrites.
  
  Definition value_GASLIMIT : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 69 |))).
  
  Axiom Constant_value_GASLIMIT :
    (M.get_constant "revm_bytecode::opcode::GASLIMIT") = value_GASLIMIT.
  Global Hint Rewrite Constant_value_GASLIMIT : constant_rewrites.
  
  Definition value_CHAINID : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 70 |))).
  
  Axiom Constant_value_CHAINID : (M.get_constant "revm_bytecode::opcode::CHAINID") = value_CHAINID.
  Global Hint Rewrite Constant_value_CHAINID : constant_rewrites.
  
  Definition value_SELFBALANCE : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 71 |))).
  
  Axiom Constant_value_SELFBALANCE :
    (M.get_constant "revm_bytecode::opcode::SELFBALANCE") = value_SELFBALANCE.
  Global Hint Rewrite Constant_value_SELFBALANCE : constant_rewrites.
  
  Definition value_BASEFEE : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 72 |))).
  
  Axiom Constant_value_BASEFEE : (M.get_constant "revm_bytecode::opcode::BASEFEE") = value_BASEFEE.
  Global Hint Rewrite Constant_value_BASEFEE : constant_rewrites.
  
  Definition value_BLOBHASH : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 73 |))).
  
  Axiom Constant_value_BLOBHASH :
    (M.get_constant "revm_bytecode::opcode::BLOBHASH") = value_BLOBHASH.
  Global Hint Rewrite Constant_value_BLOBHASH : constant_rewrites.
  
  Definition value_BLOBBASEFEE : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 74 |))).
  
  Axiom Constant_value_BLOBBASEFEE :
    (M.get_constant "revm_bytecode::opcode::BLOBBASEFEE") = value_BLOBBASEFEE.
  Global Hint Rewrite Constant_value_BLOBBASEFEE : constant_rewrites.
  
  Definition value_POP : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 80 |))).
  
  Axiom Constant_value_POP : (M.get_constant "revm_bytecode::opcode::POP") = value_POP.
  Global Hint Rewrite Constant_value_POP : constant_rewrites.
  
  Definition value_MLOAD : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 81 |))).
  
  Axiom Constant_value_MLOAD : (M.get_constant "revm_bytecode::opcode::MLOAD") = value_MLOAD.
  Global Hint Rewrite Constant_value_MLOAD : constant_rewrites.
  
  Definition value_MSTORE : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 82 |))).
  
  Axiom Constant_value_MSTORE : (M.get_constant "revm_bytecode::opcode::MSTORE") = value_MSTORE.
  Global Hint Rewrite Constant_value_MSTORE : constant_rewrites.
  
  Definition value_MSTORE8 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 83 |))).
  
  Axiom Constant_value_MSTORE8 : (M.get_constant "revm_bytecode::opcode::MSTORE8") = value_MSTORE8.
  Global Hint Rewrite Constant_value_MSTORE8 : constant_rewrites.
  
  Definition value_SLOAD : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 84 |))).
  
  Axiom Constant_value_SLOAD : (M.get_constant "revm_bytecode::opcode::SLOAD") = value_SLOAD.
  Global Hint Rewrite Constant_value_SLOAD : constant_rewrites.
  
  Definition value_SSTORE : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 85 |))).
  
  Axiom Constant_value_SSTORE : (M.get_constant "revm_bytecode::opcode::SSTORE") = value_SSTORE.
  Global Hint Rewrite Constant_value_SSTORE : constant_rewrites.
  
  Definition value_JUMP : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 86 |))).
  
  Axiom Constant_value_JUMP : (M.get_constant "revm_bytecode::opcode::JUMP") = value_JUMP.
  Global Hint Rewrite Constant_value_JUMP : constant_rewrites.
  
  Definition value_JUMPI : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 87 |))).
  
  Axiom Constant_value_JUMPI : (M.get_constant "revm_bytecode::opcode::JUMPI") = value_JUMPI.
  Global Hint Rewrite Constant_value_JUMPI : constant_rewrites.
  
  Definition value_PC : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 88 |))).
  
  Axiom Constant_value_PC : (M.get_constant "revm_bytecode::opcode::PC") = value_PC.
  Global Hint Rewrite Constant_value_PC : constant_rewrites.
  
  Definition value_MSIZE : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 89 |))).
  
  Axiom Constant_value_MSIZE : (M.get_constant "revm_bytecode::opcode::MSIZE") = value_MSIZE.
  Global Hint Rewrite Constant_value_MSIZE : constant_rewrites.
  
  Definition value_GAS : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 90 |))).
  
  Axiom Constant_value_GAS : (M.get_constant "revm_bytecode::opcode::GAS") = value_GAS.
  Global Hint Rewrite Constant_value_GAS : constant_rewrites.
  
  Definition value_JUMPDEST : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 91 |))).
  
  Axiom Constant_value_JUMPDEST :
    (M.get_constant "revm_bytecode::opcode::JUMPDEST") = value_JUMPDEST.
  Global Hint Rewrite Constant_value_JUMPDEST : constant_rewrites.
  
  Definition value_TLOAD : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 92 |))).
  
  Axiom Constant_value_TLOAD : (M.get_constant "revm_bytecode::opcode::TLOAD") = value_TLOAD.
  Global Hint Rewrite Constant_value_TLOAD : constant_rewrites.
  
  Definition value_TSTORE : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 93 |))).
  
  Axiom Constant_value_TSTORE : (M.get_constant "revm_bytecode::opcode::TSTORE") = value_TSTORE.
  Global Hint Rewrite Constant_value_TSTORE : constant_rewrites.
  
  Definition value_MCOPY : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 94 |))).
  
  Axiom Constant_value_MCOPY : (M.get_constant "revm_bytecode::opcode::MCOPY") = value_MCOPY.
  Global Hint Rewrite Constant_value_MCOPY : constant_rewrites.
  
  Definition value_PUSH0 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 95 |))).
  
  Axiom Constant_value_PUSH0 : (M.get_constant "revm_bytecode::opcode::PUSH0") = value_PUSH0.
  Global Hint Rewrite Constant_value_PUSH0 : constant_rewrites.
  
  Definition value_PUSH1 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 96 |))).
  
  Axiom Constant_value_PUSH1 : (M.get_constant "revm_bytecode::opcode::PUSH1") = value_PUSH1.
  Global Hint Rewrite Constant_value_PUSH1 : constant_rewrites.
  
  Definition value_PUSH2 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 97 |))).
  
  Axiom Constant_value_PUSH2 : (M.get_constant "revm_bytecode::opcode::PUSH2") = value_PUSH2.
  Global Hint Rewrite Constant_value_PUSH2 : constant_rewrites.
  
  Definition value_PUSH3 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 98 |))).
  
  Axiom Constant_value_PUSH3 : (M.get_constant "revm_bytecode::opcode::PUSH3") = value_PUSH3.
  Global Hint Rewrite Constant_value_PUSH3 : constant_rewrites.
  
  Definition value_PUSH4 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 99 |))).
  
  Axiom Constant_value_PUSH4 : (M.get_constant "revm_bytecode::opcode::PUSH4") = value_PUSH4.
  Global Hint Rewrite Constant_value_PUSH4 : constant_rewrites.
  
  Definition value_PUSH5 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 100 |))).
  
  Axiom Constant_value_PUSH5 : (M.get_constant "revm_bytecode::opcode::PUSH5") = value_PUSH5.
  Global Hint Rewrite Constant_value_PUSH5 : constant_rewrites.
  
  Definition value_PUSH6 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 101 |))).
  
  Axiom Constant_value_PUSH6 : (M.get_constant "revm_bytecode::opcode::PUSH6") = value_PUSH6.
  Global Hint Rewrite Constant_value_PUSH6 : constant_rewrites.
  
  Definition value_PUSH7 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 102 |))).
  
  Axiom Constant_value_PUSH7 : (M.get_constant "revm_bytecode::opcode::PUSH7") = value_PUSH7.
  Global Hint Rewrite Constant_value_PUSH7 : constant_rewrites.
  
  Definition value_PUSH8 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 103 |))).
  
  Axiom Constant_value_PUSH8 : (M.get_constant "revm_bytecode::opcode::PUSH8") = value_PUSH8.
  Global Hint Rewrite Constant_value_PUSH8 : constant_rewrites.
  
  Definition value_PUSH9 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 104 |))).
  
  Axiom Constant_value_PUSH9 : (M.get_constant "revm_bytecode::opcode::PUSH9") = value_PUSH9.
  Global Hint Rewrite Constant_value_PUSH9 : constant_rewrites.
  
  Definition value_PUSH10 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 105 |))).
  
  Axiom Constant_value_PUSH10 : (M.get_constant "revm_bytecode::opcode::PUSH10") = value_PUSH10.
  Global Hint Rewrite Constant_value_PUSH10 : constant_rewrites.
  
  Definition value_PUSH11 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 106 |))).
  
  Axiom Constant_value_PUSH11 : (M.get_constant "revm_bytecode::opcode::PUSH11") = value_PUSH11.
  Global Hint Rewrite Constant_value_PUSH11 : constant_rewrites.
  
  Definition value_PUSH12 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 107 |))).
  
  Axiom Constant_value_PUSH12 : (M.get_constant "revm_bytecode::opcode::PUSH12") = value_PUSH12.
  Global Hint Rewrite Constant_value_PUSH12 : constant_rewrites.
  
  Definition value_PUSH13 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 108 |))).
  
  Axiom Constant_value_PUSH13 : (M.get_constant "revm_bytecode::opcode::PUSH13") = value_PUSH13.
  Global Hint Rewrite Constant_value_PUSH13 : constant_rewrites.
  
  Definition value_PUSH14 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 109 |))).
  
  Axiom Constant_value_PUSH14 : (M.get_constant "revm_bytecode::opcode::PUSH14") = value_PUSH14.
  Global Hint Rewrite Constant_value_PUSH14 : constant_rewrites.
  
  Definition value_PUSH15 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 110 |))).
  
  Axiom Constant_value_PUSH15 : (M.get_constant "revm_bytecode::opcode::PUSH15") = value_PUSH15.
  Global Hint Rewrite Constant_value_PUSH15 : constant_rewrites.
  
  Definition value_PUSH16 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 111 |))).
  
  Axiom Constant_value_PUSH16 : (M.get_constant "revm_bytecode::opcode::PUSH16") = value_PUSH16.
  Global Hint Rewrite Constant_value_PUSH16 : constant_rewrites.
  
  Definition value_PUSH17 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 112 |))).
  
  Axiom Constant_value_PUSH17 : (M.get_constant "revm_bytecode::opcode::PUSH17") = value_PUSH17.
  Global Hint Rewrite Constant_value_PUSH17 : constant_rewrites.
  
  Definition value_PUSH18 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 113 |))).
  
  Axiom Constant_value_PUSH18 : (M.get_constant "revm_bytecode::opcode::PUSH18") = value_PUSH18.
  Global Hint Rewrite Constant_value_PUSH18 : constant_rewrites.
  
  Definition value_PUSH19 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 114 |))).
  
  Axiom Constant_value_PUSH19 : (M.get_constant "revm_bytecode::opcode::PUSH19") = value_PUSH19.
  Global Hint Rewrite Constant_value_PUSH19 : constant_rewrites.
  
  Definition value_PUSH20 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 115 |))).
  
  Axiom Constant_value_PUSH20 : (M.get_constant "revm_bytecode::opcode::PUSH20") = value_PUSH20.
  Global Hint Rewrite Constant_value_PUSH20 : constant_rewrites.
  
  Definition value_PUSH21 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 116 |))).
  
  Axiom Constant_value_PUSH21 : (M.get_constant "revm_bytecode::opcode::PUSH21") = value_PUSH21.
  Global Hint Rewrite Constant_value_PUSH21 : constant_rewrites.
  
  Definition value_PUSH22 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 117 |))).
  
  Axiom Constant_value_PUSH22 : (M.get_constant "revm_bytecode::opcode::PUSH22") = value_PUSH22.
  Global Hint Rewrite Constant_value_PUSH22 : constant_rewrites.
  
  Definition value_PUSH23 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 118 |))).
  
  Axiom Constant_value_PUSH23 : (M.get_constant "revm_bytecode::opcode::PUSH23") = value_PUSH23.
  Global Hint Rewrite Constant_value_PUSH23 : constant_rewrites.
  
  Definition value_PUSH24 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 119 |))).
  
  Axiom Constant_value_PUSH24 : (M.get_constant "revm_bytecode::opcode::PUSH24") = value_PUSH24.
  Global Hint Rewrite Constant_value_PUSH24 : constant_rewrites.
  
  Definition value_PUSH25 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 120 |))).
  
  Axiom Constant_value_PUSH25 : (M.get_constant "revm_bytecode::opcode::PUSH25") = value_PUSH25.
  Global Hint Rewrite Constant_value_PUSH25 : constant_rewrites.
  
  Definition value_PUSH26 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 121 |))).
  
  Axiom Constant_value_PUSH26 : (M.get_constant "revm_bytecode::opcode::PUSH26") = value_PUSH26.
  Global Hint Rewrite Constant_value_PUSH26 : constant_rewrites.
  
  Definition value_PUSH27 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 122 |))).
  
  Axiom Constant_value_PUSH27 : (M.get_constant "revm_bytecode::opcode::PUSH27") = value_PUSH27.
  Global Hint Rewrite Constant_value_PUSH27 : constant_rewrites.
  
  Definition value_PUSH28 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 123 |))).
  
  Axiom Constant_value_PUSH28 : (M.get_constant "revm_bytecode::opcode::PUSH28") = value_PUSH28.
  Global Hint Rewrite Constant_value_PUSH28 : constant_rewrites.
  
  Definition value_PUSH29 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 124 |))).
  
  Axiom Constant_value_PUSH29 : (M.get_constant "revm_bytecode::opcode::PUSH29") = value_PUSH29.
  Global Hint Rewrite Constant_value_PUSH29 : constant_rewrites.
  
  Definition value_PUSH30 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 125 |))).
  
  Axiom Constant_value_PUSH30 : (M.get_constant "revm_bytecode::opcode::PUSH30") = value_PUSH30.
  Global Hint Rewrite Constant_value_PUSH30 : constant_rewrites.
  
  Definition value_PUSH31 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 126 |))).
  
  Axiom Constant_value_PUSH31 : (M.get_constant "revm_bytecode::opcode::PUSH31") = value_PUSH31.
  Global Hint Rewrite Constant_value_PUSH31 : constant_rewrites.
  
  Definition value_PUSH32 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 127 |))).
  
  Axiom Constant_value_PUSH32 : (M.get_constant "revm_bytecode::opcode::PUSH32") = value_PUSH32.
  Global Hint Rewrite Constant_value_PUSH32 : constant_rewrites.
  
  Definition value_DUP1 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 128 |))).
  
  Axiom Constant_value_DUP1 : (M.get_constant "revm_bytecode::opcode::DUP1") = value_DUP1.
  Global Hint Rewrite Constant_value_DUP1 : constant_rewrites.
  
  Definition value_DUP2 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 129 |))).
  
  Axiom Constant_value_DUP2 : (M.get_constant "revm_bytecode::opcode::DUP2") = value_DUP2.
  Global Hint Rewrite Constant_value_DUP2 : constant_rewrites.
  
  Definition value_DUP3 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 130 |))).
  
  Axiom Constant_value_DUP3 : (M.get_constant "revm_bytecode::opcode::DUP3") = value_DUP3.
  Global Hint Rewrite Constant_value_DUP3 : constant_rewrites.
  
  Definition value_DUP4 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 131 |))).
  
  Axiom Constant_value_DUP4 : (M.get_constant "revm_bytecode::opcode::DUP4") = value_DUP4.
  Global Hint Rewrite Constant_value_DUP4 : constant_rewrites.
  
  Definition value_DUP5 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 132 |))).
  
  Axiom Constant_value_DUP5 : (M.get_constant "revm_bytecode::opcode::DUP5") = value_DUP5.
  Global Hint Rewrite Constant_value_DUP5 : constant_rewrites.
  
  Definition value_DUP6 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 133 |))).
  
  Axiom Constant_value_DUP6 : (M.get_constant "revm_bytecode::opcode::DUP6") = value_DUP6.
  Global Hint Rewrite Constant_value_DUP6 : constant_rewrites.
  
  Definition value_DUP7 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 134 |))).
  
  Axiom Constant_value_DUP7 : (M.get_constant "revm_bytecode::opcode::DUP7") = value_DUP7.
  Global Hint Rewrite Constant_value_DUP7 : constant_rewrites.
  
  Definition value_DUP8 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 135 |))).
  
  Axiom Constant_value_DUP8 : (M.get_constant "revm_bytecode::opcode::DUP8") = value_DUP8.
  Global Hint Rewrite Constant_value_DUP8 : constant_rewrites.
  
  Definition value_DUP9 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 136 |))).
  
  Axiom Constant_value_DUP9 : (M.get_constant "revm_bytecode::opcode::DUP9") = value_DUP9.
  Global Hint Rewrite Constant_value_DUP9 : constant_rewrites.
  
  Definition value_DUP10 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 137 |))).
  
  Axiom Constant_value_DUP10 : (M.get_constant "revm_bytecode::opcode::DUP10") = value_DUP10.
  Global Hint Rewrite Constant_value_DUP10 : constant_rewrites.
  
  Definition value_DUP11 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 138 |))).
  
  Axiom Constant_value_DUP11 : (M.get_constant "revm_bytecode::opcode::DUP11") = value_DUP11.
  Global Hint Rewrite Constant_value_DUP11 : constant_rewrites.
  
  Definition value_DUP12 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 139 |))).
  
  Axiom Constant_value_DUP12 : (M.get_constant "revm_bytecode::opcode::DUP12") = value_DUP12.
  Global Hint Rewrite Constant_value_DUP12 : constant_rewrites.
  
  Definition value_DUP13 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 140 |))).
  
  Axiom Constant_value_DUP13 : (M.get_constant "revm_bytecode::opcode::DUP13") = value_DUP13.
  Global Hint Rewrite Constant_value_DUP13 : constant_rewrites.
  
  Definition value_DUP14 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 141 |))).
  
  Axiom Constant_value_DUP14 : (M.get_constant "revm_bytecode::opcode::DUP14") = value_DUP14.
  Global Hint Rewrite Constant_value_DUP14 : constant_rewrites.
  
  Definition value_DUP15 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 142 |))).
  
  Axiom Constant_value_DUP15 : (M.get_constant "revm_bytecode::opcode::DUP15") = value_DUP15.
  Global Hint Rewrite Constant_value_DUP15 : constant_rewrites.
  
  Definition value_DUP16 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 143 |))).
  
  Axiom Constant_value_DUP16 : (M.get_constant "revm_bytecode::opcode::DUP16") = value_DUP16.
  Global Hint Rewrite Constant_value_DUP16 : constant_rewrites.
  
  Definition value_SWAP1 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 144 |))).
  
  Axiom Constant_value_SWAP1 : (M.get_constant "revm_bytecode::opcode::SWAP1") = value_SWAP1.
  Global Hint Rewrite Constant_value_SWAP1 : constant_rewrites.
  
  Definition value_SWAP2 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 145 |))).
  
  Axiom Constant_value_SWAP2 : (M.get_constant "revm_bytecode::opcode::SWAP2") = value_SWAP2.
  Global Hint Rewrite Constant_value_SWAP2 : constant_rewrites.
  
  Definition value_SWAP3 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 146 |))).
  
  Axiom Constant_value_SWAP3 : (M.get_constant "revm_bytecode::opcode::SWAP3") = value_SWAP3.
  Global Hint Rewrite Constant_value_SWAP3 : constant_rewrites.
  
  Definition value_SWAP4 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 147 |))).
  
  Axiom Constant_value_SWAP4 : (M.get_constant "revm_bytecode::opcode::SWAP4") = value_SWAP4.
  Global Hint Rewrite Constant_value_SWAP4 : constant_rewrites.
  
  Definition value_SWAP5 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 148 |))).
  
  Axiom Constant_value_SWAP5 : (M.get_constant "revm_bytecode::opcode::SWAP5") = value_SWAP5.
  Global Hint Rewrite Constant_value_SWAP5 : constant_rewrites.
  
  Definition value_SWAP6 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 149 |))).
  
  Axiom Constant_value_SWAP6 : (M.get_constant "revm_bytecode::opcode::SWAP6") = value_SWAP6.
  Global Hint Rewrite Constant_value_SWAP6 : constant_rewrites.
  
  Definition value_SWAP7 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 150 |))).
  
  Axiom Constant_value_SWAP7 : (M.get_constant "revm_bytecode::opcode::SWAP7") = value_SWAP7.
  Global Hint Rewrite Constant_value_SWAP7 : constant_rewrites.
  
  Definition value_SWAP8 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 151 |))).
  
  Axiom Constant_value_SWAP8 : (M.get_constant "revm_bytecode::opcode::SWAP8") = value_SWAP8.
  Global Hint Rewrite Constant_value_SWAP8 : constant_rewrites.
  
  Definition value_SWAP9 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 152 |))).
  
  Axiom Constant_value_SWAP9 : (M.get_constant "revm_bytecode::opcode::SWAP9") = value_SWAP9.
  Global Hint Rewrite Constant_value_SWAP9 : constant_rewrites.
  
  Definition value_SWAP10 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 153 |))).
  
  Axiom Constant_value_SWAP10 : (M.get_constant "revm_bytecode::opcode::SWAP10") = value_SWAP10.
  Global Hint Rewrite Constant_value_SWAP10 : constant_rewrites.
  
  Definition value_SWAP11 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 154 |))).
  
  Axiom Constant_value_SWAP11 : (M.get_constant "revm_bytecode::opcode::SWAP11") = value_SWAP11.
  Global Hint Rewrite Constant_value_SWAP11 : constant_rewrites.
  
  Definition value_SWAP12 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 155 |))).
  
  Axiom Constant_value_SWAP12 : (M.get_constant "revm_bytecode::opcode::SWAP12") = value_SWAP12.
  Global Hint Rewrite Constant_value_SWAP12 : constant_rewrites.
  
  Definition value_SWAP13 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 156 |))).
  
  Axiom Constant_value_SWAP13 : (M.get_constant "revm_bytecode::opcode::SWAP13") = value_SWAP13.
  Global Hint Rewrite Constant_value_SWAP13 : constant_rewrites.
  
  Definition value_SWAP14 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 157 |))).
  
  Axiom Constant_value_SWAP14 : (M.get_constant "revm_bytecode::opcode::SWAP14") = value_SWAP14.
  Global Hint Rewrite Constant_value_SWAP14 : constant_rewrites.
  
  Definition value_SWAP15 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 158 |))).
  
  Axiom Constant_value_SWAP15 : (M.get_constant "revm_bytecode::opcode::SWAP15") = value_SWAP15.
  Global Hint Rewrite Constant_value_SWAP15 : constant_rewrites.
  
  Definition value_SWAP16 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 159 |))).
  
  Axiom Constant_value_SWAP16 : (M.get_constant "revm_bytecode::opcode::SWAP16") = value_SWAP16.
  Global Hint Rewrite Constant_value_SWAP16 : constant_rewrites.
  
  Definition value_LOG0 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 160 |))).
  
  Axiom Constant_value_LOG0 : (M.get_constant "revm_bytecode::opcode::LOG0") = value_LOG0.
  Global Hint Rewrite Constant_value_LOG0 : constant_rewrites.
  
  Definition value_LOG1 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 161 |))).
  
  Axiom Constant_value_LOG1 : (M.get_constant "revm_bytecode::opcode::LOG1") = value_LOG1.
  Global Hint Rewrite Constant_value_LOG1 : constant_rewrites.
  
  Definition value_LOG2 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 162 |))).
  
  Axiom Constant_value_LOG2 : (M.get_constant "revm_bytecode::opcode::LOG2") = value_LOG2.
  Global Hint Rewrite Constant_value_LOG2 : constant_rewrites.
  
  Definition value_LOG3 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 163 |))).
  
  Axiom Constant_value_LOG3 : (M.get_constant "revm_bytecode::opcode::LOG3") = value_LOG3.
  Global Hint Rewrite Constant_value_LOG3 : constant_rewrites.
  
  Definition value_LOG4 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 164 |))).
  
  Axiom Constant_value_LOG4 : (M.get_constant "revm_bytecode::opcode::LOG4") = value_LOG4.
  Global Hint Rewrite Constant_value_LOG4 : constant_rewrites.
  
  Definition value_DATALOAD : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 208 |))).
  
  Axiom Constant_value_DATALOAD :
    (M.get_constant "revm_bytecode::opcode::DATALOAD") = value_DATALOAD.
  Global Hint Rewrite Constant_value_DATALOAD : constant_rewrites.
  
  Definition value_DATALOADN : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 209 |))).
  
  Axiom Constant_value_DATALOADN :
    (M.get_constant "revm_bytecode::opcode::DATALOADN") = value_DATALOADN.
  Global Hint Rewrite Constant_value_DATALOADN : constant_rewrites.
  
  Definition value_DATASIZE : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 210 |))).
  
  Axiom Constant_value_DATASIZE :
    (M.get_constant "revm_bytecode::opcode::DATASIZE") = value_DATASIZE.
  Global Hint Rewrite Constant_value_DATASIZE : constant_rewrites.
  
  Definition value_DATACOPY : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 211 |))).
  
  Axiom Constant_value_DATACOPY :
    (M.get_constant "revm_bytecode::opcode::DATACOPY") = value_DATACOPY.
  Global Hint Rewrite Constant_value_DATACOPY : constant_rewrites.
  
  Definition value_RJUMP : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 224 |))).
  
  Axiom Constant_value_RJUMP : (M.get_constant "revm_bytecode::opcode::RJUMP") = value_RJUMP.
  Global Hint Rewrite Constant_value_RJUMP : constant_rewrites.
  
  Definition value_RJUMPI : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 225 |))).
  
  Axiom Constant_value_RJUMPI : (M.get_constant "revm_bytecode::opcode::RJUMPI") = value_RJUMPI.
  Global Hint Rewrite Constant_value_RJUMPI : constant_rewrites.
  
  Definition value_RJUMPV : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 226 |))).
  
  Axiom Constant_value_RJUMPV : (M.get_constant "revm_bytecode::opcode::RJUMPV") = value_RJUMPV.
  Global Hint Rewrite Constant_value_RJUMPV : constant_rewrites.
  
  Definition value_CALLF : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 227 |))).
  
  Axiom Constant_value_CALLF : (M.get_constant "revm_bytecode::opcode::CALLF") = value_CALLF.
  Global Hint Rewrite Constant_value_CALLF : constant_rewrites.
  
  Definition value_RETF : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 228 |))).
  
  Axiom Constant_value_RETF : (M.get_constant "revm_bytecode::opcode::RETF") = value_RETF.
  Global Hint Rewrite Constant_value_RETF : constant_rewrites.
  
  Definition value_JUMPF : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 229 |))).
  
  Axiom Constant_value_JUMPF : (M.get_constant "revm_bytecode::opcode::JUMPF") = value_JUMPF.
  Global Hint Rewrite Constant_value_JUMPF : constant_rewrites.
  
  Definition value_DUPN : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 230 |))).
  
  Axiom Constant_value_DUPN : (M.get_constant "revm_bytecode::opcode::DUPN") = value_DUPN.
  Global Hint Rewrite Constant_value_DUPN : constant_rewrites.
  
  Definition value_SWAPN : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 231 |))).
  
  Axiom Constant_value_SWAPN : (M.get_constant "revm_bytecode::opcode::SWAPN") = value_SWAPN.
  Global Hint Rewrite Constant_value_SWAPN : constant_rewrites.
  
  Definition value_EXCHANGE : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 232 |))).
  
  Axiom Constant_value_EXCHANGE :
    (M.get_constant "revm_bytecode::opcode::EXCHANGE") = value_EXCHANGE.
  Global Hint Rewrite Constant_value_EXCHANGE : constant_rewrites.
  
  Definition value_EOFCREATE : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 236 |))).
  
  Axiom Constant_value_EOFCREATE :
    (M.get_constant "revm_bytecode::opcode::EOFCREATE") = value_EOFCREATE.
  Global Hint Rewrite Constant_value_EOFCREATE : constant_rewrites.
  
  Definition value_RETURNCONTRACT : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 238 |))).
  
  Axiom Constant_value_RETURNCONTRACT :
    (M.get_constant "revm_bytecode::opcode::RETURNCONTRACT") = value_RETURNCONTRACT.
  Global Hint Rewrite Constant_value_RETURNCONTRACT : constant_rewrites.
  
  Definition value_CREATE : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 240 |))).
  
  Axiom Constant_value_CREATE : (M.get_constant "revm_bytecode::opcode::CREATE") = value_CREATE.
  Global Hint Rewrite Constant_value_CREATE : constant_rewrites.
  
  Definition value_CALL : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 241 |))).
  
  Axiom Constant_value_CALL : (M.get_constant "revm_bytecode::opcode::CALL") = value_CALL.
  Global Hint Rewrite Constant_value_CALL : constant_rewrites.
  
  Definition value_CALLCODE : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 242 |))).
  
  Axiom Constant_value_CALLCODE :
    (M.get_constant "revm_bytecode::opcode::CALLCODE") = value_CALLCODE.
  Global Hint Rewrite Constant_value_CALLCODE : constant_rewrites.
  
  Definition value_RETURN : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 243 |))).
  
  Axiom Constant_value_RETURN : (M.get_constant "revm_bytecode::opcode::RETURN") = value_RETURN.
  Global Hint Rewrite Constant_value_RETURN : constant_rewrites.
  
  Definition value_DELEGATECALL : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 244 |))).
  
  Axiom Constant_value_DELEGATECALL :
    (M.get_constant "revm_bytecode::opcode::DELEGATECALL") = value_DELEGATECALL.
  Global Hint Rewrite Constant_value_DELEGATECALL : constant_rewrites.
  
  Definition value_CREATE2 : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 245 |))).
  
  Axiom Constant_value_CREATE2 : (M.get_constant "revm_bytecode::opcode::CREATE2") = value_CREATE2.
  Global Hint Rewrite Constant_value_CREATE2 : constant_rewrites.
  
  Definition value_RETURNDATALOAD : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 247 |))).
  
  Axiom Constant_value_RETURNDATALOAD :
    (M.get_constant "revm_bytecode::opcode::RETURNDATALOAD") = value_RETURNDATALOAD.
  Global Hint Rewrite Constant_value_RETURNDATALOAD : constant_rewrites.
  
  Definition value_EXTCALL : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 248 |))).
  
  Axiom Constant_value_EXTCALL : (M.get_constant "revm_bytecode::opcode::EXTCALL") = value_EXTCALL.
  Global Hint Rewrite Constant_value_EXTCALL : constant_rewrites.
  
  Definition value_EXTDELEGATECALL : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 249 |))).
  
  Axiom Constant_value_EXTDELEGATECALL :
    (M.get_constant "revm_bytecode::opcode::EXTDELEGATECALL") = value_EXTDELEGATECALL.
  Global Hint Rewrite Constant_value_EXTDELEGATECALL : constant_rewrites.
  
  Definition value_STATICCALL : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 250 |))).
  
  Axiom Constant_value_STATICCALL :
    (M.get_constant "revm_bytecode::opcode::STATICCALL") = value_STATICCALL.
  Global Hint Rewrite Constant_value_STATICCALL : constant_rewrites.
  
  Definition value_EXTSTATICCALL : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 251 |))).
  
  Axiom Constant_value_EXTSTATICCALL :
    (M.get_constant "revm_bytecode::opcode::EXTSTATICCALL") = value_EXTSTATICCALL.
  Global Hint Rewrite Constant_value_EXTSTATICCALL : constant_rewrites.
  
  Definition value_REVERT : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 253 |))).
  
  Axiom Constant_value_REVERT : (M.get_constant "revm_bytecode::opcode::REVERT") = value_REVERT.
  Global Hint Rewrite Constant_value_REVERT : constant_rewrites.
  
  Definition value_INVALID : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 254 |))).
  
  Axiom Constant_value_INVALID : (M.get_constant "revm_bytecode::opcode::INVALID") = value_INVALID.
  Global Hint Rewrite Constant_value_INVALID : constant_rewrites.
  
  Definition value_SELFDESTRUCT : Value.t :=
    M.run_constant ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 255 |))).
  
  Axiom Constant_value_SELFDESTRUCT :
    (M.get_constant "revm_bytecode::opcode::SELFDESTRUCT") = value_SELFDESTRUCT.
  Global Hint Rewrite Constant_value_SELFDESTRUCT : constant_rewrites.
  
  
  Definition value_OPCODE_INFO : Value.t :=
    M.run_constant
      ltac:(M.monadic
        (let~ map :
            Ty.apply
              (Ty.path "array")
              [ Value.Integer IntegerKind.Usize 256 ]
              [
                Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [ Ty.path "revm_bytecode::opcode::OpCodeInfo" ]
              ] :=
          M.alloc (|
            repeat (|
              Value.StructTuple "core::option::Option::None" [],
              Value.Integer IntegerKind.Usize 256
            |)
          |) in
        let~ prev : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 0 |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 0 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "STOP" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 0 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::terminating", [], [] |),
              [ M.read (| info |) ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 0 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 1 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "ADD" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 2; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 1 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 2 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "MUL" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 2; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 2 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 3 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "SUB" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 2; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 3 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 4 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "DIV" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 2; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 4 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 5 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "SDIV" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 2; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 5 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 6 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "MOD" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 2; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 6 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 7 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "SMOD" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 2; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 7 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 8 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "ADDMOD" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 3; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 8 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 9 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "MULMOD" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 3; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 9 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 10 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "EXP" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 2; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 10 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 11 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "SIGNEXTEND" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 2; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 11 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 16 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "LT" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 2; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 16 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 17 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "GT" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 2; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 17 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 18 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "SLT" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 2; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 18 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 19 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "SGT" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 2; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 19 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 20 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "EQ" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 2; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 20 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 21 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "ISZERO" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 1; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 21 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 22 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "AND" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 2; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 22 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 23 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "OR" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 2; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 23 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 24 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "XOR" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 2; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 24 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 25 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "NOT" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 1; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 25 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 26 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "BYTE" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 2; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 26 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 27 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "SHL" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 2; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 27 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 28 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "SHR" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 2; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 28 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 29 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "SAR" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 2; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 29 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 32 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "KECCAK256" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 2; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 32 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 48 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "ADDRESS" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 48 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 49 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "BALANCE" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 1; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 49 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 50 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "ORIGIN" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 50 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 51 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "CALLER" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 51 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 52 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "CALLVALUE" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 52 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 53 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "CALLDATALOAD" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 1; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 53 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 54 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "CALLDATASIZE" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 54 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 55 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "CALLDATACOPY" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 3; Value.Integer IntegerKind.U8 0 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 55 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 56 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "CODESIZE" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::not_eof", [], [] |),
              [ M.read (| info |) ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 56 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 57 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "CODECOPY" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 3; Value.Integer IntegerKind.U8 0 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::not_eof", [], [] |),
              [ M.read (| info |) ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 57 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 58 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "GASPRICE" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 58 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 59 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "EXTCODESIZE" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 1; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::not_eof", [], [] |),
              [ M.read (| info |) ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 59 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 60 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "EXTCODECOPY" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 4; Value.Integer IntegerKind.U8 0 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::not_eof", [], [] |),
              [ M.read (| info |) ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 60 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 61 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "RETURNDATASIZE" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 61 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 62 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "RETURNDATACOPY" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 3; Value.Integer IntegerKind.U8 0 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 62 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 63 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "EXTCODEHASH" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 1; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::not_eof", [], [] |),
              [ M.read (| info |) ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 63 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 64 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "BLOCKHASH" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 1; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 64 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 65 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "COINBASE" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 65 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 66 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "TIMESTAMP" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 66 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 67 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "NUMBER" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 67 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 68 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "DIFFICULTY" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 68 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 69 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "GASLIMIT" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 69 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 70 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "CHAINID" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 70 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 71 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "SELFBALANCE" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 71 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 72 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "BASEFEE" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 72 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 73 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "BLOBHASH" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 1; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 73 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 74 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "BLOBBASEFEE" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 74 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 80 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "POP" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 1; Value.Integer IntegerKind.U8 0 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 80 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 81 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "MLOAD" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 1; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 81 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 82 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "MSTORE" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 2; Value.Integer IntegerKind.U8 0 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 82 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 83 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "MSTORE8" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 2; Value.Integer IntegerKind.U8 0 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 83 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 84 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "SLOAD" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 1; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 84 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 85 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "SSTORE" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 2; Value.Integer IntegerKind.U8 0 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 85 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 86 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "JUMP" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 1; Value.Integer IntegerKind.U8 0 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::not_eof", [], [] |),
              [ M.read (| info |) ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 86 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 87 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "JUMPI" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 2; Value.Integer IntegerKind.U8 0 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::not_eof", [], [] |),
              [ M.read (| info |) ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 87 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 88 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "PC" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::not_eof", [], [] |),
              [ M.read (| info |) ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 88 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 89 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "MSIZE" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 89 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 90 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "GAS" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::not_eof", [], [] |),
              [ M.read (| info |) ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 90 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 91 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "JUMPDEST" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 0 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 91 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 92 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "TLOAD" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 1; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 92 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 93 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "TSTORE" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 2; Value.Integer IntegerKind.U8 0 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 93 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 94 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "MCOPY" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 3; Value.Integer IntegerKind.U8 0 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 94 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 95 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "PUSH0" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 95 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 96 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "PUSH1" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::immediate_size", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 96 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 97 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "PUSH2" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::immediate_size", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 2 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 97 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 98 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "PUSH3" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::immediate_size", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 3 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 98 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 99 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "PUSH4" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::immediate_size", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 4 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 99 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 100 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "PUSH5" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::immediate_size", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 5 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 100 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 101 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "PUSH6" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::immediate_size", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 6 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 101 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 102 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "PUSH7" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::immediate_size", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 7 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 102 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 103 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "PUSH8" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::immediate_size", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 8 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 103 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 104 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "PUSH9" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::immediate_size", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 9 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 104 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 105 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "PUSH10" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::immediate_size", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 10 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 105 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 106 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "PUSH11" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::immediate_size", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 11 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 106 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 107 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "PUSH12" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::immediate_size", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 12 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 107 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 108 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "PUSH13" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::immediate_size", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 13 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 108 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 109 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "PUSH14" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::immediate_size", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 14 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 109 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 110 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "PUSH15" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::immediate_size", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 15 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 110 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 111 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "PUSH16" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::immediate_size", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 16 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 111 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 112 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "PUSH17" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::immediate_size", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 17 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 112 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 113 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "PUSH18" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::immediate_size", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 18 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 113 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 114 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "PUSH19" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::immediate_size", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 19 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 114 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 115 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "PUSH20" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::immediate_size", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 20 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 115 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 116 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "PUSH21" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::immediate_size", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 21 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 116 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 117 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "PUSH22" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::immediate_size", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 22 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 117 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 118 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "PUSH23" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::immediate_size", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 23 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 118 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 119 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "PUSH24" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::immediate_size", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 24 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 119 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 120 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "PUSH25" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::immediate_size", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 25 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 120 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 121 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "PUSH26" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::immediate_size", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 26 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 121 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 122 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "PUSH27" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::immediate_size", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 27 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 122 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 123 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "PUSH28" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::immediate_size", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 28 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 123 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 124 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "PUSH29" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::immediate_size", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 29 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 124 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 125 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "PUSH30" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::immediate_size", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 30 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 125 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 126 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "PUSH31" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::immediate_size", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 31 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 126 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 127 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "PUSH32" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::immediate_size", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 32 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 127 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 128 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "DUP1" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 1; Value.Integer IntegerKind.U8 2 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 128 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 129 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "DUP2" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 2; Value.Integer IntegerKind.U8 3 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 129 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 130 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "DUP3" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 3; Value.Integer IntegerKind.U8 4 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 130 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 131 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "DUP4" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 4; Value.Integer IntegerKind.U8 5 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 131 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 132 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "DUP5" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 5; Value.Integer IntegerKind.U8 6 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 132 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 133 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "DUP6" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 6; Value.Integer IntegerKind.U8 7 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 133 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 134 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "DUP7" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 7; Value.Integer IntegerKind.U8 8 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 134 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 135 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "DUP8" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 8; Value.Integer IntegerKind.U8 9 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 135 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 136 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "DUP9" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 9; Value.Integer IntegerKind.U8 10 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 136 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 137 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "DUP10" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 10; Value.Integer IntegerKind.U8 11
              ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 137 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 138 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "DUP11" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 11; Value.Integer IntegerKind.U8 12
              ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 138 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 139 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "DUP12" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 12; Value.Integer IntegerKind.U8 13
              ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 139 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 140 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "DUP13" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 13; Value.Integer IntegerKind.U8 14
              ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 140 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 141 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "DUP14" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 14; Value.Integer IntegerKind.U8 15
              ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 141 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 142 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "DUP15" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 15; Value.Integer IntegerKind.U8 16
              ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 142 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 143 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "DUP16" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 16; Value.Integer IntegerKind.U8 17
              ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 143 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 144 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "SWAP1" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 2; Value.Integer IntegerKind.U8 2 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 144 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 145 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "SWAP2" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 3; Value.Integer IntegerKind.U8 3 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 145 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 146 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "SWAP3" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 4; Value.Integer IntegerKind.U8 4 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 146 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 147 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "SWAP4" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 5; Value.Integer IntegerKind.U8 5 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 147 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 148 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "SWAP5" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 6; Value.Integer IntegerKind.U8 6 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 148 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 149 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "SWAP6" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 7; Value.Integer IntegerKind.U8 7 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 149 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 150 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "SWAP7" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 8; Value.Integer IntegerKind.U8 8 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 150 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 151 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "SWAP8" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 9; Value.Integer IntegerKind.U8 9 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 151 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 152 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "SWAP9" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 10; Value.Integer IntegerKind.U8 10
              ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 152 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 153 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "SWAP10" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 11; Value.Integer IntegerKind.U8 11
              ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 153 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 154 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "SWAP11" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 12; Value.Integer IntegerKind.U8 12
              ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 154 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 155 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "SWAP12" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 13; Value.Integer IntegerKind.U8 13
              ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 155 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 156 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "SWAP13" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 14; Value.Integer IntegerKind.U8 14
              ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 156 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 157 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "SWAP14" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 15; Value.Integer IntegerKind.U8 15
              ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 157 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 158 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "SWAP15" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 16; Value.Integer IntegerKind.U8 16
              ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 158 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 159 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "SWAP16" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 17; Value.Integer IntegerKind.U8 17
              ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 159 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 160 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "LOG0" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 2; Value.Integer IntegerKind.U8 0 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 160 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 161 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "LOG1" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 3; Value.Integer IntegerKind.U8 0 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 161 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 162 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "LOG2" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 4; Value.Integer IntegerKind.U8 0 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 162 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 163 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "LOG3" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 5; Value.Integer IntegerKind.U8 0 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 163 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 164 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "LOG4" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 6; Value.Integer IntegerKind.U8 0 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 164 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 208 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "DATALOAD" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 1; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 208 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 209 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "DATALOADN" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::immediate_size", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 2 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 209 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 210 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "DATASIZE" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 210 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 211 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "DATACOPY" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 3; Value.Integer IntegerKind.U8 0 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 211 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 224 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "RJUMP" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 0 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::immediate_size", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 2 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::terminating", [], [] |),
              [ M.read (| info |) ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 224 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 225 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "RJUMPI" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 1; Value.Integer IntegerKind.U8 0 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::immediate_size", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 2 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 225 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 226 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "RJUMPV" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 1; Value.Integer IntegerKind.U8 0 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::immediate_size", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 226 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 227 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "CALLF" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 0 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::immediate_size", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 2 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 227 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 228 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "RETF" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 0 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::terminating", [], [] |),
              [ M.read (| info |) ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 228 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 229 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "JUMPF" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 0 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::immediate_size", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 2 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::terminating", [], [] |),
              [ M.read (| info |) ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 229 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 230 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "DUPN" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::immediate_size", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 230 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 231 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "SWAPN" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 0 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::immediate_size", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 231 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 232 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "EXCHANGE" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 0 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::immediate_size", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 232 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 236 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "EOFCREATE" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 4; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::immediate_size", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 236 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 238 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "RETURNCONTRACT" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 2; Value.Integer IntegerKind.U8 0 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::immediate_size", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::terminating", [], [] |),
              [ M.read (| info |) ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 238 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 240 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "CREATE" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 3; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::not_eof", [], [] |),
              [ M.read (| info |) ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 240 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 241 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "CALL" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 7; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::not_eof", [], [] |),
              [ M.read (| info |) ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 241 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 242 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "CALLCODE" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 7; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::not_eof", [], [] |),
              [ M.read (| info |) ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 242 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 243 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "RETURN" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 2; Value.Integer IntegerKind.U8 0 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::terminating", [], [] |),
              [ M.read (| info |) ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 243 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 244 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "DELEGATECALL" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 6; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::not_eof", [], [] |),
              [ M.read (| info |) ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 244 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 245 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "CREATE2" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 4; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::not_eof", [], [] |),
              [ M.read (| info |) ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 245 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 247 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "RETURNDATALOAD" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 1; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 247 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 248 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "EXTCALL" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 4; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 248 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 249 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "EXTDELEGATECALL" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 3; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 249 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 250 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "STATICCALL" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 6; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::not_eof", [], [] |),
              [ M.read (| info |) ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 250 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 251 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "EXTSTATICCALL" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 3; Value.Integer IntegerKind.U8 1 ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 251 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 253 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "REVERT" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 2; Value.Integer IntegerKind.U8 0 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::terminating", [], [] |),
              [ M.read (| info |) ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 253 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 254 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "INVALID" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 0; Value.Integer IntegerKind.U8 0 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::terminating", [], [] |),
              [ M.read (| info |) ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 254 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        let~ val : Ty.path "u8" := M.alloc (| Value.Integer IntegerKind.U8 255 |) in
        let~ _ : Ty.tuple [] :=
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        UnOp.not (|
                          LogicalOp.or (|
                            BinOp.eq (| M.read (| val |), Value.Integer IntegerKind.U8 0 |),
                            ltac:(M.monadic (BinOp.gt (| M.read (| val |), M.read (| prev |) |)))
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::panicking::panic_fmt", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            Value.String "opcodes must be sorted in ascending order"
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |) in
        let~ _ : Ty.tuple [] := M.alloc (| M.write (| prev, M.read (| val |) |) |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_associated_function (|
                Ty.path "revm_bytecode::opcode::OpCodeInfo",
                "new",
                [],
                []
              |),
              [ M.read (| Value.String "SELFDESTRUCT" |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::stack_io", [], [] |),
              [ M.read (| info |); Value.Integer IntegerKind.U8 1; Value.Integer IntegerKind.U8 0 ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::not_eof", [], [] |),
              [ M.read (| info |) ]
            |)
          |) in
        let~ info : Ty.path "revm_bytecode::opcode::OpCodeInfo" :=
          M.alloc (|
            M.call_closure (|
              Ty.path "revm_bytecode::opcode::OpCodeInfo",
              M.get_function (| "revm_bytecode::opcode::terminating", [], [] |),
              [ M.read (| info |) ]
            |)
          |) in
        let~ _ : Ty.tuple [] :=
          M.alloc (|
            M.write (|
              M.SubPointer.get_array_field (|
                map,
                M.alloc (| Value.Integer IntegerKind.Usize 255 |)
              |),
              Value.StructTuple "core::option::Option::Some" [ M.read (| info |) ]
            |)
          |) in
        M.match_operator (| prev, [ fun γ => ltac:(M.monadic map) ] |))).
  
  Axiom Constant_value_OPCODE_INFO :
    (M.get_constant "revm_bytecode::opcode::OPCODE_INFO") = value_OPCODE_INFO.
  Global Hint Rewrite Constant_value_OPCODE_INFO : constant_rewrites.
  
  Definition value_NAME_TO_OPCODE : Value.t :=
    M.run_constant
      ltac:(M.monadic
        (M.alloc (|
          M.alloc (|
            Value.StructRecord
              "phf::map::Map"
              [
                ("key", Value.Integer IntegerKind.U64 12913932095322966823);
                ("disps",
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Value.Array
                            [
                              Value.Tuple
                                [ Value.Integer IntegerKind.U32 0; Value.Integer IntegerKind.U32 13
                                ];
                              Value.Tuple
                                [ Value.Integer IntegerKind.U32 0; Value.Integer IntegerKind.U32 25
                                ];
                              Value.Tuple
                                [ Value.Integer IntegerKind.U32 3; Value.Integer IntegerKind.U32 164
                                ];
                              Value.Tuple
                                [ Value.Integer IntegerKind.U32 0; Value.Integer IntegerKind.U32 0
                                ];
                              Value.Tuple
                                [ Value.Integer IntegerKind.U32 0; Value.Integer IntegerKind.U32 67
                                ];
                              Value.Tuple
                                [ Value.Integer IntegerKind.U32 2; Value.Integer IntegerKind.U32 147
                                ];
                              Value.Tuple
                                [ Value.Integer IntegerKind.U32 0; Value.Integer IntegerKind.U32 25
                                ];
                              Value.Tuple
                                [ Value.Integer IntegerKind.U32 1; Value.Integer IntegerKind.U32 137
                                ];
                              Value.Tuple
                                [ Value.Integer IntegerKind.U32 8; Value.Integer IntegerKind.U32 48
                                ];
                              Value.Tuple
                                [ Value.Integer IntegerKind.U32 0; Value.Integer IntegerKind.U32 18
                                ];
                              Value.Tuple
                                [ Value.Integer IntegerKind.U32 2; Value.Integer IntegerKind.U32 1
                                ];
                              Value.Tuple
                                [ Value.Integer IntegerKind.U32 0; Value.Integer IntegerKind.U32 61
                                ];
                              Value.Tuple
                                [ Value.Integer IntegerKind.U32 0; Value.Integer IntegerKind.U32 17
                                ];
                              Value.Tuple
                                [ Value.Integer IntegerKind.U32 1; Value.Integer IntegerKind.U32 70
                                ];
                              Value.Tuple
                                [ Value.Integer IntegerKind.U32 1; Value.Integer IntegerKind.U32 28
                                ];
                              Value.Tuple
                                [ Value.Integer IntegerKind.U32 0; Value.Integer IntegerKind.U32 0
                                ];
                              Value.Tuple
                                [ Value.Integer IntegerKind.U32 12; Value.Integer IntegerKind.U32 71
                                ];
                              Value.Tuple
                                [ Value.Integer IntegerKind.U32 0; Value.Integer IntegerKind.U32 8
                                ];
                              Value.Tuple
                                [ Value.Integer IntegerKind.U32 0; Value.Integer IntegerKind.U32 11
                                ];
                              Value.Tuple
                                [ Value.Integer IntegerKind.U32 0; Value.Integer IntegerKind.U32 38
                                ];
                              Value.Tuple
                                [ Value.Integer IntegerKind.U32 0; Value.Integer IntegerKind.U32 18
                                ];
                              Value.Tuple
                                [
                                  Value.Integer IntegerKind.U32 37;
                                  Value.Integer IntegerKind.U32 159
                                ];
                              Value.Tuple
                                [ Value.Integer IntegerKind.U32 0; Value.Integer IntegerKind.U32 59
                                ];
                              Value.Tuple
                                [ Value.Integer IntegerKind.U32 0; Value.Integer IntegerKind.U32 53
                                ];
                              Value.Tuple
                                [ Value.Integer IntegerKind.U32 0; Value.Integer IntegerKind.U32 1
                                ];
                              Value.Tuple
                                [ Value.Integer IntegerKind.U32 0; Value.Integer IntegerKind.U32 14
                                ];
                              Value.Tuple
                                [ Value.Integer IntegerKind.U32 3; Value.Integer IntegerKind.U32 152
                                ];
                              Value.Tuple
                                [ Value.Integer IntegerKind.U32 1; Value.Integer IntegerKind.U32 91
                                ];
                              Value.Tuple
                                [ Value.Integer IntegerKind.U32 0; Value.Integer IntegerKind.U32 4
                                ];
                              Value.Tuple
                                [ Value.Integer IntegerKind.U32 3; Value.Integer IntegerKind.U32 27
                                ];
                              Value.Tuple
                                [ Value.Integer IntegerKind.U32 0; Value.Integer IntegerKind.U32 1
                                ];
                              Value.Tuple
                                [ Value.Integer IntegerKind.U32 2; Value.Integer IntegerKind.U32 2
                                ];
                              Value.Tuple
                                [ Value.Integer IntegerKind.U32 2; Value.Integer IntegerKind.U32 157
                                ];
                              Value.Tuple
                                [
                                  Value.Integer IntegerKind.U32 125;
                                  Value.Integer IntegerKind.U32 89
                                ]
                            ]
                        |)
                      |)
                    |)
                  |));
                ("entries",
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Value.Array
                            [
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "RETURN" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::RETURN" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "CALLDATACOPY" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::CALLDATACOPY" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "SWAP1" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::SWAP1" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "DUPN" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::DUPN" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "ORIGIN" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::ORIGIN" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "SWAP9" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::SWAP9" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "GASLIMIT" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::GASLIMIT" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "DUP1" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::DUP1" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "PUSH13" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::PUSH13" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "REVERT" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::REVERT" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "EXP" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::EXP" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "MULMOD" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::MULMOD" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "PUSH7" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::PUSH7" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "XOR" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::XOR" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "SLOAD" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::SLOAD" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "SWAP11" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::SWAP11" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "RETURNCONTRACT" |) |)
                                  |);
                                  M.read (|
                                    M.get_constant "revm_bytecode::opcode::RETURNCONTRACT"
                                  |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "DATACOPY" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::DATACOPY" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "PUSH29" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::PUSH29" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "SWAP6" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::SWAP6" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "PUSH11" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::PUSH11" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "CREATE2" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::CREATE2" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "KECCAK256" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::KECCAK256" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "EXCHANGE" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::EXCHANGE" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "PUSH1" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::PUSH1" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "MSTORE8" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::MSTORE8" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "DUP2" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::DUP2" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "LOG3" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::LOG3" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "RJUMPV" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::RJUMPV" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "BLOBBASEFEE" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::BLOBBASEFEE" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "CODECOPY" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::CODECOPY" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "SWAP16" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::SWAP16" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "SWAP8" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::SWAP8" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "GT" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::GT" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "CALLVALUE" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::CALLVALUE" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "COINBASE" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::COINBASE" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "PUSH21" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::PUSH21" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "PUSH30" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::PUSH30" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "AND" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::AND" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "SWAP5" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::SWAP5" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "JUMP" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::JUMP" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "GASPRICE" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::GASPRICE" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "PUSH23" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::PUSH23" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "SWAP12" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::SWAP12" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "PUSH31" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::PUSH31" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "BYTE" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::BYTE" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "ADD" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::ADD" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "SWAPN" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::SWAPN" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "DUP9" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::DUP9" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "EQ" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::EQ" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "MSTORE" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::MSTORE" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "DIFFICULTY" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::DIFFICULTY" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "SWAP15" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::SWAP15" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "SSTORE" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::SSTORE" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "STOP" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::STOP" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "ADDRESS" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::ADDRESS" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "RETURNDATASIZE" |) |)
                                  |);
                                  M.read (|
                                    M.get_constant "revm_bytecode::opcode::RETURNDATASIZE"
                                  |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "TLOAD" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::TLOAD" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "ADDMOD" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::ADDMOD" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "DATALOAD" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::DATALOAD" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "JUMPI" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::JUMPI" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "DUP11" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::DUP11" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "SMOD" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::SMOD" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "PUSH15" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::PUSH15" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "GAS" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::GAS" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "PUSH28" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::PUSH28" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "PUSH26" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::PUSH26" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "BASEFEE" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::BASEFEE" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "SWAP2" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::SWAP2" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "PUSH12" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::PUSH12" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "PUSH16" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::PUSH16" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "PUSH6" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::PUSH6" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "INVALID" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::INVALID" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "SWAP3" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::SWAP3" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "PUSH19" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::PUSH19" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "LOG4" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::LOG4" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "DUP7" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::DUP7" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "SWAP4" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::SWAP4" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "SWAP13" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::SWAP13" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "SLT" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::SLT" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "PUSH4" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::PUSH4" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "SDIV" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::SDIV" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "SAR" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::SAR" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "DATALOADN" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::DATALOADN" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "PUSH2" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::PUSH2" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "PUSH20" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::PUSH20" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "EOFCREATE" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::EOFCREATE" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "BLOBHASH" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::BLOBHASH" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "ISZERO" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::ISZERO" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "DUP3" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::DUP3" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "CHAINID" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::CHAINID" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "PUSH24" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::PUSH24" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "MUL" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::MUL" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "PC" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::PC" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "RJUMPI" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::RJUMPI" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "EXTCODECOPY" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::EXTCODECOPY" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "PUSH5" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::PUSH5" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "EXTDELEGATECALL" |) |)
                                  |);
                                  M.read (|
                                    M.get_constant "revm_bytecode::opcode::EXTDELEGATECALL"
                                  |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "DUP15" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::DUP15" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "PUSH25" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::PUSH25" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "CALLF" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::CALLF" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "SELFDESTRUCT" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::SELFDESTRUCT" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "LOG0" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::LOG0" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "PUSH32" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::PUSH32" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "PUSH8" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::PUSH8" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "OR" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::OR" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "SHR" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::SHR" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "DUP12" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::DUP12" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "SWAP7" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::SWAP7" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "CALLER" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::CALLER" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "DUP13" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::DUP13" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "TSTORE" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::TSTORE" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "MCOPY" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::MCOPY" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "EXTCODEHASH" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::EXTCODEHASH" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "MLOAD" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::MLOAD" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "LOG2" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::LOG2" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "JUMPDEST" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::JUMPDEST" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "DUP6" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::DUP6" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "PUSH14" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::PUSH14" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "EXTCODESIZE" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::EXTCODESIZE" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "EXTSTATICCALL" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::EXTSTATICCALL" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "STATICCALL" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::STATICCALL" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "SGT" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::SGT" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "DUP16" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::DUP16" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "BALANCE" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::BALANCE" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "POP" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::POP" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "DELEGATECALL" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::DELEGATECALL" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "PUSH0" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::PUSH0" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "CALL" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::CALL" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "CREATE" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::CREATE" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "RJUMP" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::RJUMP" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "SWAP14" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::SWAP14" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "MSIZE" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::MSIZE" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "RETF" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::RETF" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "PUSH27" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::PUSH27" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "TIMESTAMP" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::TIMESTAMP" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "NOT" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::NOT" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "MOD" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::MOD" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "DUP8" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::DUP8" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "DATASIZE" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::DATASIZE" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "PUSH18" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::PUSH18" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "DUP5" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::DUP5" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "SWAP10" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::SWAP10" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "SHL" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::SHL" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "DIV" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::DIV" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "PUSH10" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::PUSH10" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "DUP14" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::DUP14" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "SELFBALANCE" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::SELFBALANCE" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "PUSH22" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::PUSH22" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "RETURNDATALOAD" |) |)
                                  |);
                                  M.read (|
                                    M.get_constant "revm_bytecode::opcode::RETURNDATALOAD"
                                  |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "NUMBER" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::NUMBER" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "SIGNEXTEND" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::SIGNEXTEND" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "CALLCODE" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::CALLCODE" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "SUB" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::SUB" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "LT" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::LT" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "RETURNDATACOPY" |) |)
                                  |);
                                  M.read (|
                                    M.get_constant "revm_bytecode::opcode::RETURNDATACOPY"
                                  |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "BLOCKHASH" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::BLOCKHASH" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "CODESIZE" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::CODESIZE" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "CALLDATASIZE" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::CALLDATASIZE" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "LOG1" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::LOG1" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "DUP10" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::DUP10" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "EXTCALL" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::EXTCALL" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "JUMPF" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::JUMPF" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "PUSH9" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::PUSH9" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "DUP4" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::DUP4" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "CALLDATALOAD" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::CALLDATALOAD" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "PUSH3" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::PUSH3" |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| Value.String "PUSH17" |) |)
                                  |);
                                  M.read (| M.get_constant "revm_bytecode::opcode::PUSH17" |)
                                ]
                            ]
                        |)
                      |)
                    |)
                  |))
              ]
          |)
        |))).
  
  Axiom Constant_value_NAME_TO_OPCODE :
    (M.get_constant "revm_bytecode::opcode::NAME_TO_OPCODE") = value_NAME_TO_OPCODE.
  Global Hint Rewrite Constant_value_NAME_TO_OPCODE : constant_rewrites.
End opcode.
