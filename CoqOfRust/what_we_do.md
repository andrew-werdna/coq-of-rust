# What We Do

In this file we document how we specify and formally verify programs, following our flow. The idea is to later help LLM agents to do the same.

## Task: Unblocking the `progress` lemma for the cast cases, by adding an additional hypothesis

We are in the file move_sui/proofs/move_bytecode_verifier/type_safety.v The lemma `progress` is about verifying the type-checker of the Sui language, showing that for each instruction if we start from a state of a certain type, the new state generated by the interpreter is of the type generated by the type-checker. For error cases, if the type-checker succeeds then the interpreter also, except in a few cases which are explicitly mentioned: if there is a stack overflow or an arithmetic overflow. Indeed, these errors cannot be anticipated by the type-checker. The lemma is stated as follows (by reading its definition):

```coq
Lemma progress
    (ty_args : list _Type.t) (function : loader.Function.t) (resolver : loader.Resolver.t)
    (instruction : Bytecode.t)
    (pc : Z) (locals : Locals.t) (interpreter : Interpreter.t)
    (type_safety_checker : TypeSafetyChecker.t)
    (H_instruction : Bytecode.Valid.t instruction)
    (H_type_safety_checker : TypeSafetyChecker.Valid.t type_safety_checker)
    (H_interpreter : IsInterpreterContextOfType.t locals interpreter type_safety_checker)
    (H_resolver :
      resolver.(loader.Resolver.binary).(loader.BinaryType.compiled) =
      type_safety_checker.(TypeSafetyChecker.module)
    )
    (* This lemma is not true for [Bytecode.Ret] *)
    (H_not_Ret : instruction <> Bytecode.Ret) :
  let state := {|
    State.pc := pc;
    State.locals := locals;
    State.interpreter := interpreter;
  |} in
  match
    verify_instr instruction pc type_safety_checker,
    execute_instruction ty_args function resolver instruction state
  with
  | Panic.Value (Result.Ok _, type_safety_checker'),
    Panic.Value (Result.Ok _, state') =>
    let '{|
      State.pc := _;
      State.locals := locals';
      State.interpreter := interpreter';
    |} := state' in
    IsInterpreterContextOfType.t locals' interpreter' type_safety_checker'
  (* If the type-checker succeeds, then the interpreter cannot return an error *)
  | Panic.Value (Result.Ok _, _), Panic.Panic _ => False
  | Panic.Value (Result.Ok _, _), Panic.Value (Result.Err error, _) =>
    let '{| PartialVMError.major_status := major_status |} := error in
    match major_status with
    | StatusCode.EXECUTION_STACK_OVERFLOW
    | StatusCode.ARITHMETIC_ERROR => True
    | _ => False
    end
  | Panic.Panic _, _ | Panic.Value (Result.Err _, _), _ => True
  end.
```

We have to show:

```
List.Forall2 IsValueImplOfType.t (ValueImpl.U8 z :: x0) (AbstractStack.flatten t)
```

On the left we have a stack of values, on the right a stack of types. On the left there is one element followed by the rest of the stack (`::`) and on the right any stack. We need both to be on the same form to reason with `List.Forall2`.

We rewrite `t` with something more precise using a hypothesis in the context:

```
H_post3: AbstractStack.flatten t = SignatureToken.U8 :: AbstractStack.flatten stack_ty0
```

To avoid having to name this hypothesis with a generated name, we do:

```
match goal with
| H : _ = _ |- _ =>
  rewrite H; clear H
end.
```

We get the goal:

```
List.Forall2 IsValueImplOfType.t (ValueImpl.U8 z :: x0) (SignatureToken.U8 :: AbstractStack.flatten stack_ty0)
```

By applying the `constructor` tactic we get to sub goals for each part of the list:

```
IsValueImplOfType.t (ValueImpl.U8 z) SignatureToken.U8
```
and
```
List.Forall2 IsValueImplOfType.t x0 (AbstractStack.flatten stack_ty0)
```

We enter in the first one with a curly brace. Tactic `best` does not work. We unfold the definition of the predicate with:

```
unfold IsValueImplOfType.t.
```

It says:

```
Integer.Valid.t IntegerKind.U8 z
```

meaning we need to show that `z` is in the bounds of a U8 integer. We do not think this is expected, as checking that a value has a certain type should not require checking the integer bounds. It should be enough to say that we have:

```
IsValueImplOfType.t (ValueImpl.U8 z) SignatureToken.U8
```

given that we have a value starting by `ValueImpl.U8`. We go to our definition of `IsValueImplOfType.t` that we find by `Locate IsValueImplOfType.t`:

```
Module IsValueImplOfType.
  Definition t (value : ValueImpl.t) (typ : SignatureToken.t) : Prop :=
    match value, typ with
    | ValueImpl.Invalid, _ => False
    | ValueImpl.U8 z, SignatureToken.U8 => Integer.Valid.t IntegerKind.U8 z
    | ValueImpl.U16 z, SignatureToken.U16 => Integer.Valid.t IntegerKind.U16 z
    | ValueImpl.U32 z, SignatureToken.U32 => Integer.Valid.t IntegerKind.U32 z
    | ValueImpl.U64 z, SignatureToken.U64 => Integer.Valid.t IntegerKind.U64 z
    | ValueImpl.U128 z, SignatureToken.U128 => Integer.Valid.t IntegerKind.U128 z
    | ValueImpl.U256 z, SignatureToken.U256 => 0 <= z < 2^256
    | ValueImpl.Bool _, SignatureToken.Bool => True
    | ValueImpl.Address _, SignatureToken.Address => True
    (* TODO: other cases *)
    | _, _ => False
    end.
End IsValueImplOfType.
```

We remove the bounds on integers:

```
Module IsValueImplOfType.
  Definition t (value : ValueImpl.t) (typ : SignatureToken.t) : Prop :=
    match value, typ with
    | ValueImpl.Invalid, _ => False
    | ValueImpl.U8 z, SignatureToken.U8 => True
    | ValueImpl.U16 z, SignatureToken.U16 => True
    | ValueImpl.U32 z, SignatureToken.U32 => True
    | ValueImpl.U64 z, SignatureToken.U64 => True
    | ValueImpl.U128 z, SignatureToken.U128 => True
    | ValueImpl.U256 z, SignatureToken.U256 => True
    | ValueImpl.Bool _, SignatureToken.Bool => True
    | ValueImpl.Address _, SignatureToken.Address => True
    (* TODO: other cases *)
    | _, _ => False
    end.
End IsValueImplOfType.
```

We check that it compiles. We re-compile the project with `make` as this is a dependency of the file we are working on.

Now a previous case is failing:

```
hauto l: on.
```

with:

```
Error: hauto failed
```

As this is a tactic generated by `best`, we try to use `best` again. It works! We continue and arrive at our current goal. Out of curiosity, we try `best` again. It works! The idea is that since we made weaker the definition of what we want to prove, maybe we can now solve it automatically.

We have six cases which are solved by `best`:

```
{ best. }
{ best. }
{ best. }
{ best. }
{ best. }
{ best. }
```

We replace it by `; best` after the block of previous tactics:

```
step; cbn; (try easy); (try now destruct operand_ty);
  repeat (step; cbn; try easy);
  constructor; cbn; try assumption;
  best.
```

It works! By running `make` again we get that we can replace the `best` by `

So now we have done the `Bytecode.CastU8` case.

## Continuing with the next instructions

There are a lot of other cast instructions, such as `Bytecode.CastU16`. Before checking if what we have done for `Bytecode.CastU8` works for the other cases, we re-compile the project with `make`. It works, including proofs for the other casts that were already there and correct! We wonder why we had the bug then.

We commit and go to the next `admit` in the proof.

## Next admit: the CopyLoc instruction

The next `admit` is for the instruction `Bytecode.CopyLoc`. The goal is:

```
False
```

This means that either we made something wrong, or that we must show a contradiction in the hypothesis.

Something we can do is as follows: understanding how we arrived into such a `False` branch. Going back to the previous tactic, we see:

```
destruct local eqn:H_local_eq; cbn.
```

This is because in the goal we have:

```
match local with
| ValueImpl.Invalid => Result.Err (PartialVMError.new StatusCode.UNKNOWN_INVARIANT_VIOLATION_ERROR)
| _ => Impl_ValueImpl.copy_value local
end
```

An issue with this `match` is that it hides more cases than it seems. When we destruct `local`, we get one case per constructor of the `ValueImpl.t` type, instead of just two.

Here the code we are verifying is written by us as it is a simulation of the original one. Let us change it !

We first need to find this `match` in the code. The code that is pretty-printed in the goal is not necessarily written as it is in the source. We still try a text search on the pattern:

```
| ValueImpl.Invalid =>
```

The results are not convincing. We try instead to search for:

```
UNKNOWN_INVARIANT_VIOLATION_ERROR
```

Too many results! Instead we think about how we came there. The first computations are about typing. If we go to the definition of the type-checker for the `CopyLoc` instruction we look for the function `verify_instr` and do not see anything convincing. We look at the interpreter instead:

```
let local := Impl_Locals.copy_loc state.(State.locals) idx in
```

In `copy_loc` we have:

```
Definition copy_loc (self : Self) (idx : Z) : PartialVMResult.t Value.t :=
  match List.nth_error self (Z.to_nat idx) with
  | Some ValueImpl.Invalid =>
    Result.Err $ PartialVMError.new StatusCode.UNKNOWN_INVARIANT_VIOLATION_ERROR
  | Some v => Impl_ValueImpl.copy_value v
  | None => Result.Err $ PartialVMError.new StatusCode.VERIFIER_INVARIANT_VIOLATION
  end.
```

This is what we are looking for! Let us rewrite it with less cases, using an equality check with an `if`:

```
Definition copy_loc (self : Self) (idx : Z) : PartialVMResult.t Value.t :=
  match List.nth_error self (Z.to_nat idx) with
  | Some value =>
    let is_invalid :=
      match value with
      | ValueImpl.Invalid => true
      | _ => false
      end in
    if is_invalid then
      Result.Err $ PartialVMError.new StatusCode.UNKNOWN_INVARIANT_VIOLATION_ERROR
    else
      Impl_ValueImpl.copy_value value
  | None => Result.Err $ PartialVMError.new StatusCode.VERIFIER_INVARIANT_VIOLATION
  end.
```

This seems silly but now we will be able to destruct on a boolean instead of on the `ValueImpl.t` type. We re-compile the project with `make`.

Going back to our previous point in the proof, just before the destruct of `local`, we replace it by:

```
match goal with
| |- context[if ?is_local_expr then _ else _] =>
  set (is_local := is_local_expr)
end.
destruct is_local; cbn.
```

We name the boolean condition with a `set` tactic to be explicit, and destruct it. We now have two sub goals instead of many similar one for the `_` pattern!

The first sub goal is still `False`. Something special in the hypothesis that we see is:

```
H_nth_error:
  match List.nth_error locals_ty (Z.to_nat z) with
  | Some x2 => IsValueImplOfType.t local x2
  | None => False
  end
```

Can it be true? In some sense, if `local` is the invalid value, it cannot have a type. So both the case `Some` and `None` are impossible. Is it really what we want that an invalid value has no type? Let us assume that as this sounds reasonable. If this is not actually the case, we will be stuck in the proof later, if the interpreter can produce invalid values.

Let us prove a lemma about that, to say that an invalid value cannot have a type. We put it just after the definition of `IsValueImplOfType.t`:

```
Lemma invalid_has_no_type typ :
  ~ IsValueImplOfType.t ValueImpl.Invalid typ.
```

Note that we use `typ` as a direct parameter for the `Lemma` instead of a `forall` quantifier. This is our convention, to make the code shorter.

We go into this lemma. The proof we be by case, for each possible `typ`. We start with:

```
destruct typ; cbn; try easy.
```

It works! We simplify with `now destruct typ` which is the equivalent of `destruct typ; easy`. We re-compile the project with `make`. We are back to our goal.

We forgot to add that in the `False` case the condition `is_invalid` is true. We add it with:

```
destruct is_invalid eqn:H_is_invalid_eq; cbn.
```

We always name the equality hypothesis that was as a convention. Now we destruct the `local` variable again, generating many sub goals, but with a simpler resolution:

```
destruct local eqn:H_local_eq.
```

No `cbn` as there is nothing to reduce in the goal. We need to eliminate easily the cases where `local` is not invalid. We do:

```
destruct local eqn:H_local_eq; try easy.
```

Now we have:

```
match List.nth_error locals_ty (Z.to_nat z) with
| Some x2 => IsValueImplOfType.t ValueImpl.Invalid x2
| None => False
end
```

We reason by cases on the `nth_error`:

```
destruct List.nth_error in H_nth_error; try easy.
```

We reaslize that all the cases succeed! This means we do not need the lemma we proved about invalid values not having a type. We still keep the lemma as it is still an important property to state explicitly.

We replace the destruct by:

```
now destruct List.nth_error in H_nth_error.
```

Solved! We go to the next goal. It starts with:

```
match Impl_ValueImpl.copy_value local with
```

We go to the definition of `copy_value`: it is a complex mutually recursive definition! Maybe we can define a lemma about it. We go to the definition of `copy_value`:

```
Fixpoint copy_value (self : Self) : PartialVMResult.t Self :=
  match self with
  | ValueImpl.Invalid => Result.Ok ValueImpl.Invalid
  | ValueImpl.U8 x => Result.Ok $ ValueImpl.U8 x
  | ValueImpl.U16 x => Result.Ok $ ValueImpl.U16 x
  | ValueImpl.U32 x => Result.Ok $ ValueImpl.U32 x
  | ValueImpl.U64 x => Result.Ok $ ValueImpl.U64 x
  | ValueImpl.U128 x => Result.Ok $ ValueImpl.U128 x
  | ValueImpl.U256 x => Result.Ok $ ValueImpl.U256 x
  | ValueImpl.Bool x => Result.Ok $ ValueImpl.Bool x
  | ValueImpl.Address x => Result.Ok $ ValueImpl.Address x
  | ValueImpl.ContainerRef r =>
    Result.Ok $ ValueImpl.ContainerRef (Impl_ContainerRef.copy_value r)
  | ValueImpl.IndexedRef r =>
    Result.Ok $ ValueImpl.IndexedRef (Impl_IndexedRef.copy_value r)
  | ValueImpl.Container c =>
    let? copy_value := 'Container_copy_value c in
    Result.Ok $ ValueImpl.Container copy_value
  end

  where "'Container_copy_value" := (fun (self : Container.t) =>
    match self with
    | ContainerSkeleton.Vec vec =>
      let? vec := Result.map copy_value vec in
      Result.Ok $ ContainerSkeleton.Vec vec
    | ContainerSkeleton.Struct f =>
      let? f := Result.map copy_value f in
      Result.Ok $ ContainerSkeleton.Struct f
    | ContainerSkeleton.VecU8 v => Result.Ok $ ContainerSkeleton.VecU8 v
    | ContainerSkeleton.VecU64 v => Result.Ok $ ContainerSkeleton.VecU64 v
    | ContainerSkeleton.VecU128 v => Result.Ok $ ContainerSkeleton.VecU128 v
    | ContainerSkeleton.VecBool v => Result.Ok $ ContainerSkeleton.VecBool v
    | ContainerSkeleton.VecAddress v => Result.Ok $ ContainerSkeleton.VecAddress v
    | ContainerSkeleton.VecU16 v => Result.Ok $ ContainerSkeleton.VecU16 v
    | ContainerSkeleton.VecU32 v => Result.Ok $ ContainerSkeleton.VecU32 v
    | ContainerSkeleton.VecU256 v => Result.Ok $ ContainerSkeleton.VecU256 v
    | ContainerSkeleton.Locals _ =>
      Result.Err $ PartialVMError.new StatusCode.UNKNOWN_INVARIANT_VIOLATION_ERROR
    end
  ).
```

Which property can we prove about this function? We see that this is very often the identity function, except for the `Locals` case. Is that the case that we cannot have a container of locals? We go to the Rust code to investigate a bit. We name the Rocq files as in Rust. We search for the `Container` text and Ctrl-click to its definition:

```
/// A container is a collection of values. It is used to represent data structures like a
/// Move vector or struct.
///
/// There is one general container that can be used to store an array of any values, same
/// type or not, and a few specialized flavors to offer compact memory layout for small
/// primitive types.
///
/// Except when not owned by the VM stack, a container always lives inside an Rc<RefCell<>>,
/// making it possible to be shared by references.
````

We do not see anything in the comments about the `Locals` case. We look instead in the function making an error for locals, namely `copy_value`. We do not see any interesting comments either. So maybe this is because locals cannot contain other locals. Let us add this property!

The locals are the set of local variables for the current function. There are disjoint from the values on the stack. So we need a predicate specifically for them. We add it is a `ValueImpl` module in a proof file with the same name as where `ValueImpl` is defined. The name of the file is move_sui/proofs/move_vm_types/values/values_impl.v We make a definition in a module:

```
Module ValueImpl.
  Module IsWithoutLocals.
    
  End IsWithoutLocals.
End ValueImpl.
```

to be namespaced. The definition of `ValueImpl.t` is a complex mutually recursive definition. We get inspiration from the definition of the `copy_value` function, as this is the one we will specify anyways. We start by its definition and add a resulting property for each of the branches:

```
Reserved Notation "'Container_t".

Fixpoint t (self : ValueImpl.t) : Prop :=
  match self with
  | ValueImpl.Invalid => True
  | ValueImpl.U8 _ => True
  | ValueImpl.U16 _ => True
  | ValueImpl.U32 _ => True
  | ValueImpl.U64 _ => True
  | ValueImpl.U128 _ => True
  | ValueImpl.U256 _ => True
  | ValueImpl.Bool _ => True
  | ValueImpl.Address _ => True
  | ValueImpl.ContainerRef r => ContainerRef.IsWithoutLocals.t r
  | ValueImpl.IndexedRef r => IndexedRef.IsWithoutLocals.t r
  | ValueImpl.Container c => 'Container_t c
  end

  where "'Container_t" := (fun (self : Container.t) =>
    match self with
    | ContainerSkeleton.Vec vec => List.Forall t vec
    | ContainerSkeleton.Struct f => List.Forall t f
    | ContainerSkeleton.VecU8 _ => True
    | ContainerSkeleton.VecU64 _ => True
    | ContainerSkeleton.VecU128 _ => True
    | ContainerSkeleton.VecBool _ => True
    | ContainerSkeleton.VecAddress _ => True
    | ContainerSkeleton.VecU16 _ => True
    | ContainerSkeleton.VecU32 _ => True
    | ContainerSkeleton.VecU256 _ => True
    | ContainerSkeleton.Locals _ => False
    end
  ).
```

It does not work!

```
Error: Recursive definition of t is ill-formed.
In environment
t : ValueImpl.t -> Prop
self : ValueImpl.t
c : ContainerSkeleton.t ValueImpl.t
self0 := c : Container.t
f : list ValueImpl.t
Recursive call to t has not enough arguments.
```

This might be due to the `List.Forall` that is an inductive rather than a function. By commenting the corresponding cases it works! We need to design a new definition, using an inductive instead.

Our direct attempt at using an Inductive results in an error "impossible: strictly positive occurrence of t".

Instead, the solution that works is to follow the inductives defining the type. We get the following definition:

```
Module ContainerSkeleton.
  Module IsWithoutLocals.
    Inductive t {ValueImpl : Set} (P : ValueImpl -> Prop) : ContainerSkeleton.t ValueImpl -> Prop :=
    | Vec vec : List.Forall P vec -> t P (ContainerSkeleton.Vec vec)
    | Struct f : List.Forall P f -> t P (ContainerSkeleton.Struct f)
    | VecU8 vec : t P (ContainerSkeleton.VecU8 vec)
    | VecU64 vec : t P (ContainerSkeleton.VecU64 vec)
    | VecU128 vec : t P (ContainerSkeleton.VecU128 vec)
    | VecBool vec : t P (ContainerSkeleton.VecBool vec)
    | VecAddress vec : t P (ContainerSkeleton.VecAddress vec)
    | VecU16 vec : t P (ContainerSkeleton.VecU16 vec)
    | VecU32 vec : t P (ContainerSkeleton.VecU32 vec)
    | VecU256 vec : t P (ContainerSkeleton.VecU256 vec).
  End IsWithoutLocals.
End ContainerSkeleton.

Module ValueImpl.
  Module IsWithoutLocals.
    Inductive t : ValueImpl.t -> Prop :=
    | Invalid : t ValueImpl.Invalid
    | U8 z : t (ValueImpl.U8 z)
    | U16 z : t (ValueImpl.U16 z)
    | U32 z : t (ValueImpl.U32 z)
    | U64 z : t (ValueImpl.U64 z)
    | U128 z : t (ValueImpl.U128 z)
    | U256 z : t (ValueImpl.U256 z)
    | Bool b : t (ValueImpl.Bool b)
    | Address a : t (ValueImpl.Address a)
    | ContainerRef r : t (ValueImpl.ContainerRef r)
    | IndexedRef r : t (ValueImpl.IndexedRef r)
    | Container c : ContainerSkeleton.IsWithoutLocals.t t c -> t (ValueImpl.Container c).
  End IsWithoutLocals.
End ValueImpl.
```

which type-checks. We will now show that it implies that the function `copy_value` succeeds. We state this lemma where this function is defined, namely in:

move_sui/proofs/move_vm_types/values/values_impl.v

```
Fixpoint check_copy_value (self : ValueImpl.t)
    (H_self : IsWithoutLocals.t self) :
  match Impl_ValueImpl.copy_value self with
  | Result.Ok _ => True
  | Result.Err _ => False
  end.
```

We do a fixpoint to follow the definition of the function. Then we reason by cases:

```
destruct self; cbn; try easy.
```

One case is left for the Container case:

```
match
  (let? copy_value
   := match t with
      | ContainerSkeleton.Locals _ =>
          Result.Err (PartialVMError.new StatusCode.UNKNOWN_INVARIANT_VIOLATION_ERROR)
      | ContainerSkeleton.Vec vec =>
          let? vec0 := Result.map Impl_ValueImpl.copy_value vec in Result.Ok (ContainerSkeleton.Vec vec0)
      | ContainerSkeleton.Struct f =>
          let? f0 := Result.map Impl_ValueImpl.copy_value f in Result.Ok (ContainerSkeleton.Struct f0)
      | ContainerSkeleton.VecU8 v => Result.Ok (ContainerSkeleton.VecU8 v)
      | ContainerSkeleton.VecU64 v => Result.Ok (ContainerSkeleton.VecU64 v)
      | ContainerSkeleton.VecU128 v => Result.Ok (ContainerSkeleton.VecU128 v)
      | ContainerSkeleton.VecBool v => Result.Ok (ContainerSkeleton.VecBool v)
      | ContainerSkeleton.VecAddress v => Result.Ok (ContainerSkeleton.VecAddress v)
      | ContainerSkeleton.VecU16 v => Result.Ok (ContainerSkeleton.VecU16 v)
      | ContainerSkeleton.VecU32 v => Result.Ok (ContainerSkeleton.VecU32 v)
      | ContainerSkeleton.VecU256 v => Result.Ok (ContainerSkeleton.VecU256 v)
      end in Result.Ok (ValueImpl.Container copy_value))
with
| Result.Ok _ => True
| Result.Err _ => False
end
```

We do a destruct also with the `step` tactic to automatically find the next value that we match on:

```
step; cbn; try easy.
```

We have a `False` case corresponding to the locals. We need to use our hypothesis H_self that says we cannot have locals. It is:

H_self: IsWithoutLocals.t (ValueImpl.Container (ContainerSkeleton.Locals locals))

Because it is an inductive applied to a constructor, we can use the `inversion` tactic to get the contradiction:

```
inversion H_self; subst; try easy.
```

A better version:

```
{ now inversion_clear H_self. }
```

Next we have two similar goals:

```
match
  (let? copy_value
   := (let? vec0 := Result.map Impl_ValueImpl.copy_value vec in Result.Ok (ContainerSkeleton.Vec vec0))
   in Result.Ok (ValueImpl.Container copy_value))
with
| Result.Ok _ => True
| Result.Err _ => False
end
```

The function Result.map should actually be named Result.List.map to be more explicit: this is the mapping function in the Result monad. We do the renaming!

Now we need to somehow link the effect of this Result.List.map with the List.Forall of the predicate. We will do that by induction, locally, in the current lemma.

We also need to use the:

H_self: IsWithoutLocals.t (ValueImpl.Container (ContainerSkeleton.Vec vec))

hypothesis. As we need it in all the sub goals, we can do the inversion on all cases with:

all: inversion_clear H_self; try easy.

We have:

H: ContainerSkeleton.IsWithoutLocals.t IsWithoutLocals.t
      (ContainerSkeleton.Vec vec)

in the hypothesis with a generated name. We can do an inversion on it without using the hypothesis name, by:

all:
  match goal with
  | H : ContainerSkeleton.IsWithoutLocals.t _ _ |- _ => inversion_clear H
  end.

We will focus on the first sub-goal. Both are very similar. We can actually assert that:

assert (
  forall vec,
  List.Forall IsWithoutLocals.t vec ->
  match Result.List.map Impl_ValueImpl.copy_value vec with
  | Result.Ok _ => True
  | Result.Err _ => False
  end
).

We do it at the beginning of the proof to avoid name collisions. We start with:

induction vec; cbn; intros.
admit.

We admit the first case as it is generally easy. For the second case best does not work. We have in the goal:

match
  List.fold_left
    (fun (acc : Result.t (list Impl_ValueImpl.Self) errors.PartialVMError.t) (x : Impl_ValueImpl.Self) =>
     let? acc0 := acc in let? y := Impl_ValueImpl.copy_value x in return? (y :: acc0)) vec
    (let? y := Impl_ValueImpl.copy_value a in return? [y])
with
| Result.Ok _ => True
| Result.Err _ => False
end

We see a List.fold_left instead of a Result.List.map. This makes it harder to use the induction hypothesis. We rewrite our Result.List.map function to use itself instead:

Fixpoint map {A B Error : Set} (f : A -> t B Error) (l : list A) : t (list B) Error :=
  match l with
  | [] => return_ []
  | x :: l =>
    bind (f x) (fun y => bind (map f l) (fun ys => return_ (y :: ys)))
  end.

Now back to the proof:

```
inversion H; subst; try easy.
```
