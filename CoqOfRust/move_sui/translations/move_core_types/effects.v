(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module effects.
  (*
  Enum Op
  {
    const_params := [];
    ty_params := [ "T" ];
    variants :=
      [
        {
          name := "New";
          item := StructTuple [ T ];
          discriminant := None;
        };
        {
          name := "Modify";
          item := StructTuple [ T ];
          discriminant := None;
        };
        {
          name := "Delete";
          item := StructTuple [];
          discriminant := None;
        }
      ];
  }
  *)
  
  Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_move_core_types_effects_Op_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "move_core_types::effects::Op") [] [ T ].
    
    (* Debug *)
    Definition fmt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_core_types::effects::Op::New",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| Value.String "New" |);
                          (* Unsize *) M.pointer_coercion __self_0
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_core_types::effects::Op::Modify",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| Value.String "Modify" |);
                          (* Unsize *) M.pointer_coercion __self_0
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ := M.is_struct_tuple (| γ, "move_core_types::effects::Op::Delete" |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "Delete" |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
  End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_move_core_types_effects_Op_T.
  
  Module Impl_core_clone_Clone_where_core_clone_Clone_T_for_move_core_types_effects_Op_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "move_core_types::effects::Op") [] [ T ].
    
    (* Clone *)
    Definition clone (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_core_types::effects::Op::New",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_core_types::effects::Op::New"
                        [
                          M.call_closure (|
                            M.get_trait_method (| "core::clone::Clone", T, [], "clone", [] |),
                            [ M.read (| __self_0 |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_core_types::effects::Op::Modify",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_core_types::effects::Op::Modify"
                        [
                          M.call_closure (|
                            M.get_trait_method (| "core::clone::Clone", T, [], "clone", [] |),
                            [ M.read (| __self_0 |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ := M.is_struct_tuple (| γ, "move_core_types::effects::Op::Delete" |) in
                    M.alloc (| Value.StructTuple "move_core_types::effects::Op::Delete" [] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method (clone T)) ].
  End Impl_core_clone_Clone_where_core_clone_Clone_T_for_move_core_types_effects_Op_T.
  
  Module Impl_core_marker_StructuralEq_for_move_core_types_effects_Op_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "move_core_types::effects::Op") [] [ T ].
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::marker::StructuralEq"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralEq_for_move_core_types_effects_Op_T.
  
  Module Impl_core_cmp_Eq_where_core_cmp_Eq_T_for_move_core_types_effects_Op_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "move_core_types::effects::Op") [] [ T ].
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
            |)
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::cmp::Eq"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method (assert_receiver_is_total_eq T)) ].
  End Impl_core_cmp_Eq_where_core_cmp_Eq_T_for_move_core_types_effects_Op_T.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_core_types_effects_Op_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "move_core_types::effects::Op") [] [ T ].
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_core_types_effects_Op_T.
  
  Module Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_T_for_move_core_types_effects_Op_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "move_core_types::effects::Op") [] [ T ].
    
    (* PartialEq *)
    Definition eq (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let~ __self_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.apply (Ty.path "move_core_types::effects::Op") [] [ T ] ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let~ __arg1_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.apply (Ty.path "move_core_types::effects::Op") [] [ T ] ]
                  |),
                  [ M.read (| other |) ]
                |)
              |) in
            M.alloc (|
              LogicalOp.and (|
                BinOp.Pure.eq (M.read (| __self_tag |)) (M.read (| __arg1_tag |)),
                ltac:(M.monadic
                  (M.read (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [ M.read (| self |); M.read (| other |) ] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_core_types::effects::Op::New",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_core_types::effects::Op::New",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (| "core::cmp::PartialEq", T, [ T ], "eq", [] |),
                                [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_core_types::effects::Op::Modify",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_core_types::effects::Op::Modify",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (| "core::cmp::PartialEq", T, [ T ], "eq", [] |),
                                [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |)))
                      ]
                    |)
                  |)))
              |)
            |)
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method (eq T)) ].
  End Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_T_for_move_core_types_effects_Op_T.
  
  Module Impl_core_cmp_Ord_where_core_cmp_Ord_T_for_move_core_types_effects_Op_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "move_core_types::effects::Op") [] [ T ].
    
    (* Ord *)
    Definition cmp (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let~ __self_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.apply (Ty.path "move_core_types::effects::Op") [] [ T ] ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let~ __arg1_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.apply (Ty.path "move_core_types::effects::Op") [] [ T ] ]
                  |),
                  [ M.read (| other |) ]
                |)
              |) in
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::cmp::Ord", Ty.path "isize", [], "cmp", [] |),
                  [ __self_tag; __arg1_tag ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::cmp::Ordering::Equal" |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [ M.read (| self |); M.read (| other |) ] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_core_types::effects::Op::New",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_core_types::effects::Op::New",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (| "core::cmp::Ord", T, [], "cmp", [] |),
                                [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_core_types::effects::Op::Modify",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_core_types::effects::Op::Modify",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (| "core::cmp::Ord", T, [], "cmp", [] |),
                                [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (| Value.StructTuple "core::cmp::Ordering::Equal" [] |)))
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let cmp := M.copy (| γ |) in
                    cmp))
              ]
            |)
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::cmp::Ord"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("cmp", InstanceField.Method (cmp T)) ].
  End Impl_core_cmp_Ord_where_core_cmp_Ord_T_for_move_core_types_effects_Op_T.
  
  Module Impl_core_cmp_PartialOrd_where_core_cmp_PartialOrd_T_for_move_core_types_effects_Op_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "move_core_types::effects::Op") [] [ T ].
    
    (* PartialOrd *)
    Definition partial_cmp (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let~ __self_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.apply (Ty.path "move_core_types::effects::Op") [] [ T ] ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let~ __arg1_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.apply (Ty.path "move_core_types::effects::Op") [] [ T ] ]
                  |),
                  [ M.read (| other |) ]
                |)
              |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [ M.read (| self |); M.read (| other |) ] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let γ0_0 := M.read (| γ0_0 |) in
                    let γ2_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ0_0,
                        "move_core_types::effects::Op::New",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ2_0 |) in
                    let γ0_1 := M.read (| γ0_1 |) in
                    let γ2_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ0_1,
                        "move_core_types::effects::Op::New",
                        0
                      |) in
                    let __arg1_0 := M.alloc (| γ2_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::cmp::PartialOrd",
                          T,
                          [ T ],
                          "partial_cmp",
                          []
                        |),
                        [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let γ0_0 := M.read (| γ0_0 |) in
                    let γ2_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ0_0,
                        "move_core_types::effects::Op::Modify",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ2_0 |) in
                    let γ0_1 := M.read (| γ0_1 |) in
                    let γ2_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ0_1,
                        "move_core_types::effects::Op::Modify",
                        0
                      |) in
                    let __arg1_0 := M.alloc (| γ2_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::cmp::PartialOrd",
                          T,
                          [ T ],
                          "partial_cmp",
                          []
                        |),
                        [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::cmp::PartialOrd",
                          Ty.path "isize",
                          [ Ty.path "isize" ],
                          "partial_cmp",
                          []
                        |),
                        [ __self_tag; __arg1_tag ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("partial_cmp", InstanceField.Method (partial_cmp T)) ].
  End Impl_core_cmp_PartialOrd_where_core_cmp_PartialOrd_T_for_move_core_types_effects_Op_T.
  
  Module Impl_move_core_types_effects_Op_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "move_core_types::effects::Op") [] [ T ].
    
    (*
        pub fn as_ref(&self) -> Op<&T> {
            use Op::*;
    
            match self {
                New(data) => New(data),
                Modify(data) => Modify(data),
                Delete => Delete,
            }
        }
    *)
    Definition as_ref (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_core_types::effects::Op::New",
                        0
                      |) in
                    let data := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple "move_core_types::effects::Op::New" [ M.read (| data |) ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_core_types::effects::Op::Modify",
                        0
                      |) in
                    let data := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple "move_core_types::effects::Op::Modify" [ M.read (| data |) ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ := M.is_struct_tuple (| γ, "move_core_types::effects::Op::Delete" |) in
                    M.alloc (| Value.StructTuple "move_core_types::effects::Op::Delete" [] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_as_ref :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "as_ref" (as_ref T).
    
    (*
        pub fn map<F, U>(self, f: F) -> Op<U>
        where
            F: FnOnce(T) -> U,
        {
            use Op::*;
    
            match self {
                New(data) => New(f(data)),
                Modify(data) => Modify(f(data)),
                Delete => Delete,
            }
        }
    *)
    Definition map (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [ F; U ], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_core_types::effects::Op::New",
                        0
                      |) in
                    let data := M.copy (| γ0_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_core_types::effects::Op::New"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::function::FnOnce",
                              F,
                              [ Ty.tuple [ T ] ],
                              "call_once",
                              []
                            |),
                            [ M.read (| f |); Value.Tuple [ M.read (| data |) ] ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_core_types::effects::Op::Modify",
                        0
                      |) in
                    let data := M.copy (| γ0_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_core_types::effects::Op::Modify"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::function::FnOnce",
                              F,
                              [ Ty.tuple [ T ] ],
                              "call_once",
                              []
                            |),
                            [ M.read (| f |); Value.Tuple [ M.read (| data |) ] ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "move_core_types::effects::Op::Delete" |) in
                    M.alloc (| Value.StructTuple "move_core_types::effects::Op::Delete" [] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_map : forall (T : Ty.t), M.IsAssociatedFunction (Self T) "map" (map T).
    
    (*
        pub fn ok(self) -> Option<T> {
            use Op::*;
    
            match self {
                New(data) | Modify(data) => Some(data),
                Delete => None,
            }
        }
    *)
    Definition ok (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.find_or_pattern (|
                      γ,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "move_core_types::effects::Op::New",
                                0
                              |) in
                            let data := M.copy (| γ0_0 |) in
                            Value.Tuple [ data ]));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "move_core_types::effects::Op::Modify",
                                0
                              |) in
                            let data := M.copy (| γ0_0 |) in
                            Value.Tuple [ data ]))
                      ],
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ data ] =>
                              M.alloc (|
                                Value.StructTuple "core::option::Option::Some" [ M.read (| data |) ]
                              |)
                            | _ => M.impossible (||)
                            end))
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "move_core_types::effects::Op::Delete" |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_ok : forall (T : Ty.t), M.IsAssociatedFunction (Self T) "ok" (ok T).
  End Impl_move_core_types_effects_Op_T.
  
  (* StructRecord
    {
      name := "AccountChangeSet";
      const_params := [];
      ty_params := [];
      fields :=
        [
          ("modules",
            Ty.apply
              (Ty.path "alloc::collections::btree::map::BTreeMap")
              []
              [
                Ty.path "move_core_types::identifier::Identifier";
                Ty.apply
                  (Ty.path "move_core_types::effects::Op")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                  ];
                Ty.path "alloc::alloc::Global"
              ]);
          ("resources",
            Ty.apply
              (Ty.path "alloc::collections::btree::map::BTreeMap")
              []
              [
                Ty.path "move_core_types::language_storage::StructTag";
                Ty.apply
                  (Ty.path "move_core_types::effects::Op")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                  ];
                Ty.path "alloc::alloc::Global"
              ])
        ];
    } *)
  
  Module Impl_core_fmt_Debug_for_move_core_types_effects_AccountChangeSet.
    Definition Self : Ty.t := Ty.path "move_core_types::effects::AccountChangeSet".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field2_finish",
              []
            |),
            [
              M.read (| f |);
              M.read (| Value.String "AccountChangeSet" |);
              M.read (| Value.String "modules" |);
              (* Unsize *)
              M.pointer_coercion
                (M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "move_core_types::effects::AccountChangeSet",
                  "modules"
                |));
              M.read (| Value.String "resources" |);
              (* Unsize *)
              M.pointer_coercion
                (M.alloc (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "move_core_types::effects::AccountChangeSet",
                    "resources"
                  |)
                |))
            ]
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_core_types_effects_AccountChangeSet.
  
  Module Impl_core_clone_Clone_for_move_core_types_effects_AccountChangeSet.
    Definition Self : Ty.t := Ty.path "move_core_types::effects::AccountChangeSet".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "move_core_types::effects::AccountChangeSet"
            [
              ("modules",
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply
                      (Ty.path "alloc::collections::btree::map::BTreeMap")
                      []
                      [
                        Ty.path "move_core_types::identifier::Identifier";
                        Ty.apply
                          (Ty.path "move_core_types::effects::Op")
                          []
                          [
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                          ];
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    "clone",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "move_core_types::effects::AccountChangeSet",
                      "modules"
                    |)
                  ]
                |));
              ("resources",
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply
                      (Ty.path "alloc::collections::btree::map::BTreeMap")
                      []
                      [
                        Ty.path "move_core_types::language_storage::StructTag";
                        Ty.apply
                          (Ty.path "move_core_types::effects::Op")
                          []
                          [
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                          ];
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    "clone",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "move_core_types::effects::AccountChangeSet",
                      "resources"
                    |)
                  ]
                |))
            ]))
      | _, _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_core_types_effects_AccountChangeSet.
  
  Module Impl_core_marker_StructuralEq_for_move_core_types_effects_AccountChangeSet.
    Definition Self : Ty.t := Ty.path "move_core_types::effects::AccountChangeSet".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralEq_for_move_core_types_effects_AccountChangeSet.
  
  Module Impl_core_cmp_Eq_for_move_core_types_effects_AccountChangeSet.
    Definition Self : Ty.t := Ty.path "move_core_types::effects::AccountChangeSet".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Value.DeclaredButUndefined,
                      [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_core_types_effects_AccountChangeSet.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_core_types_effects_AccountChangeSet.
    Definition Self : Ty.t := Ty.path "move_core_types::effects::AccountChangeSet".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_core_types_effects_AccountChangeSet.
  
  Module Impl_core_cmp_PartialEq_for_move_core_types_effects_AccountChangeSet.
    Definition Self : Ty.t := Ty.path "move_core_types::effects::AccountChangeSet".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          LogicalOp.and (|
            M.call_closure (|
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply
                  (Ty.path "alloc::collections::btree::map::BTreeMap")
                  []
                  [
                    Ty.path "move_core_types::identifier::Identifier";
                    Ty.apply
                      (Ty.path "move_core_types::effects::Op")
                      []
                      [
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                      ];
                    Ty.path "alloc::alloc::Global"
                  ],
                [
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::BTreeMap")
                    []
                    [
                      Ty.path "move_core_types::identifier::Identifier";
                      Ty.apply
                        (Ty.path "move_core_types::effects::Op")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                        ];
                      Ty.path "alloc::alloc::Global"
                    ]
                ],
                "eq",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "move_core_types::effects::AccountChangeSet",
                  "modules"
                |);
                M.SubPointer.get_struct_record_field (|
                  M.read (| other |),
                  "move_core_types::effects::AccountChangeSet",
                  "modules"
                |)
              ]
            |),
            ltac:(M.monadic
              (M.call_closure (|
                M.get_trait_method (|
                  "core::cmp::PartialEq",
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::BTreeMap")
                    []
                    [
                      Ty.path "move_core_types::language_storage::StructTag";
                      Ty.apply
                        (Ty.path "move_core_types::effects::Op")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                        ];
                      Ty.path "alloc::alloc::Global"
                    ],
                  [
                    Ty.apply
                      (Ty.path "alloc::collections::btree::map::BTreeMap")
                      []
                      [
                        Ty.path "move_core_types::language_storage::StructTag";
                        Ty.apply
                          (Ty.path "move_core_types::effects::Op")
                          []
                          [
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                          ];
                        Ty.path "alloc::alloc::Global"
                      ]
                  ],
                  "eq",
                  []
                |),
                [
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "move_core_types::effects::AccountChangeSet",
                    "resources"
                  |);
                  M.SubPointer.get_struct_record_field (|
                    M.read (| other |),
                    "move_core_types::effects::AccountChangeSet",
                    "resources"
                  |)
                ]
              |)))
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_move_core_types_effects_AccountChangeSet.
  
  Module Impl_core_cmp_Ord_for_move_core_types_effects_AccountChangeSet.
    Definition Self : Ty.t := Ty.path "move_core_types::effects::AccountChangeSet".
    
    (* Ord *)
    Definition cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::cmp::Ord",
                    Ty.apply
                      (Ty.path "alloc::collections::btree::map::BTreeMap")
                      []
                      [
                        Ty.path "move_core_types::identifier::Identifier";
                        Ty.apply
                          (Ty.path "move_core_types::effects::Op")
                          []
                          [
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                          ];
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    "cmp",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "move_core_types::effects::AccountChangeSet",
                      "modules"
                    |);
                    M.SubPointer.get_struct_record_field (|
                      M.read (| other |),
                      "move_core_types::effects::AccountChangeSet",
                      "modules"
                    |)
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::cmp::Ordering::Equal" |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::cmp::Ord",
                          Ty.apply
                            (Ty.path "alloc::collections::btree::map::BTreeMap")
                            []
                            [
                              Ty.path "move_core_types::language_storage::StructTag";
                              Ty.apply
                                (Ty.path "move_core_types::effects::Op")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    []
                                    [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                ];
                              Ty.path "alloc::alloc::Global"
                            ],
                          [],
                          "cmp",
                          []
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "move_core_types::effects::AccountChangeSet",
                            "resources"
                          |);
                          M.SubPointer.get_struct_record_field (|
                            M.read (| other |),
                            "move_core_types::effects::AccountChangeSet",
                            "resources"
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let cmp := M.copy (| γ |) in
                    cmp))
              ]
            |)
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Ord"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
  End Impl_core_cmp_Ord_for_move_core_types_effects_AccountChangeSet.
  
  Module Impl_core_cmp_PartialOrd_for_move_core_types_effects_AccountChangeSet.
    Definition Self : Ty.t := Ty.path "move_core_types::effects::AccountChangeSet".
    
    (* PartialOrd *)
    Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::cmp::PartialOrd",
                    Ty.apply
                      (Ty.path "alloc::collections::btree::map::BTreeMap")
                      []
                      [
                        Ty.path "move_core_types::identifier::Identifier";
                        Ty.apply
                          (Ty.path "move_core_types::effects::Op")
                          []
                          [
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                          ];
                        Ty.path "alloc::alloc::Global"
                      ],
                    [
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::BTreeMap")
                        []
                        [
                          Ty.path "move_core_types::identifier::Identifier";
                          Ty.apply
                            (Ty.path "move_core_types::effects::Op")
                            []
                            [
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                            ];
                          Ty.path "alloc::alloc::Global"
                        ]
                    ],
                    "partial_cmp",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "move_core_types::effects::AccountChangeSet",
                      "modules"
                    |);
                    M.SubPointer.get_struct_record_field (|
                      M.read (| other |),
                      "move_core_types::effects::AccountChangeSet",
                      "modules"
                    |)
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let _ := M.is_struct_tuple (| γ0_0, "core::cmp::Ordering::Equal" |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::cmp::PartialOrd",
                          Ty.apply
                            (Ty.path "alloc::collections::btree::map::BTreeMap")
                            []
                            [
                              Ty.path "move_core_types::language_storage::StructTag";
                              Ty.apply
                                (Ty.path "move_core_types::effects::Op")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    []
                                    [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                ];
                              Ty.path "alloc::alloc::Global"
                            ],
                          [
                            Ty.apply
                              (Ty.path "alloc::collections::btree::map::BTreeMap")
                              []
                              [
                                Ty.path "move_core_types::language_storage::StructTag";
                                Ty.apply
                                  (Ty.path "move_core_types::effects::Op")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      []
                                      [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                  ];
                                Ty.path "alloc::alloc::Global"
                              ]
                          ],
                          "partial_cmp",
                          []
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "move_core_types::effects::AccountChangeSet",
                            "resources"
                          |);
                          M.SubPointer.get_struct_record_field (|
                            M.read (| other |),
                            "move_core_types::effects::AccountChangeSet",
                            "resources"
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let cmp := M.copy (| γ |) in
                    cmp))
              ]
            |)
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_for_move_core_types_effects_AccountChangeSet.
  
  (*
  fn squash<K, V>(map: &mut BTreeMap<K, Op<V>>, other: BTreeMap<K, Op<V>>) -> Result<()>
  where
      K: Ord,
  {
      use btree_map::Entry::*;
      use Op::*;
  
      for (key, op) in other.into_iter() {
          match map.entry(key) {
              Occupied(mut entry) => {
                  let r = entry.get_mut();
                  match (r.as_ref(), op) {
                      (Modify(_) | New(_), New(_)) | (Delete, Delete | Modify(_)) => {
                          bail!("The given change sets cannot be squashed")
                      }
                      (Modify(_), Modify(data)) => *r = Modify(data),
                      (New(_), Modify(data)) => *r = New(data),
                      (Modify(_), Delete) => *r = Delete,
                      (Delete, New(data)) => *r = Modify(data),
                      (New(_), Delete) => {
                          entry.remove();
                      }
                  }
              }
              Vacant(entry) => {
                  entry.insert(op);
              }
          }
      }
  
      Ok(())
  }
  *)
  Definition squash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ K; V ], [ map; other ] =>
      ltac:(M.monadic
        (let map := M.alloc (| map |) in
        let other := M.alloc (| other |) in
        M.catch_return (|
          ltac:(M.monadic
            (M.read (|
              let~ _ :=
                M.use
                  (M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::iter::traits::collect::IntoIterator",
                          Ty.apply
                            (Ty.path "alloc::collections::btree::map::IntoIter")
                            []
                            [
                              K;
                              Ty.apply (Ty.path "move_core_types::effects::Op") [] [ V ];
                              Ty.path "alloc::alloc::Global"
                            ],
                          [],
                          "into_iter",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::iter::traits::collect::IntoIterator",
                              Ty.apply
                                (Ty.path "alloc::collections::btree::map::BTreeMap")
                                []
                                [
                                  K;
                                  Ty.apply (Ty.path "move_core_types::effects::Op") [] [ V ];
                                  Ty.path "alloc::alloc::Global"
                                ],
                              [],
                              "into_iter",
                              []
                            |),
                            [ M.read (| other |) ]
                          |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let iter := M.copy (| γ |) in
                          M.loop (|
                            ltac:(M.monadic
                              (let~ _ :=
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::iter::traits::iterator::Iterator",
                                        Ty.apply
                                          (Ty.path "alloc::collections::btree::map::IntoIter")
                                          []
                                          [
                                            K;
                                            Ty.apply
                                              (Ty.path "move_core_types::effects::Op")
                                              []
                                              [ V ];
                                            Ty.path "alloc::alloc::Global"
                                          ],
                                        [],
                                        "next",
                                        []
                                      |),
                                      [ iter ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let _ :=
                                          M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                        M.alloc (|
                                          M.never_to_any (| M.read (| M.break (||) |) |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::option::Option::Some",
                                            0
                                          |) in
                                        let γ1_0 := M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                                        let γ1_1 := M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                                        let key := M.copy (| γ1_0 |) in
                                        let op := M.copy (| γ1_1 |) in
                                        M.match_operator (|
                                          M.alloc (|
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path
                                                    "alloc::collections::btree::map::BTreeMap")
                                                  []
                                                  [
                                                    K;
                                                    Ty.apply
                                                      (Ty.path "move_core_types::effects::Op")
                                                      []
                                                      [ V ];
                                                    Ty.path "alloc::alloc::Global"
                                                  ],
                                                "entry",
                                                []
                                              |),
                                              [ M.read (| map |); M.read (| key |) ]
                                            |)
                                          |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ0_0 :=
                                                  M.SubPointer.get_struct_tuple_field (|
                                                    γ,
                                                    "alloc::collections::btree::map::entry::Entry::Occupied",
                                                    0
                                                  |) in
                                                let entry := M.copy (| γ0_0 |) in
                                                let~ r :=
                                                  M.alloc (|
                                                    M.call_closure (|
                                                      M.get_associated_function (|
                                                        Ty.apply
                                                          (Ty.path
                                                            "alloc::collections::btree::map::entry::OccupiedEntry")
                                                          []
                                                          [
                                                            K;
                                                            Ty.apply
                                                              (Ty.path
                                                                "move_core_types::effects::Op")
                                                              []
                                                              [ V ];
                                                            Ty.path "alloc::alloc::Global"
                                                          ],
                                                        "get_mut",
                                                        []
                                                      |),
                                                      [ entry ]
                                                    |)
                                                  |) in
                                                M.match_operator (|
                                                  M.alloc (|
                                                    Value.Tuple
                                                      [
                                                        M.call_closure (|
                                                          M.get_associated_function (|
                                                            Ty.apply
                                                              (Ty.path
                                                                "move_core_types::effects::Op")
                                                              []
                                                              [ V ],
                                                            "as_ref",
                                                            []
                                                          |),
                                                          [ M.read (| r |) ]
                                                        |);
                                                        M.read (| op |)
                                                      ]
                                                  |),
                                                  [
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (M.find_or_pattern (|
                                                          γ,
                                                          [
                                                            fun γ =>
                                                              ltac:(M.monadic
                                                                (let γ0_0 :=
                                                                  M.SubPointer.get_tuple_field (|
                                                                    γ,
                                                                    0
                                                                  |) in
                                                                let γ0_1 :=
                                                                  M.SubPointer.get_tuple_field (|
                                                                    γ,
                                                                    1
                                                                  |) in
                                                                M.find_or_pattern (|
                                                                  γ0_0,
                                                                  [
                                                                    fun γ =>
                                                                      ltac:(M.monadic
                                                                        (let γ0_0 :=
                                                                          M.SubPointer.get_struct_tuple_field (|
                                                                            γ,
                                                                            "move_core_types::effects::Op::Modify",
                                                                            0
                                                                          |) in
                                                                        Value.Tuple []));
                                                                    fun γ =>
                                                                      ltac:(M.monadic
                                                                        (let γ0_0 :=
                                                                          M.SubPointer.get_struct_tuple_field (|
                                                                            γ,
                                                                            "move_core_types::effects::Op::New",
                                                                            0
                                                                          |) in
                                                                        Value.Tuple []))
                                                                  ],
                                                                  M.closure
                                                                    (fun γ =>
                                                                      ltac:(M.monadic
                                                                        match γ with
                                                                        | [] =>
                                                                          let γ1_0 :=
                                                                            M.SubPointer.get_struct_tuple_field (|
                                                                              γ0_1,
                                                                              "move_core_types::effects::Op::New",
                                                                              0
                                                                            |) in
                                                                          Value.Tuple []
                                                                        | _ => M.impossible (||)
                                                                        end))
                                                                |)));
                                                            fun γ =>
                                                              ltac:(M.monadic
                                                                (let γ0_0 :=
                                                                  M.SubPointer.get_tuple_field (|
                                                                    γ,
                                                                    0
                                                                  |) in
                                                                let γ0_1 :=
                                                                  M.SubPointer.get_tuple_field (|
                                                                    γ,
                                                                    1
                                                                  |) in
                                                                let _ :=
                                                                  M.is_struct_tuple (|
                                                                    γ0_0,
                                                                    "move_core_types::effects::Op::Delete"
                                                                  |) in
                                                                M.find_or_pattern (|
                                                                  γ0_1,
                                                                  [
                                                                    fun γ =>
                                                                      ltac:(M.monadic
                                                                        (let _ :=
                                                                          M.is_struct_tuple (|
                                                                            γ,
                                                                            "move_core_types::effects::Op::Delete"
                                                                          |) in
                                                                        Value.Tuple []));
                                                                    fun γ =>
                                                                      ltac:(M.monadic
                                                                        (let γ0_0 :=
                                                                          M.SubPointer.get_struct_tuple_field (|
                                                                            γ,
                                                                            "move_core_types::effects::Op::Modify",
                                                                            0
                                                                          |) in
                                                                        Value.Tuple []))
                                                                  ],
                                                                  M.closure
                                                                    (fun γ =>
                                                                      ltac:(M.monadic
                                                                        match γ with
                                                                        | [] => Value.Tuple []
                                                                        | _ => M.impossible (||)
                                                                        end))
                                                                |)))
                                                          ],
                                                          M.closure
                                                            (fun γ =>
                                                              ltac:(M.monadic
                                                                match γ with
                                                                | [] =>
                                                                  M.alloc (|
                                                                    M.never_to_any (|
                                                                      M.read (|
                                                                        M.return_ (|
                                                                          Value.StructTuple
                                                                            "core::result::Result::Err"
                                                                            [
                                                                              M.read (|
                                                                                let~ error :=
                                                                                  M.alloc (|
                                                                                    M.call_closure (|
                                                                                      M.get_function (|
                                                                                        "anyhow::__private::format_err",
                                                                                        []
                                                                                      |),
                                                                                      [
                                                                                        M.call_closure (|
                                                                                          M.get_associated_function (|
                                                                                            Ty.path
                                                                                              "core::fmt::Arguments",
                                                                                            "new_const",
                                                                                            []
                                                                                          |),
                                                                                          [
                                                                                            (* Unsize *)
                                                                                            M.pointer_coercion
                                                                                              (M.alloc (|
                                                                                                Value.Array
                                                                                                  [
                                                                                                    M.read (|
                                                                                                      Value.String
                                                                                                        "The given change sets cannot be squashed"
                                                                                                    |)
                                                                                                  ]
                                                                                              |))
                                                                                          ]
                                                                                        |)
                                                                                      ]
                                                                                    |)
                                                                                  |) in
                                                                                error
                                                                              |)
                                                                            ]
                                                                        |)
                                                                      |)
                                                                    |)
                                                                  |)
                                                                | _ => M.impossible (||)
                                                                end))
                                                        |)));
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (let γ0_0 :=
                                                          M.SubPointer.get_tuple_field (| γ, 0 |) in
                                                        let γ0_1 :=
                                                          M.SubPointer.get_tuple_field (| γ, 1 |) in
                                                        let γ1_0 :=
                                                          M.SubPointer.get_struct_tuple_field (|
                                                            γ0_0,
                                                            "move_core_types::effects::Op::Modify",
                                                            0
                                                          |) in
                                                        let γ1_0 :=
                                                          M.SubPointer.get_struct_tuple_field (|
                                                            γ0_1,
                                                            "move_core_types::effects::Op::Modify",
                                                            0
                                                          |) in
                                                        let data := M.copy (| γ1_0 |) in
                                                        M.write (|
                                                          M.read (| r |),
                                                          Value.StructTuple
                                                            "move_core_types::effects::Op::Modify"
                                                            [ M.read (| data |) ]
                                                        |)));
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (let γ0_0 :=
                                                          M.SubPointer.get_tuple_field (| γ, 0 |) in
                                                        let γ0_1 :=
                                                          M.SubPointer.get_tuple_field (| γ, 1 |) in
                                                        let γ1_0 :=
                                                          M.SubPointer.get_struct_tuple_field (|
                                                            γ0_0,
                                                            "move_core_types::effects::Op::New",
                                                            0
                                                          |) in
                                                        let γ1_0 :=
                                                          M.SubPointer.get_struct_tuple_field (|
                                                            γ0_1,
                                                            "move_core_types::effects::Op::Modify",
                                                            0
                                                          |) in
                                                        let data := M.copy (| γ1_0 |) in
                                                        M.write (|
                                                          M.read (| r |),
                                                          Value.StructTuple
                                                            "move_core_types::effects::Op::New"
                                                            [ M.read (| data |) ]
                                                        |)));
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (let γ0_0 :=
                                                          M.SubPointer.get_tuple_field (| γ, 0 |) in
                                                        let γ0_1 :=
                                                          M.SubPointer.get_tuple_field (| γ, 1 |) in
                                                        let γ1_0 :=
                                                          M.SubPointer.get_struct_tuple_field (|
                                                            γ0_0,
                                                            "move_core_types::effects::Op::Modify",
                                                            0
                                                          |) in
                                                        let _ :=
                                                          M.is_struct_tuple (|
                                                            γ0_1,
                                                            "move_core_types::effects::Op::Delete"
                                                          |) in
                                                        M.write (|
                                                          M.read (| r |),
                                                          Value.StructTuple
                                                            "move_core_types::effects::Op::Delete"
                                                            []
                                                        |)));
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (let γ0_0 :=
                                                          M.SubPointer.get_tuple_field (| γ, 0 |) in
                                                        let γ0_1 :=
                                                          M.SubPointer.get_tuple_field (| γ, 1 |) in
                                                        let _ :=
                                                          M.is_struct_tuple (|
                                                            γ0_0,
                                                            "move_core_types::effects::Op::Delete"
                                                          |) in
                                                        let γ1_0 :=
                                                          M.SubPointer.get_struct_tuple_field (|
                                                            γ0_1,
                                                            "move_core_types::effects::Op::New",
                                                            0
                                                          |) in
                                                        let data := M.copy (| γ1_0 |) in
                                                        M.write (|
                                                          M.read (| r |),
                                                          Value.StructTuple
                                                            "move_core_types::effects::Op::Modify"
                                                            [ M.read (| data |) ]
                                                        |)));
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (let γ0_0 :=
                                                          M.SubPointer.get_tuple_field (| γ, 0 |) in
                                                        let γ0_1 :=
                                                          M.SubPointer.get_tuple_field (| γ, 1 |) in
                                                        let γ1_0 :=
                                                          M.SubPointer.get_struct_tuple_field (|
                                                            γ0_0,
                                                            "move_core_types::effects::Op::New",
                                                            0
                                                          |) in
                                                        let _ :=
                                                          M.is_struct_tuple (|
                                                            γ0_1,
                                                            "move_core_types::effects::Op::Delete"
                                                          |) in
                                                        let~ _ :=
                                                          M.alloc (|
                                                            M.call_closure (|
                                                              M.get_associated_function (|
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "alloc::collections::btree::map::entry::OccupiedEntry")
                                                                  []
                                                                  [
                                                                    K;
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "move_core_types::effects::Op")
                                                                      []
                                                                      [ V ];
                                                                    Ty.path "alloc::alloc::Global"
                                                                  ],
                                                                "remove",
                                                                []
                                                              |),
                                                              [ M.read (| entry |) ]
                                                            |)
                                                          |) in
                                                        M.alloc (| Value.Tuple [] |)))
                                                  ]
                                                |)));
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ0_0 :=
                                                  M.SubPointer.get_struct_tuple_field (|
                                                    γ,
                                                    "alloc::collections::btree::map::entry::Entry::Vacant",
                                                    0
                                                  |) in
                                                let entry := M.copy (| γ0_0 |) in
                                                let~ _ :=
                                                  M.alloc (|
                                                    M.call_closure (|
                                                      M.get_associated_function (|
                                                        Ty.apply
                                                          (Ty.path
                                                            "alloc::collections::btree::map::entry::VacantEntry")
                                                          []
                                                          [
                                                            K;
                                                            Ty.apply
                                                              (Ty.path
                                                                "move_core_types::effects::Op")
                                                              []
                                                              [ V ];
                                                            Ty.path "alloc::alloc::Global"
                                                          ],
                                                        "insert",
                                                        []
                                                      |),
                                                      [ M.read (| entry |); M.read (| op |) ]
                                                    |)
                                                  |) in
                                                M.alloc (| Value.Tuple [] |)))
                                          ]
                                        |)))
                                  ]
                                |) in
                              M.alloc (| Value.Tuple [] |)))
                          |)))
                    ]
                  |)) in
              M.alloc (| Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ] |)
            |)))
        |)))
    | _, _, _ => M.impossible
    end.
  
  Axiom Function_squash : M.IsFunction "move_core_types::effects::squash" squash.
  
  Module Impl_move_core_types_effects_AccountChangeSet.
    Definition Self : Ty.t := Ty.path "move_core_types::effects::AccountChangeSet".
    
    (*
        pub fn from_modules_resources(
            modules: BTreeMap<Identifier, Op<Vec<u8>>>,
            resources: BTreeMap<StructTag, Op<Vec<u8>>>,
        ) -> Self {
            Self { modules, resources }
        }
    *)
    Definition from_modules_resources (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ modules; resources ] =>
        ltac:(M.monadic
          (let modules := M.alloc (| modules |) in
          let resources := M.alloc (| resources |) in
          Value.StructRecord
            "move_core_types::effects::AccountChangeSet"
            [ ("modules", M.read (| modules |)); ("resources", M.read (| resources |)) ]))
      | _, _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_modules_resources :
      M.IsAssociatedFunction Self "from_modules_resources" from_modules_resources.
    
    (*
        pub fn new() -> Self {
            Self {
                modules: BTreeMap::new(),
                resources: BTreeMap::new(),
            }
        }
    *)
    Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (Value.StructRecord
            "move_core_types::effects::AccountChangeSet"
            [
              ("modules",
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::collections::btree::map::BTreeMap")
                      []
                      [
                        Ty.path "move_core_types::identifier::Identifier";
                        Ty.apply
                          (Ty.path "move_core_types::effects::Op")
                          []
                          [
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                          ];
                        Ty.path "alloc::alloc::Global"
                      ],
                    "new",
                    []
                  |),
                  []
                |));
              ("resources",
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::collections::btree::map::BTreeMap")
                      []
                      [
                        Ty.path "move_core_types::language_storage::StructTag";
                        Ty.apply
                          (Ty.path "move_core_types::effects::Op")
                          []
                          [
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                          ];
                        Ty.path "alloc::alloc::Global"
                      ],
                    "new",
                    []
                  |),
                  []
                |))
            ]))
      | _, _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
    
    (*
        pub fn add_module_op(&mut self, name: Identifier, op: Op<Vec<u8>>) -> Result<()> {
            use btree_map::Entry::*;
    
            match self.modules.entry(name) {
                Occupied(entry) => bail!("Module {} already exists", entry.key()),
                Vacant(entry) => {
                    entry.insert(op);
                }
            }
    
            Ok(())
        }
    *)
    Definition add_module_op (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; name; op ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let name := M.alloc (| name |) in
          let op := M.alloc (| op |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::collections::btree::map::BTreeMap")
                            []
                            [
                              Ty.path "move_core_types::identifier::Identifier";
                              Ty.apply
                                (Ty.path "move_core_types::effects::Op")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    []
                                    [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                ];
                              Ty.path "alloc::alloc::Global"
                            ],
                          "entry",
                          []
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "move_core_types::effects::AccountChangeSet",
                            "modules"
                          |);
                          M.read (| name |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "alloc::collections::btree::map::entry::Entry::Occupied",
                              0
                            |) in
                          let entry := M.copy (| γ0_0 |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Err"
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "anyhow::Error",
                                          "msg",
                                          [ Ty.path "alloc::string::String" ]
                                        |),
                                        [
                                          M.read (|
                                            let~ res :=
                                              M.alloc (|
                                                M.call_closure (|
                                                  M.get_function (| "alloc::fmt::format", [] |),
                                                  [
                                                    M.call_closure (|
                                                      M.get_associated_function (|
                                                        Ty.path "core::fmt::Arguments",
                                                        "new_v1",
                                                        []
                                                      |),
                                                      [
                                                        (* Unsize *)
                                                        M.pointer_coercion
                                                          (M.alloc (|
                                                            Value.Array
                                                              [
                                                                M.read (| Value.String "Module " |);
                                                                M.read (|
                                                                  Value.String " already exists"
                                                                |)
                                                              ]
                                                          |));
                                                        (* Unsize *)
                                                        M.pointer_coercion
                                                          (M.alloc (|
                                                            Value.Array
                                                              [
                                                                M.call_closure (|
                                                                  M.get_associated_function (|
                                                                    Ty.path
                                                                      "core::fmt::rt::Argument",
                                                                    "new_display",
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path "&")
                                                                        []
                                                                        [
                                                                          Ty.path
                                                                            "move_core_types::identifier::Identifier"
                                                                        ]
                                                                    ]
                                                                  |),
                                                                  [
                                                                    M.alloc (|
                                                                      M.call_closure (|
                                                                        M.get_associated_function (|
                                                                          Ty.apply
                                                                            (Ty.path
                                                                              "alloc::collections::btree::map::entry::OccupiedEntry")
                                                                            []
                                                                            [
                                                                              Ty.path
                                                                                "move_core_types::identifier::Identifier";
                                                                              Ty.apply
                                                                                (Ty.path
                                                                                  "move_core_types::effects::Op")
                                                                                []
                                                                                [
                                                                                  Ty.apply
                                                                                    (Ty.path
                                                                                      "alloc::vec::Vec")
                                                                                    []
                                                                                    [
                                                                                      Ty.path "u8";
                                                                                      Ty.path
                                                                                        "alloc::alloc::Global"
                                                                                    ]
                                                                                ];
                                                                              Ty.path
                                                                                "alloc::alloc::Global"
                                                                            ],
                                                                          "key",
                                                                          []
                                                                        |),
                                                                        [ entry ]
                                                                      |)
                                                                    |)
                                                                  ]
                                                                |)
                                                              ]
                                                          |))
                                                      ]
                                                    |)
                                                  ]
                                                |)
                                              |) in
                                            res
                                          |)
                                        ]
                                      |)
                                    ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "alloc::collections::btree::map::entry::Entry::Vacant",
                              0
                            |) in
                          let entry := M.copy (| γ0_0 |) in
                          let~ _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::collections::btree::map::entry::VacantEntry")
                                    []
                                    [
                                      Ty.path "move_core_types::identifier::Identifier";
                                      Ty.apply
                                        (Ty.path "move_core_types::effects::Op")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            []
                                            [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                        ];
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  "insert",
                                  []
                                |),
                                [ M.read (| entry |); M.read (| op |) ]
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.alloc (| Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ] |)
              |)))
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_add_module_op :
      M.IsAssociatedFunction Self "add_module_op" add_module_op.
    
    (*
        pub fn add_resource_op(&mut self, struct_tag: StructTag, op: Op<Vec<u8>>) -> Result<()> {
            use btree_map::Entry::*;
    
            match self.resources.entry(struct_tag) {
                Occupied(entry) => bail!("Resource {} already exists", entry.key()),
                Vacant(entry) => {
                    entry.insert(op);
                }
            }
    
            Ok(())
        }
    *)
    Definition add_resource_op (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; struct_tag; op ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let struct_tag := M.alloc (| struct_tag |) in
          let op := M.alloc (| op |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::collections::btree::map::BTreeMap")
                            []
                            [
                              Ty.path "move_core_types::language_storage::StructTag";
                              Ty.apply
                                (Ty.path "move_core_types::effects::Op")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    []
                                    [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                ];
                              Ty.path "alloc::alloc::Global"
                            ],
                          "entry",
                          []
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "move_core_types::effects::AccountChangeSet",
                            "resources"
                          |);
                          M.read (| struct_tag |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "alloc::collections::btree::map::entry::Entry::Occupied",
                              0
                            |) in
                          let entry := M.copy (| γ0_0 |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Err"
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "anyhow::Error",
                                          "msg",
                                          [ Ty.path "alloc::string::String" ]
                                        |),
                                        [
                                          M.read (|
                                            let~ res :=
                                              M.alloc (|
                                                M.call_closure (|
                                                  M.get_function (| "alloc::fmt::format", [] |),
                                                  [
                                                    M.call_closure (|
                                                      M.get_associated_function (|
                                                        Ty.path "core::fmt::Arguments",
                                                        "new_v1",
                                                        []
                                                      |),
                                                      [
                                                        (* Unsize *)
                                                        M.pointer_coercion
                                                          (M.alloc (|
                                                            Value.Array
                                                              [
                                                                M.read (|
                                                                  Value.String "Resource "
                                                                |);
                                                                M.read (|
                                                                  Value.String " already exists"
                                                                |)
                                                              ]
                                                          |));
                                                        (* Unsize *)
                                                        M.pointer_coercion
                                                          (M.alloc (|
                                                            Value.Array
                                                              [
                                                                M.call_closure (|
                                                                  M.get_associated_function (|
                                                                    Ty.path
                                                                      "core::fmt::rt::Argument",
                                                                    "new_display",
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path "&")
                                                                        []
                                                                        [
                                                                          Ty.path
                                                                            "move_core_types::language_storage::StructTag"
                                                                        ]
                                                                    ]
                                                                  |),
                                                                  [
                                                                    M.alloc (|
                                                                      M.call_closure (|
                                                                        M.get_associated_function (|
                                                                          Ty.apply
                                                                            (Ty.path
                                                                              "alloc::collections::btree::map::entry::OccupiedEntry")
                                                                            []
                                                                            [
                                                                              Ty.path
                                                                                "move_core_types::language_storage::StructTag";
                                                                              Ty.apply
                                                                                (Ty.path
                                                                                  "move_core_types::effects::Op")
                                                                                []
                                                                                [
                                                                                  Ty.apply
                                                                                    (Ty.path
                                                                                      "alloc::vec::Vec")
                                                                                    []
                                                                                    [
                                                                                      Ty.path "u8";
                                                                                      Ty.path
                                                                                        "alloc::alloc::Global"
                                                                                    ]
                                                                                ];
                                                                              Ty.path
                                                                                "alloc::alloc::Global"
                                                                            ],
                                                                          "key",
                                                                          []
                                                                        |),
                                                                        [ entry ]
                                                                      |)
                                                                    |)
                                                                  ]
                                                                |)
                                                              ]
                                                          |))
                                                      ]
                                                    |)
                                                  ]
                                                |)
                                              |) in
                                            res
                                          |)
                                        ]
                                      |)
                                    ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "alloc::collections::btree::map::entry::Entry::Vacant",
                              0
                            |) in
                          let entry := M.copy (| γ0_0 |) in
                          let~ _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::collections::btree::map::entry::VacantEntry")
                                    []
                                    [
                                      Ty.path "move_core_types::language_storage::StructTag";
                                      Ty.apply
                                        (Ty.path "move_core_types::effects::Op")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            []
                                            [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                        ];
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  "insert",
                                  []
                                |),
                                [ M.read (| entry |); M.read (| op |) ]
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.alloc (| Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ] |)
              |)))
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_add_resource_op :
      M.IsAssociatedFunction Self "add_resource_op" add_resource_op.
    
    (*
        pub fn into_inner(
            self,
        ) -> (
            BTreeMap<Identifier, Op<Vec<u8>>>,
            BTreeMap<StructTag, Op<Vec<u8>>>,
        ) {
            (self.modules, self.resources)
        }
    *)
    Definition into_inner (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.Tuple
            [
              M.read (|
                M.SubPointer.get_struct_record_field (|
                  self,
                  "move_core_types::effects::AccountChangeSet",
                  "modules"
                |)
              |);
              M.read (|
                M.SubPointer.get_struct_record_field (|
                  self,
                  "move_core_types::effects::AccountChangeSet",
                  "resources"
                |)
              |)
            ]))
      | _, _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_into_inner : M.IsAssociatedFunction Self "into_inner" into_inner.
    
    (*
        pub fn into_resources(self) -> BTreeMap<StructTag, Op<Vec<u8>>> {
            self.resources
        }
    *)
    Definition into_resources (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.SubPointer.get_struct_record_field (|
              self,
              "move_core_types::effects::AccountChangeSet",
              "resources"
            |)
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_into_resources :
      M.IsAssociatedFunction Self "into_resources" into_resources.
    
    (*
        pub fn into_modules(self) -> BTreeMap<Identifier, Op<Vec<u8>>> {
            self.modules
        }
    *)
    Definition into_modules (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.SubPointer.get_struct_record_field (|
              self,
              "move_core_types::effects::AccountChangeSet",
              "modules"
            |)
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_into_modules : M.IsAssociatedFunction Self "into_modules" into_modules.
    
    (*
        pub fn modules(&self) -> &BTreeMap<Identifier, Op<Vec<u8>>> {
            &self.modules
        }
    *)
    Definition modules (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.SubPointer.get_struct_record_field (|
            M.read (| self |),
            "move_core_types::effects::AccountChangeSet",
            "modules"
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_modules : M.IsAssociatedFunction Self "modules" modules.
    
    (*
        pub fn resources(&self) -> &BTreeMap<StructTag, Op<Vec<u8>>> {
            &self.resources
        }
    *)
    Definition resources (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.SubPointer.get_struct_record_field (|
            M.read (| self |),
            "move_core_types::effects::AccountChangeSet",
            "resources"
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_resources : M.IsAssociatedFunction Self "resources" resources.
    
    (*
        pub fn is_empty(&self) -> bool {
            self.modules.is_empty() && self.resources.is_empty()
        }
    *)
    Definition is_empty (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          LogicalOp.and (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "alloc::collections::btree::map::BTreeMap")
                  []
                  [
                    Ty.path "move_core_types::identifier::Identifier";
                    Ty.apply
                      (Ty.path "move_core_types::effects::Op")
                      []
                      [
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                      ];
                    Ty.path "alloc::alloc::Global"
                  ],
                "is_empty",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "move_core_types::effects::AccountChangeSet",
                  "modules"
                |)
              ]
            |),
            ltac:(M.monadic
              (M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::BTreeMap")
                    []
                    [
                      Ty.path "move_core_types::language_storage::StructTag";
                      Ty.apply
                        (Ty.path "move_core_types::effects::Op")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                        ];
                      Ty.path "alloc::alloc::Global"
                    ],
                  "is_empty",
                  []
                |),
                [
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "move_core_types::effects::AccountChangeSet",
                    "resources"
                  |)
                ]
              |)))
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_is_empty : M.IsAssociatedFunction Self "is_empty" is_empty.
    
    (*
        pub fn squash(&mut self, other: Self) -> Result<()> {
            squash(&mut self.modules, other.modules)?;
            squash(&mut self.resources, other.resources)
        }
    *)
    Definition squash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::ops::try_trait::Try",
                          Ty.apply
                            (Ty.path "core::result::Result")
                            []
                            [ Ty.tuple []; Ty.path "anyhow::Error" ],
                          [],
                          "branch",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_function (|
                              "move_core_types::effects::squash",
                              [
                                Ty.path "move_core_types::identifier::Identifier";
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  []
                                  [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                              ]
                            |),
                            [
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "move_core_types::effects::AccountChangeSet",
                                "modules"
                              |);
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  other,
                                  "move_core_types::effects::AccountChangeSet",
                                  "modules"
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::ops::control_flow::ControlFlow::Break",
                              0
                            |) in
                          let residual := M.copy (| γ0_0 |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::ops::try_trait::FromResidual",
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [ Ty.tuple []; Ty.path "anyhow::Error" ],
                                      [
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.path "core::convert::Infallible";
                                            Ty.path "anyhow::Error"
                                          ]
                                      ],
                                      "from_residual",
                                      []
                                    |),
                                    [ M.read (| residual |) ]
                                  |)
                                |)
                              |)
                            |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::ops::control_flow::ControlFlow::Continue",
                              0
                            |) in
                          let val := M.copy (| γ0_0 |) in
                          val))
                    ]
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_function (|
                      "move_core_types::effects::squash",
                      [
                        Ty.path "move_core_types::language_storage::StructTag";
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                      ]
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "move_core_types::effects::AccountChangeSet",
                        "resources"
                      |);
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          other,
                          "move_core_types::effects::AccountChangeSet",
                          "resources"
                        |)
                      |)
                    ]
                  |)
                |)
              |)))
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_squash : M.IsAssociatedFunction Self "squash" squash.
  End Impl_move_core_types_effects_AccountChangeSet.
  
  (* StructRecord
    {
      name := "ChangeSet";
      const_params := [];
      ty_params := [];
      fields :=
        [
          ("accounts",
            Ty.apply
              (Ty.path "alloc::collections::btree::map::BTreeMap")
              []
              [
                Ty.path "move_core_types::account_address::AccountAddress";
                Ty.path "move_core_types::effects::AccountChangeSet";
                Ty.path "alloc::alloc::Global"
              ])
        ];
    } *)
  
  Module Impl_core_fmt_Debug_for_move_core_types_effects_ChangeSet.
    Definition Self : Ty.t := Ty.path "move_core_types::effects::ChangeSet".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field1_finish",
              []
            |),
            [
              M.read (| f |);
              M.read (| Value.String "ChangeSet" |);
              M.read (| Value.String "accounts" |);
              (* Unsize *)
              M.pointer_coercion
                (M.alloc (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "move_core_types::effects::ChangeSet",
                    "accounts"
                  |)
                |))
            ]
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_core_types_effects_ChangeSet.
  
  Module Impl_core_clone_Clone_for_move_core_types_effects_ChangeSet.
    Definition Self : Ty.t := Ty.path "move_core_types::effects::ChangeSet".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "move_core_types::effects::ChangeSet"
            [
              ("accounts",
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply
                      (Ty.path "alloc::collections::btree::map::BTreeMap")
                      []
                      [
                        Ty.path "move_core_types::account_address::AccountAddress";
                        Ty.path "move_core_types::effects::AccountChangeSet";
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    "clone",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "move_core_types::effects::ChangeSet",
                      "accounts"
                    |)
                  ]
                |))
            ]))
      | _, _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_core_types_effects_ChangeSet.
  
  Module Impl_core_marker_StructuralEq_for_move_core_types_effects_ChangeSet.
    Definition Self : Ty.t := Ty.path "move_core_types::effects::ChangeSet".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralEq_for_move_core_types_effects_ChangeSet.
  
  Module Impl_core_cmp_Eq_for_move_core_types_effects_ChangeSet.
    Definition Self : Ty.t := Ty.path "move_core_types::effects::ChangeSet".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
            |)
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_core_types_effects_ChangeSet.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_core_types_effects_ChangeSet.
    Definition Self : Ty.t := Ty.path "move_core_types::effects::ChangeSet".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_core_types_effects_ChangeSet.
  
  Module Impl_core_cmp_PartialEq_for_move_core_types_effects_ChangeSet.
    Definition Self : Ty.t := Ty.path "move_core_types::effects::ChangeSet".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::cmp::PartialEq",
              Ty.apply
                (Ty.path "alloc::collections::btree::map::BTreeMap")
                []
                [
                  Ty.path "move_core_types::account_address::AccountAddress";
                  Ty.path "move_core_types::effects::AccountChangeSet";
                  Ty.path "alloc::alloc::Global"
                ],
              [
                Ty.apply
                  (Ty.path "alloc::collections::btree::map::BTreeMap")
                  []
                  [
                    Ty.path "move_core_types::account_address::AccountAddress";
                    Ty.path "move_core_types::effects::AccountChangeSet";
                    Ty.path "alloc::alloc::Global"
                  ]
              ],
              "eq",
              []
            |),
            [
              M.SubPointer.get_struct_record_field (|
                M.read (| self |),
                "move_core_types::effects::ChangeSet",
                "accounts"
              |);
              M.SubPointer.get_struct_record_field (|
                M.read (| other |),
                "move_core_types::effects::ChangeSet",
                "accounts"
              |)
            ]
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_move_core_types_effects_ChangeSet.
  
  Module Impl_core_cmp_Ord_for_move_core_types_effects_ChangeSet.
    Definition Self : Ty.t := Ty.path "move_core_types::effects::ChangeSet".
    
    (* Ord *)
    Definition cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::cmp::Ord",
              Ty.apply
                (Ty.path "alloc::collections::btree::map::BTreeMap")
                []
                [
                  Ty.path "move_core_types::account_address::AccountAddress";
                  Ty.path "move_core_types::effects::AccountChangeSet";
                  Ty.path "alloc::alloc::Global"
                ],
              [],
              "cmp",
              []
            |),
            [
              M.SubPointer.get_struct_record_field (|
                M.read (| self |),
                "move_core_types::effects::ChangeSet",
                "accounts"
              |);
              M.SubPointer.get_struct_record_field (|
                M.read (| other |),
                "move_core_types::effects::ChangeSet",
                "accounts"
              |)
            ]
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Ord"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
  End Impl_core_cmp_Ord_for_move_core_types_effects_ChangeSet.
  
  Module Impl_core_cmp_PartialOrd_for_move_core_types_effects_ChangeSet.
    Definition Self : Ty.t := Ty.path "move_core_types::effects::ChangeSet".
    
    (* PartialOrd *)
    Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.apply
                (Ty.path "alloc::collections::btree::map::BTreeMap")
                []
                [
                  Ty.path "move_core_types::account_address::AccountAddress";
                  Ty.path "move_core_types::effects::AccountChangeSet";
                  Ty.path "alloc::alloc::Global"
                ],
              [
                Ty.apply
                  (Ty.path "alloc::collections::btree::map::BTreeMap")
                  []
                  [
                    Ty.path "move_core_types::account_address::AccountAddress";
                    Ty.path "move_core_types::effects::AccountChangeSet";
                    Ty.path "alloc::alloc::Global"
                  ]
              ],
              "partial_cmp",
              []
            |),
            [
              M.SubPointer.get_struct_record_field (|
                M.read (| self |),
                "move_core_types::effects::ChangeSet",
                "accounts"
              |);
              M.SubPointer.get_struct_record_field (|
                M.read (| other |),
                "move_core_types::effects::ChangeSet",
                "accounts"
              |)
            ]
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_for_move_core_types_effects_ChangeSet.
  
  Module Impl_core_default_Default_for_move_core_types_effects_ChangeSet.
    Definition Self : Ty.t := Ty.path "move_core_types::effects::ChangeSet".
    
    (*
        fn default() -> Self {
            Self::new()
        }
    *)
    Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (M.call_closure (|
            M.get_associated_function (|
              Ty.path "move_core_types::effects::ChangeSet",
              "new",
              []
            |),
            []
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::default::Default"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("default", InstanceField.Method default) ].
  End Impl_core_default_Default_for_move_core_types_effects_ChangeSet.
  
  Module Impl_move_core_types_effects_ChangeSet.
    Definition Self : Ty.t := Ty.path "move_core_types::effects::ChangeSet".
    
    (*
        pub fn new() -> Self {
            Self {
                accounts: BTreeMap::new(),
            }
        }
    *)
    Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (Value.StructRecord
            "move_core_types::effects::ChangeSet"
            [
              ("accounts",
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::collections::btree::map::BTreeMap")
                      []
                      [
                        Ty.path "move_core_types::account_address::AccountAddress";
                        Ty.path "move_core_types::effects::AccountChangeSet";
                        Ty.path "alloc::alloc::Global"
                      ],
                    "new",
                    []
                  |),
                  []
                |))
            ]))
      | _, _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
    
    (*
        pub fn add_account_changeset(
            &mut self,
            addr: AccountAddress,
            account_changeset: AccountChangeSet,
        ) -> Result<()> {
            match self.accounts.entry(addr) {
                btree_map::Entry::Occupied(_) => bail!(
                    "Failed to add account change set. Account {} already exists.",
                    addr
                ),
                btree_map::Entry::Vacant(entry) => {
                    entry.insert(account_changeset);
                }
            }
    
            Ok(())
        }
    *)
    Definition add_account_changeset (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; addr; account_changeset ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let addr := M.alloc (| addr |) in
          let account_changeset := M.alloc (| account_changeset |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::collections::btree::map::BTreeMap")
                            []
                            [
                              Ty.path "move_core_types::account_address::AccountAddress";
                              Ty.path "move_core_types::effects::AccountChangeSet";
                              Ty.path "alloc::alloc::Global"
                            ],
                          "entry",
                          []
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "move_core_types::effects::ChangeSet",
                            "accounts"
                          |);
                          M.read (| addr |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "alloc::collections::btree::map::entry::Entry::Occupied",
                              0
                            |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Err"
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "anyhow::Error",
                                          "msg",
                                          [ Ty.path "alloc::string::String" ]
                                        |),
                                        [
                                          M.read (|
                                            let~ res :=
                                              M.alloc (|
                                                M.call_closure (|
                                                  M.get_function (| "alloc::fmt::format", [] |),
                                                  [
                                                    M.call_closure (|
                                                      M.get_associated_function (|
                                                        Ty.path "core::fmt::Arguments",
                                                        "new_v1",
                                                        []
                                                      |),
                                                      [
                                                        (* Unsize *)
                                                        M.pointer_coercion
                                                          (M.alloc (|
                                                            Value.Array
                                                              [
                                                                M.read (|
                                                                  Value.String
                                                                    "Failed to add account change set. Account "
                                                                |);
                                                                M.read (|
                                                                  Value.String " already exists."
                                                                |)
                                                              ]
                                                          |));
                                                        (* Unsize *)
                                                        M.pointer_coercion
                                                          (M.alloc (|
                                                            Value.Array
                                                              [
                                                                M.call_closure (|
                                                                  M.get_associated_function (|
                                                                    Ty.path
                                                                      "core::fmt::rt::Argument",
                                                                    "new_display",
                                                                    [
                                                                      Ty.path
                                                                        "move_core_types::account_address::AccountAddress"
                                                                    ]
                                                                  |),
                                                                  [ addr ]
                                                                |)
                                                              ]
                                                          |))
                                                      ]
                                                    |)
                                                  ]
                                                |)
                                              |) in
                                            res
                                          |)
                                        ]
                                      |)
                                    ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "alloc::collections::btree::map::entry::Entry::Vacant",
                              0
                            |) in
                          let entry := M.copy (| γ0_0 |) in
                          let~ _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::collections::btree::map::entry::VacantEntry")
                                    []
                                    [
                                      Ty.path "move_core_types::account_address::AccountAddress";
                                      Ty.path "move_core_types::effects::AccountChangeSet";
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  "insert",
                                  []
                                |),
                                [ M.read (| entry |); M.read (| account_changeset |) ]
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.alloc (| Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ] |)
              |)))
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_add_account_changeset :
      M.IsAssociatedFunction Self "add_account_changeset" add_account_changeset.
    
    (*
        pub fn accounts(&self) -> &BTreeMap<AccountAddress, AccountChangeSet> {
            &self.accounts
        }
    *)
    Definition accounts (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.SubPointer.get_struct_record_field (|
            M.read (| self |),
            "move_core_types::effects::ChangeSet",
            "accounts"
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_accounts : M.IsAssociatedFunction Self "accounts" accounts.
    
    (*
        pub fn into_inner(self) -> BTreeMap<AccountAddress, AccountChangeSet> {
            self.accounts
        }
    *)
    Definition into_inner (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.SubPointer.get_struct_record_field (|
              self,
              "move_core_types::effects::ChangeSet",
              "accounts"
            |)
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_into_inner : M.IsAssociatedFunction Self "into_inner" into_inner.
    
    (*
        fn get_or_insert_account_changeset(&mut self, addr: AccountAddress) -> &mut AccountChangeSet {
            match self.accounts.entry(addr) {
                btree_map::Entry::Occupied(entry) => entry.into_mut(),
                btree_map::Entry::Vacant(entry) => entry.insert(AccountChangeSet::new()),
            }
        }
    *)
    Definition get_or_insert_account_changeset
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self; addr ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let addr := M.alloc (| addr |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::collections::btree::map::BTreeMap")
                      []
                      [
                        Ty.path "move_core_types::account_address::AccountAddress";
                        Ty.path "move_core_types::effects::AccountChangeSet";
                        Ty.path "alloc::alloc::Global"
                      ],
                    "entry",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "move_core_types::effects::ChangeSet",
                      "accounts"
                    |);
                    M.read (| addr |)
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "alloc::collections::btree::map::entry::Entry::Occupied",
                        0
                      |) in
                    let entry := M.copy (| γ0_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::collections::btree::map::entry::OccupiedEntry")
                            []
                            [
                              Ty.path "move_core_types::account_address::AccountAddress";
                              Ty.path "move_core_types::effects::AccountChangeSet";
                              Ty.path "alloc::alloc::Global"
                            ],
                          "into_mut",
                          []
                        |),
                        [ M.read (| entry |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "alloc::collections::btree::map::entry::Entry::Vacant",
                        0
                      |) in
                    let entry := M.copy (| γ0_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::collections::btree::map::entry::VacantEntry")
                            []
                            [
                              Ty.path "move_core_types::account_address::AccountAddress";
                              Ty.path "move_core_types::effects::AccountChangeSet";
                              Ty.path "alloc::alloc::Global"
                            ],
                          "insert",
                          []
                        |),
                        [
                          M.read (| entry |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "move_core_types::effects::AccountChangeSet",
                              "new",
                              []
                            |),
                            []
                          |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_get_or_insert_account_changeset :
      M.IsAssociatedFunction Self "get_or_insert_account_changeset" get_or_insert_account_changeset.
    
    (*
        pub fn add_module_op(&mut self, module_id: ModuleId, op: Op<Vec<u8>>) -> Result<()> {
            let account = self.get_or_insert_account_changeset( *module_id.address());
            account.add_module_op(module_id.name().to_owned(), op)
        }
    *)
    Definition add_module_op (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; module_id; op ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let module_id := M.alloc (| module_id |) in
          let op := M.alloc (| op |) in
          M.read (|
            let~ account :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "move_core_types::effects::ChangeSet",
                    "get_or_insert_account_changeset",
                    []
                  |),
                  [
                    M.read (| self |);
                    M.read (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "move_core_types::language_storage::ModuleId",
                          "address",
                          []
                        |),
                        [ module_id ]
                      |)
                    |)
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "move_core_types::effects::AccountChangeSet",
                  "add_module_op",
                  []
                |),
                [
                  M.read (| account |);
                  M.call_closure (|
                    M.get_trait_method (|
                      "alloc::borrow::ToOwned",
                      Ty.path "move_core_types::identifier::IdentStr",
                      [],
                      "to_owned",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "move_core_types::language_storage::ModuleId",
                          "name",
                          []
                        |),
                        [ module_id ]
                      |)
                    ]
                  |);
                  M.read (| op |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_add_module_op :
      M.IsAssociatedFunction Self "add_module_op" add_module_op.
    
    (*
        pub fn add_resource_op(
            &mut self,
            addr: AccountAddress,
            struct_tag: StructTag,
            op: Op<Vec<u8>>,
        ) -> Result<()> {
            let account = self.get_or_insert_account_changeset(addr);
            account.add_resource_op(struct_tag, op)
        }
    *)
    Definition add_resource_op (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; addr; struct_tag; op ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let addr := M.alloc (| addr |) in
          let struct_tag := M.alloc (| struct_tag |) in
          let op := M.alloc (| op |) in
          M.read (|
            let~ account :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "move_core_types::effects::ChangeSet",
                    "get_or_insert_account_changeset",
                    []
                  |),
                  [ M.read (| self |); M.read (| addr |) ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "move_core_types::effects::AccountChangeSet",
                  "add_resource_op",
                  []
                |),
                [ M.read (| account |); M.read (| struct_tag |); M.read (| op |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_add_resource_op :
      M.IsAssociatedFunction Self "add_resource_op" add_resource_op.
    
    (*
        pub fn squash(&mut self, other: Self) -> Result<()> {
            for (addr, other_account_changeset) in other.accounts {
                match self.accounts.entry(addr) {
                    btree_map::Entry::Occupied(mut entry) => {
                        entry.get_mut().squash(other_account_changeset)?;
                    }
                    btree_map::Entry::Vacant(entry) => {
                        entry.insert(other_account_changeset);
                    }
                }
            }
            Ok(())
        }
    *)
    Definition squash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ :=
                  M.use
                    (M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::iter::traits::collect::IntoIterator",
                            Ty.apply
                              (Ty.path "alloc::collections::btree::map::BTreeMap")
                              []
                              [
                                Ty.path "move_core_types::account_address::AccountAddress";
                                Ty.path "move_core_types::effects::AccountChangeSet";
                                Ty.path "alloc::alloc::Global"
                              ],
                            [],
                            "into_iter",
                            []
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                other,
                                "move_core_types::effects::ChangeSet",
                                "accounts"
                              |)
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let iter := M.copy (| γ |) in
                            M.loop (|
                              ltac:(M.monadic
                                (let~ _ :=
                                  M.match_operator (|
                                    M.alloc (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::iter::traits::iterator::Iterator",
                                          Ty.apply
                                            (Ty.path "alloc::collections::btree::map::IntoIter")
                                            []
                                            [
                                              Ty.path
                                                "move_core_types::account_address::AccountAddress";
                                              Ty.path "move_core_types::effects::AccountChangeSet";
                                              Ty.path "alloc::alloc::Global"
                                            ],
                                          [],
                                          "next",
                                          []
                                        |),
                                        [ iter ]
                                      |)
                                    |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let _ :=
                                            M.is_struct_tuple (|
                                              γ,
                                              "core::option::Option::None"
                                            |) in
                                          M.alloc (|
                                            M.never_to_any (| M.read (| M.break (||) |) |)
                                          |)));
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 :=
                                            M.SubPointer.get_struct_tuple_field (|
                                              γ,
                                              "core::option::Option::Some",
                                              0
                                            |) in
                                          let γ1_0 := M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                                          let γ1_1 := M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                                          let addr := M.copy (| γ1_0 |) in
                                          let other_account_changeset := M.copy (| γ1_1 |) in
                                          M.match_operator (|
                                            M.alloc (|
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::btree::map::BTreeMap")
                                                    []
                                                    [
                                                      Ty.path
                                                        "move_core_types::account_address::AccountAddress";
                                                      Ty.path
                                                        "move_core_types::effects::AccountChangeSet";
                                                      Ty.path "alloc::alloc::Global"
                                                    ],
                                                  "entry",
                                                  []
                                                |),
                                                [
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.read (| self |),
                                                    "move_core_types::effects::ChangeSet",
                                                    "accounts"
                                                  |);
                                                  M.read (| addr |)
                                                ]
                                              |)
                                            |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let γ0_0 :=
                                                    M.SubPointer.get_struct_tuple_field (|
                                                      γ,
                                                      "alloc::collections::btree::map::entry::Entry::Occupied",
                                                      0
                                                    |) in
                                                  let entry := M.copy (| γ0_0 |) in
                                                  let~ _ :=
                                                    M.match_operator (|
                                                      M.alloc (|
                                                        M.call_closure (|
                                                          M.get_trait_method (|
                                                            "core::ops::try_trait::Try",
                                                            Ty.apply
                                                              (Ty.path "core::result::Result")
                                                              []
                                                              [ Ty.tuple []; Ty.path "anyhow::Error"
                                                              ],
                                                            [],
                                                            "branch",
                                                            []
                                                          |),
                                                          [
                                                            M.call_closure (|
                                                              M.get_associated_function (|
                                                                Ty.path
                                                                  "move_core_types::effects::AccountChangeSet",
                                                                "squash",
                                                                []
                                                              |),
                                                              [
                                                                M.call_closure (|
                                                                  M.get_associated_function (|
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "alloc::collections::btree::map::entry::OccupiedEntry")
                                                                      []
                                                                      [
                                                                        Ty.path
                                                                          "move_core_types::account_address::AccountAddress";
                                                                        Ty.path
                                                                          "move_core_types::effects::AccountChangeSet";
                                                                        Ty.path
                                                                          "alloc::alloc::Global"
                                                                      ],
                                                                    "get_mut",
                                                                    []
                                                                  |),
                                                                  [ entry ]
                                                                |);
                                                                M.read (| other_account_changeset |)
                                                              ]
                                                            |)
                                                          ]
                                                        |)
                                                      |),
                                                      [
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (let γ0_0 :=
                                                              M.SubPointer.get_struct_tuple_field (|
                                                                γ,
                                                                "core::ops::control_flow::ControlFlow::Break",
                                                                0
                                                              |) in
                                                            let residual := M.copy (| γ0_0 |) in
                                                            M.alloc (|
                                                              M.never_to_any (|
                                                                M.read (|
                                                                  M.return_ (|
                                                                    M.call_closure (|
                                                                      M.get_trait_method (|
                                                                        "core::ops::try_trait::FromResidual",
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "core::result::Result")
                                                                          []
                                                                          [
                                                                            Ty.tuple [];
                                                                            Ty.path "anyhow::Error"
                                                                          ],
                                                                        [
                                                                          Ty.apply
                                                                            (Ty.path
                                                                              "core::result::Result")
                                                                            []
                                                                            [
                                                                              Ty.path
                                                                                "core::convert::Infallible";
                                                                              Ty.path
                                                                                "anyhow::Error"
                                                                            ]
                                                                        ],
                                                                        "from_residual",
                                                                        []
                                                                      |),
                                                                      [ M.read (| residual |) ]
                                                                    |)
                                                                  |)
                                                                |)
                                                              |)
                                                            |)));
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (let γ0_0 :=
                                                              M.SubPointer.get_struct_tuple_field (|
                                                                γ,
                                                                "core::ops::control_flow::ControlFlow::Continue",
                                                                0
                                                              |) in
                                                            let val := M.copy (| γ0_0 |) in
                                                            val))
                                                      ]
                                                    |) in
                                                  M.alloc (| Value.Tuple [] |)));
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let γ0_0 :=
                                                    M.SubPointer.get_struct_tuple_field (|
                                                      γ,
                                                      "alloc::collections::btree::map::entry::Entry::Vacant",
                                                      0
                                                    |) in
                                                  let entry := M.copy (| γ0_0 |) in
                                                  let~ _ :=
                                                    M.alloc (|
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.apply
                                                            (Ty.path
                                                              "alloc::collections::btree::map::entry::VacantEntry")
                                                            []
                                                            [
                                                              Ty.path
                                                                "move_core_types::account_address::AccountAddress";
                                                              Ty.path
                                                                "move_core_types::effects::AccountChangeSet";
                                                              Ty.path "alloc::alloc::Global"
                                                            ],
                                                          "insert",
                                                          []
                                                        |),
                                                        [
                                                          M.read (| entry |);
                                                          M.read (| other_account_changeset |)
                                                        ]
                                                      |)
                                                    |) in
                                                  M.alloc (| Value.Tuple [] |)))
                                            ]
                                          |)))
                                    ]
                                  |) in
                                M.alloc (| Value.Tuple [] |)))
                            |)))
                      ]
                    |)) in
                M.alloc (| Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ] |)
              |)))
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_squash : M.IsAssociatedFunction Self "squash" squash.
    
    (*
        pub fn into_modules(self) -> impl Iterator<Item = (ModuleId, Op<Vec<u8>>)> {
            self.accounts.into_iter().flat_map(|(addr, account)| {
                account
                    .modules
                    .into_iter()
                    .map(move |(module_name, blob_opt)| (ModuleId::new(addr, module_name), blob_opt))
            })
        }
    *)
    Definition into_modules (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::iter::traits::iterator::Iterator",
              Ty.apply
                (Ty.path "alloc::collections::btree::map::IntoIter")
                []
                [
                  Ty.path "move_core_types::account_address::AccountAddress";
                  Ty.path "move_core_types::effects::AccountChangeSet";
                  Ty.path "alloc::alloc::Global"
                ],
              [],
              "flat_map",
              [
                Ty.apply
                  (Ty.path "core::iter::adapters::map::Map")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloc::collections::btree::map::IntoIter")
                      []
                      [
                        Ty.path "move_core_types::identifier::Identifier";
                        Ty.apply
                          (Ty.path "move_core_types::effects::Op")
                          []
                          [
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                          ];
                        Ty.path "alloc::alloc::Global"
                      ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.tuple
                              [
                                Ty.path "move_core_types::identifier::Identifier";
                                Ty.apply
                                  (Ty.path "move_core_types::effects::Op")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      []
                                      [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                  ]
                              ]
                          ]
                      ]
                      (Ty.tuple
                        [
                          Ty.path "move_core_types::language_storage::ModuleId";
                          Ty.apply
                            (Ty.path "move_core_types::effects::Op")
                            []
                            [
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                            ]
                        ])
                  ];
                Ty.function
                  [
                    Ty.tuple
                      [
                        Ty.tuple
                          [
                            Ty.path "move_core_types::account_address::AccountAddress";
                            Ty.path "move_core_types::effects::AccountChangeSet"
                          ]
                      ]
                  ]
                  (Ty.apply
                    (Ty.path "core::iter::adapters::map::Map")
                    []
                    [
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::IntoIter")
                        []
                        [
                          Ty.path "move_core_types::identifier::Identifier";
                          Ty.apply
                            (Ty.path "move_core_types::effects::Op")
                            []
                            [
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                            ];
                          Ty.path "alloc::alloc::Global"
                        ];
                      Ty.function
                        [
                          Ty.tuple
                            [
                              Ty.tuple
                                [
                                  Ty.path "move_core_types::identifier::Identifier";
                                  Ty.apply
                                    (Ty.path "move_core_types::effects::Op")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::vec::Vec")
                                        []
                                        [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                    ]
                                ]
                            ]
                        ]
                        (Ty.tuple
                          [
                            Ty.path "move_core_types::language_storage::ModuleId";
                            Ty.apply
                              (Ty.path "move_core_types::effects::Op")
                              []
                              [
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  []
                                  [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                              ]
                          ])
                    ])
              ]
            |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::collect::IntoIterator",
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::BTreeMap")
                    []
                    [
                      Ty.path "move_core_types::account_address::AccountAddress";
                      Ty.path "move_core_types::effects::AccountChangeSet";
                      Ty.path "alloc::alloc::Global"
                    ],
                  [],
                  "into_iter",
                  []
                |),
                [
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      self,
                      "move_core_types::effects::ChangeSet",
                      "accounts"
                    |)
                  |)
                ]
              |);
              M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      M.match_operator (|
                        M.alloc (| α0 |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let addr := M.copy (| γ0_0 |) in
                              let account := M.copy (| γ0_1 |) in
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::iter::traits::iterator::Iterator",
                                  Ty.apply
                                    (Ty.path "alloc::collections::btree::map::IntoIter")
                                    []
                                    [
                                      Ty.path "move_core_types::identifier::Identifier";
                                      Ty.apply
                                        (Ty.path "move_core_types::effects::Op")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            []
                                            [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                        ];
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  [],
                                  "map",
                                  [
                                    Ty.tuple
                                      [
                                        Ty.path "move_core_types::language_storage::ModuleId";
                                        Ty.apply
                                          (Ty.path "move_core_types::effects::Op")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              []
                                              [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                          ]
                                      ];
                                    Ty.function
                                      [
                                        Ty.tuple
                                          [
                                            Ty.tuple
                                              [
                                                Ty.path "move_core_types::identifier::Identifier";
                                                Ty.apply
                                                  (Ty.path "move_core_types::effects::Op")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "alloc::vec::Vec")
                                                      []
                                                      [ Ty.path "u8"; Ty.path "alloc::alloc::Global"
                                                      ]
                                                  ]
                                              ]
                                          ]
                                      ]
                                      (Ty.tuple
                                        [
                                          Ty.path "move_core_types::language_storage::ModuleId";
                                          Ty.apply
                                            (Ty.path "move_core_types::effects::Op")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::vec::Vec")
                                                []
                                                [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                            ]
                                        ])
                                  ]
                                |),
                                [
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::iter::traits::collect::IntoIterator",
                                      Ty.apply
                                        (Ty.path "alloc::collections::btree::map::BTreeMap")
                                        []
                                        [
                                          Ty.path "move_core_types::identifier::Identifier";
                                          Ty.apply
                                            (Ty.path "move_core_types::effects::Op")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::vec::Vec")
                                                []
                                                [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                            ];
                                          Ty.path "alloc::alloc::Global"
                                        ],
                                      [],
                                      "into_iter",
                                      []
                                    |),
                                    [
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          account,
                                          "move_core_types::effects::AccountChangeSet",
                                          "modules"
                                        |)
                                      |)
                                    ]
                                  |);
                                  M.closure
                                    (fun γ =>
                                      ltac:(M.monadic
                                        match γ with
                                        | [ α0 ] =>
                                          M.match_operator (|
                                            M.alloc (| α0 |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let γ0_0 :=
                                                    M.SubPointer.get_tuple_field (| γ, 0 |) in
                                                  let γ0_1 :=
                                                    M.SubPointer.get_tuple_field (| γ, 1 |) in
                                                  let module_name := M.copy (| γ0_0 |) in
                                                  let blob_opt := M.copy (| γ0_1 |) in
                                                  Value.Tuple
                                                    [
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.path
                                                            "move_core_types::language_storage::ModuleId",
                                                          "new",
                                                          []
                                                        |),
                                                        [
                                                          M.read (| addr |);
                                                          M.read (| module_name |)
                                                        ]
                                                      |);
                                                      M.read (| blob_opt |)
                                                    ]))
                                            ]
                                          |)
                                        | _ => M.impossible (||)
                                        end))
                                ]
                              |)))
                        ]
                      |)
                    | _ => M.impossible (||)
                    end))
            ]
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_into_modules : M.IsAssociatedFunction Self "into_modules" into_modules.
    
    (*
        pub fn modules(&self) -> impl Iterator<Item = (AccountAddress, &Identifier, Op<&[u8]>)> {
            self.accounts.iter().flat_map(|(addr, account)| {
                let addr = *addr;
                account
                    .modules
                    .iter()
                    .map(move |(module_name, op)| (addr, module_name, op.as_ref().map(|v| v.as_ref())))
            })
        }
    *)
    Definition modules (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::iter::traits::iterator::Iterator",
              Ty.apply
                (Ty.path "alloc::collections::btree::map::Iter")
                []
                [
                  Ty.path "move_core_types::account_address::AccountAddress";
                  Ty.path "move_core_types::effects::AccountChangeSet"
                ],
              [],
              "flat_map",
              [
                Ty.apply
                  (Ty.path "core::iter::adapters::map::Map")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloc::collections::btree::map::Iter")
                      []
                      [
                        Ty.path "move_core_types::identifier::Identifier";
                        Ty.apply
                          (Ty.path "move_core_types::effects::Op")
                          []
                          [
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                          ]
                      ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.tuple
                              [
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.path "move_core_types::identifier::Identifier" ];
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "move_core_types::effects::Op")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::vec::Vec")
                                          []
                                          [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                      ]
                                  ]
                              ]
                          ]
                      ]
                      (Ty.tuple
                        [
                          Ty.path "move_core_types::account_address::AccountAddress";
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.path "move_core_types::identifier::Identifier" ];
                          Ty.apply
                            (Ty.path "move_core_types::effects::Op")
                            []
                            [
                              Ty.apply
                                (Ty.path "&")
                                []
                                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                            ]
                        ])
                  ];
                Ty.function
                  [
                    Ty.tuple
                      [
                        Ty.tuple
                          [
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.path "move_core_types::account_address::AccountAddress" ];
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.path "move_core_types::effects::AccountChangeSet" ]
                          ]
                      ]
                  ]
                  (Ty.apply
                    (Ty.path "core::iter::adapters::map::Map")
                    []
                    [
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::Iter")
                        []
                        [
                          Ty.path "move_core_types::identifier::Identifier";
                          Ty.apply
                            (Ty.path "move_core_types::effects::Op")
                            []
                            [
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                            ]
                        ];
                      Ty.function
                        [
                          Ty.tuple
                            [
                              Ty.tuple
                                [
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.path "move_core_types::identifier::Identifier" ];
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "move_core_types::effects::Op")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            []
                                            [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                        ]
                                    ]
                                ]
                            ]
                        ]
                        (Ty.tuple
                          [
                            Ty.path "move_core_types::account_address::AccountAddress";
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.path "move_core_types::identifier::Identifier" ];
                            Ty.apply
                              (Ty.path "move_core_types::effects::Op")
                              []
                              [
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                              ]
                          ])
                    ])
              ]
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::BTreeMap")
                    []
                    [
                      Ty.path "move_core_types::account_address::AccountAddress";
                      Ty.path "move_core_types::effects::AccountChangeSet";
                      Ty.path "alloc::alloc::Global"
                    ],
                  "iter",
                  []
                |),
                [
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "move_core_types::effects::ChangeSet",
                    "accounts"
                  |)
                ]
              |);
              M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      M.match_operator (|
                        M.alloc (| α0 |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let addr := M.copy (| γ0_0 |) in
                              let account := M.copy (| γ0_1 |) in
                              M.read (|
                                let~ addr := M.copy (| M.read (| addr |) |) in
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::iter::traits::iterator::Iterator",
                                      Ty.apply
                                        (Ty.path "alloc::collections::btree::map::Iter")
                                        []
                                        [
                                          Ty.path "move_core_types::identifier::Identifier";
                                          Ty.apply
                                            (Ty.path "move_core_types::effects::Op")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::vec::Vec")
                                                []
                                                [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                            ]
                                        ],
                                      [],
                                      "map",
                                      [
                                        Ty.tuple
                                          [
                                            Ty.path
                                              "move_core_types::account_address::AccountAddress";
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [ Ty.path "move_core_types::identifier::Identifier" ];
                                            Ty.apply
                                              (Ty.path "move_core_types::effects::Op")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                              ]
                                          ];
                                        Ty.function
                                          [
                                            Ty.tuple
                                              [
                                                Ty.tuple
                                                  [
                                                    Ty.apply
                                                      (Ty.path "&")
                                                      []
                                                      [
                                                        Ty.path
                                                          "move_core_types::identifier::Identifier"
                                                      ];
                                                    Ty.apply
                                                      (Ty.path "&")
                                                      []
                                                      [
                                                        Ty.apply
                                                          (Ty.path "move_core_types::effects::Op")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path "alloc::vec::Vec")
                                                              []
                                                              [
                                                                Ty.path "u8";
                                                                Ty.path "alloc::alloc::Global"
                                                              ]
                                                          ]
                                                      ]
                                                  ]
                                              ]
                                          ]
                                          (Ty.tuple
                                            [
                                              Ty.path
                                                "move_core_types::account_address::AccountAddress";
                                              Ty.apply
                                                (Ty.path "&")
                                                []
                                                [ Ty.path "move_core_types::identifier::Identifier"
                                                ];
                                              Ty.apply
                                                (Ty.path "move_core_types::effects::Op")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "&")
                                                    []
                                                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ]
                                                    ]
                                                ]
                                            ])
                                      ]
                                    |),
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloc::collections::btree::map::BTreeMap")
                                            []
                                            [
                                              Ty.path "move_core_types::identifier::Identifier";
                                              Ty.apply
                                                (Ty.path "move_core_types::effects::Op")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "alloc::vec::Vec")
                                                    []
                                                    [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                                ];
                                              Ty.path "alloc::alloc::Global"
                                            ],
                                          "iter",
                                          []
                                        |),
                                        [
                                          M.SubPointer.get_struct_record_field (|
                                            M.read (| account |),
                                            "move_core_types::effects::AccountChangeSet",
                                            "modules"
                                          |)
                                        ]
                                      |);
                                      M.closure
                                        (fun γ =>
                                          ltac:(M.monadic
                                            match γ with
                                            | [ α0 ] =>
                                              M.match_operator (|
                                                M.alloc (| α0 |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ0_0 :=
                                                        M.SubPointer.get_tuple_field (| γ, 0 |) in
                                                      let γ0_1 :=
                                                        M.SubPointer.get_tuple_field (| γ, 1 |) in
                                                      let module_name := M.copy (| γ0_0 |) in
                                                      let op := M.copy (| γ0_1 |) in
                                                      Value.Tuple
                                                        [
                                                          M.read (| addr |);
                                                          M.read (| module_name |);
                                                          M.call_closure (|
                                                            M.get_associated_function (|
                                                              Ty.apply
                                                                (Ty.path
                                                                  "move_core_types::effects::Op")
                                                                []
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path "&")
                                                                    []
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path "alloc::vec::Vec")
                                                                        []
                                                                        [
                                                                          Ty.path "u8";
                                                                          Ty.path
                                                                            "alloc::alloc::Global"
                                                                        ]
                                                                    ]
                                                                ],
                                                              "map",
                                                              [
                                                                Ty.function
                                                                  [
                                                                    Ty.tuple
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path "&")
                                                                          []
                                                                          [
                                                                            Ty.apply
                                                                              (Ty.path
                                                                                "alloc::vec::Vec")
                                                                              []
                                                                              [
                                                                                Ty.path "u8";
                                                                                Ty.path
                                                                                  "alloc::alloc::Global"
                                                                              ]
                                                                          ]
                                                                      ]
                                                                  ]
                                                                  (Ty.apply
                                                                    (Ty.path "&")
                                                                    []
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path "slice")
                                                                        []
                                                                        [ Ty.path "u8" ]
                                                                    ]);
                                                                Ty.apply
                                                                  (Ty.path "&")
                                                                  []
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path "slice")
                                                                      []
                                                                      [ Ty.path "u8" ]
                                                                  ]
                                                              ]
                                                            |),
                                                            [
                                                              M.call_closure (|
                                                                M.get_associated_function (|
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "move_core_types::effects::Op")
                                                                    []
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path "alloc::vec::Vec")
                                                                        []
                                                                        [
                                                                          Ty.path "u8";
                                                                          Ty.path
                                                                            "alloc::alloc::Global"
                                                                        ]
                                                                    ],
                                                                  "as_ref",
                                                                  []
                                                                |),
                                                                [ M.read (| op |) ]
                                                              |);
                                                              M.closure
                                                                (fun γ =>
                                                                  ltac:(M.monadic
                                                                    match γ with
                                                                    | [ α0 ] =>
                                                                      M.match_operator (|
                                                                        M.alloc (| α0 |),
                                                                        [
                                                                          fun γ =>
                                                                            ltac:(M.monadic
                                                                              (let v :=
                                                                                M.copy (| γ |) in
                                                                              M.call_closure (|
                                                                                M.get_trait_method (|
                                                                                  "core::convert::AsRef",
                                                                                  Ty.apply
                                                                                    (Ty.path
                                                                                      "alloc::vec::Vec")
                                                                                    []
                                                                                    [
                                                                                      Ty.path "u8";
                                                                                      Ty.path
                                                                                        "alloc::alloc::Global"
                                                                                    ],
                                                                                  [
                                                                                    Ty.apply
                                                                                      (Ty.path
                                                                                        "slice")
                                                                                      []
                                                                                      [ Ty.path "u8"
                                                                                      ]
                                                                                  ],
                                                                                  "as_ref",
                                                                                  []
                                                                                |),
                                                                                [ M.read (| v |) ]
                                                                              |)))
                                                                        ]
                                                                      |)
                                                                    | _ => M.impossible (||)
                                                                    end))
                                                            ]
                                                          |)
                                                        ]))
                                                ]
                                              |)
                                            | _ => M.impossible (||)
                                            end))
                                    ]
                                  |)
                                |)
                              |)))
                        ]
                      |)
                    | _ => M.impossible (||)
                    end))
            ]
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_modules : M.IsAssociatedFunction Self "modules" modules.
    
    (*
        pub fn resources(&self) -> impl Iterator<Item = (AccountAddress, &StructTag, Op<&[u8]>)> {
            self.accounts.iter().flat_map(|(addr, account)| {
                let addr = *addr;
                account
                    .resources
                    .iter()
                    .map(move |(struct_tag, op)| (addr, struct_tag, op.as_ref().map(|v| v.as_ref())))
            })
        }
    *)
    Definition resources (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::iter::traits::iterator::Iterator",
              Ty.apply
                (Ty.path "alloc::collections::btree::map::Iter")
                []
                [
                  Ty.path "move_core_types::account_address::AccountAddress";
                  Ty.path "move_core_types::effects::AccountChangeSet"
                ],
              [],
              "flat_map",
              [
                Ty.apply
                  (Ty.path "core::iter::adapters::map::Map")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloc::collections::btree::map::Iter")
                      []
                      [
                        Ty.path "move_core_types::language_storage::StructTag";
                        Ty.apply
                          (Ty.path "move_core_types::effects::Op")
                          []
                          [
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                          ]
                      ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.tuple
                              [
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.path "move_core_types::language_storage::StructTag" ];
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "move_core_types::effects::Op")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::vec::Vec")
                                          []
                                          [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                      ]
                                  ]
                              ]
                          ]
                      ]
                      (Ty.tuple
                        [
                          Ty.path "move_core_types::account_address::AccountAddress";
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.path "move_core_types::language_storage::StructTag" ];
                          Ty.apply
                            (Ty.path "move_core_types::effects::Op")
                            []
                            [
                              Ty.apply
                                (Ty.path "&")
                                []
                                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                            ]
                        ])
                  ];
                Ty.function
                  [
                    Ty.tuple
                      [
                        Ty.tuple
                          [
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.path "move_core_types::account_address::AccountAddress" ];
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.path "move_core_types::effects::AccountChangeSet" ]
                          ]
                      ]
                  ]
                  (Ty.apply
                    (Ty.path "core::iter::adapters::map::Map")
                    []
                    [
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::Iter")
                        []
                        [
                          Ty.path "move_core_types::language_storage::StructTag";
                          Ty.apply
                            (Ty.path "move_core_types::effects::Op")
                            []
                            [
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                            ]
                        ];
                      Ty.function
                        [
                          Ty.tuple
                            [
                              Ty.tuple
                                [
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.path "move_core_types::language_storage::StructTag" ];
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "move_core_types::effects::Op")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            []
                                            [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                        ]
                                    ]
                                ]
                            ]
                        ]
                        (Ty.tuple
                          [
                            Ty.path "move_core_types::account_address::AccountAddress";
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.path "move_core_types::language_storage::StructTag" ];
                            Ty.apply
                              (Ty.path "move_core_types::effects::Op")
                              []
                              [
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                              ]
                          ])
                    ])
              ]
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::BTreeMap")
                    []
                    [
                      Ty.path "move_core_types::account_address::AccountAddress";
                      Ty.path "move_core_types::effects::AccountChangeSet";
                      Ty.path "alloc::alloc::Global"
                    ],
                  "iter",
                  []
                |),
                [
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "move_core_types::effects::ChangeSet",
                    "accounts"
                  |)
                ]
              |);
              M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      M.match_operator (|
                        M.alloc (| α0 |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let addr := M.copy (| γ0_0 |) in
                              let account := M.copy (| γ0_1 |) in
                              M.read (|
                                let~ addr := M.copy (| M.read (| addr |) |) in
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::iter::traits::iterator::Iterator",
                                      Ty.apply
                                        (Ty.path "alloc::collections::btree::map::Iter")
                                        []
                                        [
                                          Ty.path "move_core_types::language_storage::StructTag";
                                          Ty.apply
                                            (Ty.path "move_core_types::effects::Op")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::vec::Vec")
                                                []
                                                [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                            ]
                                        ],
                                      [],
                                      "map",
                                      [
                                        Ty.tuple
                                          [
                                            Ty.path
                                              "move_core_types::account_address::AccountAddress";
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [
                                                Ty.path
                                                  "move_core_types::language_storage::StructTag"
                                              ];
                                            Ty.apply
                                              (Ty.path "move_core_types::effects::Op")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                              ]
                                          ];
                                        Ty.function
                                          [
                                            Ty.tuple
                                              [
                                                Ty.tuple
                                                  [
                                                    Ty.apply
                                                      (Ty.path "&")
                                                      []
                                                      [
                                                        Ty.path
                                                          "move_core_types::language_storage::StructTag"
                                                      ];
                                                    Ty.apply
                                                      (Ty.path "&")
                                                      []
                                                      [
                                                        Ty.apply
                                                          (Ty.path "move_core_types::effects::Op")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path "alloc::vec::Vec")
                                                              []
                                                              [
                                                                Ty.path "u8";
                                                                Ty.path "alloc::alloc::Global"
                                                              ]
                                                          ]
                                                      ]
                                                  ]
                                              ]
                                          ]
                                          (Ty.tuple
                                            [
                                              Ty.path
                                                "move_core_types::account_address::AccountAddress";
                                              Ty.apply
                                                (Ty.path "&")
                                                []
                                                [
                                                  Ty.path
                                                    "move_core_types::language_storage::StructTag"
                                                ];
                                              Ty.apply
                                                (Ty.path "move_core_types::effects::Op")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "&")
                                                    []
                                                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ]
                                                    ]
                                                ]
                                            ])
                                      ]
                                    |),
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloc::collections::btree::map::BTreeMap")
                                            []
                                            [
                                              Ty.path
                                                "move_core_types::language_storage::StructTag";
                                              Ty.apply
                                                (Ty.path "move_core_types::effects::Op")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "alloc::vec::Vec")
                                                    []
                                                    [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                                ];
                                              Ty.path "alloc::alloc::Global"
                                            ],
                                          "iter",
                                          []
                                        |),
                                        [
                                          M.SubPointer.get_struct_record_field (|
                                            M.read (| account |),
                                            "move_core_types::effects::AccountChangeSet",
                                            "resources"
                                          |)
                                        ]
                                      |);
                                      M.closure
                                        (fun γ =>
                                          ltac:(M.monadic
                                            match γ with
                                            | [ α0 ] =>
                                              M.match_operator (|
                                                M.alloc (| α0 |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ0_0 :=
                                                        M.SubPointer.get_tuple_field (| γ, 0 |) in
                                                      let γ0_1 :=
                                                        M.SubPointer.get_tuple_field (| γ, 1 |) in
                                                      let struct_tag := M.copy (| γ0_0 |) in
                                                      let op := M.copy (| γ0_1 |) in
                                                      Value.Tuple
                                                        [
                                                          M.read (| addr |);
                                                          M.read (| struct_tag |);
                                                          M.call_closure (|
                                                            M.get_associated_function (|
                                                              Ty.apply
                                                                (Ty.path
                                                                  "move_core_types::effects::Op")
                                                                []
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path "&")
                                                                    []
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path "alloc::vec::Vec")
                                                                        []
                                                                        [
                                                                          Ty.path "u8";
                                                                          Ty.path
                                                                            "alloc::alloc::Global"
                                                                        ]
                                                                    ]
                                                                ],
                                                              "map",
                                                              [
                                                                Ty.function
                                                                  [
                                                                    Ty.tuple
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path "&")
                                                                          []
                                                                          [
                                                                            Ty.apply
                                                                              (Ty.path
                                                                                "alloc::vec::Vec")
                                                                              []
                                                                              [
                                                                                Ty.path "u8";
                                                                                Ty.path
                                                                                  "alloc::alloc::Global"
                                                                              ]
                                                                          ]
                                                                      ]
                                                                  ]
                                                                  (Ty.apply
                                                                    (Ty.path "&")
                                                                    []
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path "slice")
                                                                        []
                                                                        [ Ty.path "u8" ]
                                                                    ]);
                                                                Ty.apply
                                                                  (Ty.path "&")
                                                                  []
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path "slice")
                                                                      []
                                                                      [ Ty.path "u8" ]
                                                                  ]
                                                              ]
                                                            |),
                                                            [
                                                              M.call_closure (|
                                                                M.get_associated_function (|
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "move_core_types::effects::Op")
                                                                    []
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path "alloc::vec::Vec")
                                                                        []
                                                                        [
                                                                          Ty.path "u8";
                                                                          Ty.path
                                                                            "alloc::alloc::Global"
                                                                        ]
                                                                    ],
                                                                  "as_ref",
                                                                  []
                                                                |),
                                                                [ M.read (| op |) ]
                                                              |);
                                                              M.closure
                                                                (fun γ =>
                                                                  ltac:(M.monadic
                                                                    match γ with
                                                                    | [ α0 ] =>
                                                                      M.match_operator (|
                                                                        M.alloc (| α0 |),
                                                                        [
                                                                          fun γ =>
                                                                            ltac:(M.monadic
                                                                              (let v :=
                                                                                M.copy (| γ |) in
                                                                              M.call_closure (|
                                                                                M.get_trait_method (|
                                                                                  "core::convert::AsRef",
                                                                                  Ty.apply
                                                                                    (Ty.path
                                                                                      "alloc::vec::Vec")
                                                                                    []
                                                                                    [
                                                                                      Ty.path "u8";
                                                                                      Ty.path
                                                                                        "alloc::alloc::Global"
                                                                                    ],
                                                                                  [
                                                                                    Ty.apply
                                                                                      (Ty.path
                                                                                        "slice")
                                                                                      []
                                                                                      [ Ty.path "u8"
                                                                                      ]
                                                                                  ],
                                                                                  "as_ref",
                                                                                  []
                                                                                |),
                                                                                [ M.read (| v |) ]
                                                                              |)))
                                                                        ]
                                                                      |)
                                                                    | _ => M.impossible (||)
                                                                    end))
                                                            ]
                                                          |)
                                                        ]))
                                                ]
                                              |)
                                            | _ => M.impossible (||)
                                            end))
                                    ]
                                  |)
                                |)
                              |)))
                        ]
                      |)
                    | _ => M.impossible (||)
                    end))
            ]
          |)))
      | _, _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_resources : M.IsAssociatedFunction Self "resources" resources.
  End Impl_move_core_types_effects_ChangeSet.
  
  Axiom Event :
    (Ty.path "move_core_types::effects::Event") =
      (Ty.tuple
        [
          Ty.apply (Ty.path "alloc::vec::Vec") [] [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ];
          Ty.path "u64";
          Ty.path "move_core_types::language_storage::TypeTag";
          Ty.apply (Ty.path "alloc::vec::Vec") [] [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
        ]).
End effects.
