(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module friends.
  (*
  pub fn verify_module(module: &CompiledModule) -> VMResult<()> {
      verify_module_impl(module).map_err(|e| e.finish(Location::Module(module.self_id())))
  }
  *)
  Definition verify_module (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ module ] =>
      ltac:(M.monadic
        (let module := M.alloc (| module |) in
        M.call_closure (|
          M.get_associated_function (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "move_binary_format::errors::PartialVMError" ],
            "map_err",
            [
              Ty.path "move_binary_format::errors::VMError";
              Ty.function
                [ Ty.tuple [ Ty.path "move_binary_format::errors::PartialVMError" ] ]
                (Ty.path "move_binary_format::errors::VMError")
            ]
          |),
          [
            M.call_closure (|
              M.get_function (| "move_bytecode_verifier::friends::verify_module_impl", [] |),
              [ M.read (| module |) ]
            |);
            M.closure
              (fun γ =>
                ltac:(M.monadic
                  match γ with
                  | [ α0 ] =>
                    M.match_operator (|
                      M.alloc (| α0 |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let e := M.copy (| γ |) in
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "move_binary_format::errors::PartialVMError",
                                "finish",
                                []
                              |),
                              [
                                M.read (| e |);
                                Value.StructTuple
                                  "move_binary_format::errors::Location::Module"
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "move_binary_format::file_format::CompiledModule",
                                        "self_id",
                                        []
                                      |),
                                      [ M.read (| module |) ]
                                    |)
                                  ]
                              ]
                            |)))
                      ]
                    |)
                  | _ => M.impossible (||)
                  end))
          ]
        |)))
    | _, _, _ => M.impossible
    end.
  
  Axiom Function_verify_module :
    M.IsFunction "move_bytecode_verifier::friends::verify_module" verify_module.
  
  (*
  fn verify_module_impl(module: &CompiledModule) -> PartialVMResult<()> {
      // cannot make friends with the module itself
      let self_handle = module.self_handle();
      if module.friend_decls().contains(self_handle) {
          return Err(PartialVMError::new(
              StatusCode::INVALID_FRIEND_DECL_WITH_SELF,
          ));
      }
  
      // cannot make friends with modules outside of the account address
      //
      // NOTE: this constraint is a policy decision rather than a technical requirement. The VM and
      // other bytecode verifier passes do not rely on the assumption that friend modules must be
      // declared within the same account address.
      //
      // However, lacking a definite use case of friending modules across account boundaries, and also
      // to minimize the associated changes on the module publishing flow, we temporarily enforce this
      // constraint and we may consider lifting this limitation in the future.
      let self_address =
          module.address_identifier_at(module.module_handle_at(module.self_handle_idx()).address);
      let has_external_friend = module
          .friend_decls()
          .iter()
          .any(|handle| module.address_identifier_at(handle.address) != self_address);
      if has_external_friend {
          return Err(PartialVMError::new(
              StatusCode::INVALID_FRIEND_DECL_WITH_MODULES_OUTSIDE_ACCOUNT_ADDRESS,
          ));
      }
  
      Ok(())
  }
  *)
  Definition verify_module_impl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ module ] =>
      ltac:(M.monadic
        (let module := M.alloc (| module |) in
        M.catch_return (|
          ltac:(M.monadic
            (M.read (|
              let~ self_handle :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "move_binary_format::file_format::CompiledModule",
                      "self_handle",
                      []
                    |),
                    [ M.read (| module |) ]
                  |)
                |) in
              let~ _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "slice")
                                    []
                                    [ Ty.path "move_binary_format::file_format::ModuleHandle" ],
                                  "contains",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "move_binary_format::file_format::CompiledModule",
                                      "friend_decls",
                                      []
                                    |),
                                    [ M.read (| module |) ]
                                  |);
                                  M.read (| self_handle |)
                                ]
                              |)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.read (|
                              M.return_ (|
                                Value.StructTuple
                                  "core::result::Result::Err"
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "move_binary_format::errors::PartialVMError",
                                        "new",
                                        []
                                      |),
                                      [
                                        Value.StructTuple
                                          "move_core_types::vm_status::StatusCode::INVALID_FRIEND_DECL_WITH_SELF"
                                          []
                                      ]
                                    |)
                                  ]
                              |)
                            |)
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let~ self_address :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "move_binary_format::file_format::CompiledModule",
                      "address_identifier_at",
                      []
                    |),
                    [
                      M.read (| module |);
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "move_binary_format::file_format::CompiledModule",
                              "module_handle_at",
                              []
                            |),
                            [
                              M.read (| module |);
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "move_binary_format::file_format::CompiledModule",
                                  "self_handle_idx",
                                  []
                                |),
                                [ M.read (| module |) ]
                              |)
                            ]
                          |),
                          "move_binary_format::file_format::ModuleHandle",
                          "address"
                        |)
                      |)
                    ]
                  |)
                |) in
              let~ has_external_friend :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply
                        (Ty.path "core::slice::iter::Iter")
                        []
                        [ Ty.path "move_binary_format::file_format::ModuleHandle" ],
                      [],
                      "any",
                      [
                        Ty.function
                          [
                            Ty.tuple
                              [
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.path "move_binary_format::file_format::ModuleHandle" ]
                              ]
                          ]
                          (Ty.path "bool")
                      ]
                    |),
                    [
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "slice")
                              []
                              [ Ty.path "move_binary_format::file_format::ModuleHandle" ],
                            "iter",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "move_binary_format::file_format::CompiledModule",
                                "friend_decls",
                                []
                              |),
                              [ M.read (| module |) ]
                            |)
                          ]
                        |)
                      |);
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ α0 ] =>
                              M.match_operator (|
                                M.alloc (| α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let handle := M.copy (| γ |) in
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::cmp::PartialEq",
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [
                                              Ty.path
                                                "move_core_types::account_address::AccountAddress"
                                            ],
                                          [
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [
                                                Ty.path
                                                  "move_core_types::account_address::AccountAddress"
                                              ]
                                          ],
                                          "ne",
                                          []
                                        |),
                                        [
                                          M.alloc (|
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.path
                                                  "move_binary_format::file_format::CompiledModule",
                                                "address_identifier_at",
                                                []
                                              |),
                                              [
                                                M.read (| module |);
                                                M.read (|
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.read (| handle |),
                                                    "move_binary_format::file_format::ModuleHandle",
                                                    "address"
                                                  |)
                                                |)
                                              ]
                                            |)
                                          |);
                                          self_address
                                        ]
                                      |)))
                                ]
                              |)
                            | _ => M.impossible (||)
                            end))
                    ]
                  |)
                |) in
              let~ _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use has_external_friend in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.read (|
                              M.return_ (|
                                Value.StructTuple
                                  "core::result::Result::Err"
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "move_binary_format::errors::PartialVMError",
                                        "new",
                                        []
                                      |),
                                      [
                                        Value.StructTuple
                                          "move_core_types::vm_status::StatusCode::INVALID_FRIEND_DECL_WITH_MODULES_OUTSIDE_ACCOUNT_ADDRESS"
                                          []
                                      ]
                                    |)
                                  ]
                              |)
                            |)
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (| Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ] |)
            |)))
        |)))
    | _, _, _ => M.impossible
    end.
  
  Axiom Function_verify_module_impl :
    M.IsFunction "move_bytecode_verifier::friends::verify_module_impl" verify_module_impl.
End friends.
